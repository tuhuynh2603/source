<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="13.0.4">
<library/>
<procedure name="_Average_Reference_Image">
<interface>
<io>
<par name="TotalSumImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="AverageImage" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c></c>
<l>gen_image_proto (TotalSumImage, ConstImage, 30)</l>
<l>div_image (TotalSumImage, ConstImage, AverageImage, 1, 0)</l>
<l>convert_image_type (AverageImage, AverageImage, 'byte')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Average_Reference_Image">
<parameters>
<parameter id="AverageImage"/>
<parameter id="TotalSumImage"/>
</parameters>
</docu>
</procedure>
<procedure name="_CVL_TeachTupleVector">
<interface>
<ic>
<par name="CVLTupleVector" base_type="ctrl" dimension="3"/>
<par name="CVLTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfRegions" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnRows" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnCols" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
<par name="CVLRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLMatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="CVLMatchModelCenterCol" base_type="ctrl" dimension="0"/>
<par name="CVLContrast" base_type="ctrl" dimension="0"/>
<par name="CVLLength" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="MinCVLHeight" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLTupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<l>CVLTupleVectorOut := CVLTupleVector</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(0,CVLTeachDoc)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(1,NoOfRegions)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(2,CVLRectRgnRows)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(3,CVLRectRgnCols)</l>
<c></c>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(4,NoOfUniquePatterns)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(5,MaxRotationAngle)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(6,PatternSearchAreaAlongX)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(7,PatternSearchAreaAlongY)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(8,MinAcceptanceScore)</l>
<c></c>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(9,CVLDatumRows)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(10,CVLDatumCols)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(11,CVLModelID)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(12,CVLRotationAngle)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(13,CVLMatchModelCenterRow)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(14,CVLMatchModelCenterCol)</l>
<c></c>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(15,CVLContrast)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(16,CVLLength)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(17,MaskSize)</l>
<l>CVLTupleVectorOut.at(FoV-1).at(i).insert(18,MinCVLHeight)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_CVL_TeachTupleVector">
<parameters>
<parameter id="CVLContrast"/>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLLength"/>
<parameter id="CVLMatchModelCenterCol"/>
<parameter id="CVLMatchModelCenterRow"/>
<parameter id="CVLModelID"/>
<parameter id="CVLRectRgnCols"/>
<parameter id="CVLRectRgnRows"/>
<parameter id="CVLRotationAngle"/>
<parameter id="CVLTeachDoc"/>
<parameter id="CVLTupleVector"/>
<parameter id="CVLTupleVectorOut"/>
<parameter id="FoV"/>
<parameter id="MaskSize"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinCVLHeight"/>
<parameter id="NoOfRegions"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_CVLA_TeachTupleVector">
<interface>
<ic>
<par name="CVLATupleVector" base_type="ctrl" dimension="3"/>
<par name="CVLAlignmentTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLARect" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLAModelIDs" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLATeachCols" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLADatum" base_type="ctrl" dimension="0"/>
<par name="CVLADatumModelID" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachCols" base_type="ctrl" dimension="0"/>
<par name="CVLARefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointColumn" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLArectFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRowsFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachColsFL" base_type="ctrl" dimension="0"/>
<par name="MaxDistanceBtnCLFL" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLATupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<l>CVLATupleVectorOut := CVLATupleVector</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(0,CVLAlignmentTeachDoc)</l>
<c></c>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(1,NoOfCVLARect)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(2,MaxRotationAngle)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(3,PatternSearchAreaAlongX)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(4,PatternSearchAreaAlongY)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(5,MinAcceptanceScore)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(6,CVLAModelIDs)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(7,CVLATeachRows)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(8,CVLATeachCols)</l>
<c></c>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(9,NoOfCVLADatum)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(10,CVLADatumModelID)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(11,CVLADatumTeachRows)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(12,CVLADatumTeachCols)</l>
<c></c>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(13,CVLARefRotationAngle)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(14,CVLARefPointRow)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(15,CVLARefPointColumn)</l>
<c></c>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(16,NoOfCVLArectFL)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(17,CVLATeachRowsFL)</l>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(18,CVLATeachColsFL)</l>
<c></c>
<l>CVLATupleVectorOut.at(FoV-1).at(i).insert(19,MaxDistanceBtnCLFL)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_CVLA_TeachTupleVector">
<parameters>
<parameter id="CVLADatumModelID"/>
<parameter id="CVLADatumTeachCols"/>
<parameter id="CVLADatumTeachRows"/>
<parameter id="CVLAModelIDs"/>
<parameter id="CVLARefPointColumn"/>
<parameter id="CVLARefPointRow"/>
<parameter id="CVLARefRotationAngle"/>
<parameter id="CVLATeachCols"/>
<parameter id="CVLATeachColsFL"/>
<parameter id="CVLATeachRows"/>
<parameter id="CVLATeachRowsFL"/>
<parameter id="CVLATupleVector"/>
<parameter id="CVLATupleVectorOut"/>
<parameter id="CVLAlignmentTeachDoc"/>
<parameter id="FoV"/>
<parameter id="MaxDistanceBtnCLFL"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="NoOfCVLADatum"/>
<parameter id="NoOfCVLARect"/>
<parameter id="NoOfCVLArectFL"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_Encap_RegionProjection">
<interface/>
<body>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_Encap_RegionProjection">
<parameters/>
</docu>
</procedure>
<procedure name="_Encap_TeachTupleVector">
<interface>
<ic>
<par name="EncapTupleVector" base_type="ctrl" dimension="3"/>
<par name="EncapTeachDoc" base_type="ctrl" dimension="0"/>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEncapContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfEncapRect4EncapLoc" base_type="ctrl" dimension="0"/>
<par name="EncapRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapRectCols" base_type="ctrl" dimension="0"/>
<par name="NoOfRectangle4EncapInsp" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EncapTupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<c></c>
<l>EncapTupleVectorOut := EncapTupleVector</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(0,EncapTeachDoc)</l>
<c></c>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(1,MinEncapContrast)</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(2,MaxEncapContrast)</l>
<c></c>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(3,NoOfEncapRect4EncapLoc)</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(4,EncapRectRows)</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(5,EncapRectCols)</l>
<c></c>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(6,NoOfRectangle4EncapInsp)</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(7,EncapInspectRectRows)</l>
<l>EncapTupleVectorOut.at(FoV-1).at(i).insert(8,EncapInspectRectCols)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Encap_TeachTupleVector">
<parameters>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapRectCols"/>
<parameter id="EncapRectRows"/>
<parameter id="EncapTeachDoc"/>
<parameter id="EncapTupleVector"/>
<parameter id="EncapTupleVectorOut"/>
<parameter id="FoV"/>
<parameter id="MaxEncapContrast"/>
<parameter id="MinEncapContrast"/>
<parameter id="NoOfEncapRect4EncapLoc"/>
<parameter id="NoOfRectangle4EncapInsp"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_Extract_DeviceLocation_Data">
<interface>
<ic>
<par name="TupleVector4Eachntensity" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="TeachDoc" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>NoOfLocationTeachRegs   := TupleVector4Eachntensity.at(0)</l>
<l>DeviceWidth             := TupleVector4Eachntensity.at(1)</l>
<l>DeviceHeight            := TupleVector4Eachntensity.at(2)</l>
<l>MinDeviceContrast       := TupleVector4Eachntensity.at(3)</l>
<l>NoOfUniquePatterns      := TupleVector4Eachntensity.at(4)</l>
<l>MaxRotationAngle        := TupleVector4Eachntensity.at(5)</l>
<l>PatternSearchAreaAlongX := TupleVector4Eachntensity.at(6)</l>
<l>PatternSearchAreaAlongY := TupleVector4Eachntensity.at(7)</l>
<l>MinAcceptanceScore      := TupleVector4Eachntensity.at(8)</l>
<l>PatternTeachRows        := TupleVector4Eachntensity.at(9)</l>
<l>PatternTeachCols        := TupleVector4Eachntensity.at(10)</l>
<l>LocationTeachRows       := TupleVector4Eachntensity.at(11)</l>
<l>LocationTeachCols       := TupleVector4Eachntensity.at(12)</l>
<l>ModelID                 := TupleVector4Eachntensity.at(13)</l>
<l>PatternDegree           := TupleVector4Eachntensity.at(14)</l>
<l>MatchModelCenterRow     := TupleVector4Eachntensity.at(15)</l>
<l>MatchModelCenterColumn  := TupleVector4Eachntensity.at(16)</l>
<l>MaskSize                := TupleVector4Eachntensity.at(17)</l>
<l>TeachDoc                := TupleVector4Eachntensity.at(18)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Extract_DeviceLocation_Data">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceWidth"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelCenterColumn"/>
<parameter id="MatchModelCenterRow"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelID"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternDegree"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
<parameter id="TeachDoc"/>
<parameter id="TupleVector4Eachntensity"/>
</parameters>
</docu>
</procedure>
<procedure name="_Extract_Encap_Data">
<interface>
<ic>
<par name="EncapTupleVector4Eachntensity" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEncapContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfEncapRect4EncapLoc" base_type="ctrl" dimension="0"/>
<par name="EncapRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapRectCols" base_type="ctrl" dimension="0"/>
<par name="NoOfRectangle4EncapInsp" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>MinEncapContrast         := EncapTupleVector4Eachntensity.at(1)</l>
<l>MaxEncapContrast         := EncapTupleVector4Eachntensity.at(2)</l>
<c></c>
<l>NoOfEncapRect4EncapLoc   := EncapTupleVector4Eachntensity.at(3)</l>
<l>EncapRectRows            := EncapTupleVector4Eachntensity.at(4)</l>
<l>EncapRectCols            := EncapTupleVector4Eachntensity.at(5)</l>
<c></c>
<l>NoOfRectangle4EncapInsp  := EncapTupleVector4Eachntensity.at(6)</l>
<l>EncapInspectRectRows     := EncapTupleVector4Eachntensity.at(7)</l>
<l>EncapInspectRectCols     := EncapTupleVector4Eachntensity.at(8)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Extract_Encap_Data">
<parameters>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapRectCols"/>
<parameter id="EncapRectRows"/>
<parameter id="EncapTupleVector4Eachntensity"/>
<parameter id="MaxEncapContrast"/>
<parameter id="MinEncapContrast"/>
<parameter id="NoOfEncapRect4EncapLoc"/>
<parameter id="NoOfRectangle4EncapInsp"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_AppendOverlayRegion">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="OverlayRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="OverlayImage" base_type="iconic" dimension="0"/>
<par name="OverlayRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Color" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ColorOutput" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (OverlayRegionOut)</l>
<l>gen_empty_obj(OverlayImage)</l>
<c>*****Overlay Region Color</c>
<l>ColorOutput := []</l>
<c></c>
<l>concat_obj(OverlayImage, Image, OverlayImage)</l>
<l>union1 (OverlayRegion, OverlayRegion)</l>
<l>concat_obj (OverlayRegionOut, OverlayRegion, OverlayRegionOut)</l>
<c></c>
<l>count_obj (OverlayRegionOut, Count)</l>
<l>tuple_gen_const (Count, Color, Colors)</l>
<l>tuple_concat (ColorOutput, Colors, ColorOutput)</l>
<l>return()</l>
</body>
<docu id="_FCI_AppendOverlayRegion">
<parameters>
<parameter id="Color"/>
<parameter id="ColorOutput"/>
<parameter id="Image"/>
<parameter id="OverlayImage"/>
<parameter id="OverlayRegion"/>
<parameter id="OverlayRegionOut"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_ConnectedRgn_RegionProjection">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="CVLInspectRgn" base_type="iconic" dimension="0"/>
<par name="ProjectedCVLRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="NoOfRegions" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnRows" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnCols" base_type="ctrl" dimension="0"/>
<par name="CVLRefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointCol" base_type="ctrl" dimension="0"/>
<par name="FindRotationAngle" base_type="ctrl" dimension="0"/>
<par name="FindPointRow" base_type="ctrl" dimension="0"/>
<par name="FindPointCol" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>ShiftAlongRow := CVLRefPointRow - FindPointRow</l>
<l>ShiftAlongCol := CVLRefPointCol - FindPointCol</l>
<l>RotationAngleDev := CVLRefRotationAngle - FindRotationAngle</l>
<c></c>
<l>if(|ShiftAlongRow| = 0)</l>
<l>    ShiftAlongRow := 0.0</l>
<l>    ShiftAlongCol := 0.0</l>
<l>    RotationAngleDev := 0.0</l>
<l>endif</l>
<l>get_image_size (InspectImage, ImageWidth, ImageHeight)</l>
<l>gen_empty_obj (CVLInspectRgn)</l>
<l>for CVLRectIndex := 0 to NoOfRegions-1 by 1</l>
<l>    RectRows := CVLRectRgnRows [2*CVLRectIndex : 2*(CVLRectIndex+1)-1]</l>
<l>    RectCols := CVLRectRgnCols [2*CVLRectIndex : 2*(CVLRectIndex+1)-1]</l>
<l>    gen_rectangle1 (CVLCheckRgn, RectRows[0], RectCols[0], RectRows[1], RectCols[1])</l>
<l>    concat_obj (CVLInspectRgn, CVLCheckRgn, CVLInspectRgn)</l>
<l>endfor</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngleDev, ImageWidth/2, ImageHeight/2, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (CVLInspectRgn, ProjectedCVLRegion, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Projected CoverLayer Region']</l>
<l>    _FCI_DebugParameters (InspectImage, ProjectedCVLRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_ConnectedRgn_RegionProjection">
<parameters>
<parameter id="CVLInspectRgn"/>
<parameter id="CVLRectRgnCols"/>
<parameter id="CVLRectRgnRows"/>
<parameter id="CVLRefPointCol"/>
<parameter id="CVLRefPointRow"/>
<parameter id="CVLRefRotationAngle"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FindPointCol"/>
<parameter id="FindPointRow"/>
<parameter id="FindRotationAngle"/>
<parameter id="InspectImage"/>
<parameter id="IsStepMode"/>
<parameter id="NoOfRegions"/>
<parameter id="ProjectedCVLRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CoverLayer_Manual_Teach">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="TeachCoverLayerRgn" base_type="iconic" dimension="0"/>
<par name="OverlayImage" base_type="iconic" dimension="0"/>
<par name="OverlayRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="CVLTupleVector" base_type="ctrl" dimension="3"/>
<par name="WindowHandleOut" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLTupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<c></c>
<l>CVLTeachDoc := -1</l>
<l>NoOfRegions := 0</l>
<l>CVLRectRgnRows := []</l>
<l>CVLRectRgnCols := []</l>
<l>NoOfUniquePatterns := 0</l>
<l>MaxRotationAngle := []</l>
<l>PatternSearchAreaAlongX := []</l>
<l>PatternSearchAreaAlongY := []</l>
<l>MinAcceptanceScore := []</l>
<l>CVLDatumRows := []</l>
<l>CVLDatumCols := []</l>
<l>CVLModelID := []</l>
<l>CVLRefRotationAngle := []</l>
<l>CVLRefPointRow := []</l>
<l>CVLRefPointColumn := []</l>
<l>CVLContrast := []</l>
<l>CVLLength := []</l>
<l>MaskSize := []</l>
<l>MinCVLHeight := []</l>
<c></c>
<l>CVLTupleVectorOut := CVLTupleVector</l>
<c></c>
<c></c>
<l>dev_display (Image)</l>
<l>disp_message (WindowHandleOut, 'CoverLayer Teach [Y/N] ?', 'window', 12, 12, 'black', 'true')</l>
<l>stop()</l>
<l>IsCVLTeach := 1</l>
<c></c>
<l>dev_display (Image)</l>
<l>if(IsCVLTeach)            </l>
<l>    CVLTeachDoc := i    </l>
<c>    ***Two Flags for CVL Teach</c>
<l>    stop()</l>
<l>    IsCVLTeachWithDatum := 0</l>
<l>    IsCVLTeachWithOutDatum := 1</l>
<c>    </c>
<l>    if(IsCVLTeachWithOutDatum)</l>
<l>        NoOfRegions := 4</l>
<l>        _FCI_Gen_Rectangles (CVLTeachRgn, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, WindowHandleOut, \
                             CVLRectRgnRows, CVLRectRgnCols)</l>
<c>        </c>
<l>    elseif(IsCVLTeachWithDatum)</l>
<c>        </c>
<l>        NoOfUniquePatterns      := 2</l>
<l>        MaxRotationAngle        := 10</l>
<l>        PatternSearchAreaAlongX := 100</l>
<l>        PatternSearchAreaAlongY := 50</l>
<l>        MinAcceptanceScore      := 0.65</l>
<l>        if(NoOfUniquePatterns &lt; 2)</l>
<l>            NoOfUniquePatterns := 2</l>
<l>        endif </l>
<l>        _FCI_Gen_Rectangles (CVLRectRegion, NoOfUniquePatterns, CVLDatumRows, CVLDatumCols, WindowHandleOut, \
                             CVLDatumRows, CVLDatumCols)</l>
<c>        </c>
<l>        _FCI_TeachUniquePattern (Image, NoOfUniquePatterns, MaxRotationAngle, CVLDatumRows, CVLDatumCols, \
                                 CVLModelID)</l>
<c>        </c>
<l>        _FCI_Inspect_UniquePattern (Image, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, CVLModelID, CVLDatumRows, CVLDatumCols, IsFindDatum, MatchModelScore, CVLRefRotationAngle, CVLRefPointRow, CVLRefPointColumn, DebugMessageOut)</l>
<c>        </c>
<c>        ****Step2: ROI Teach</c>
<l>        NoOfRegions := 4</l>
<l>        _FCI_Gen_Rectangles (CVLTeachRgn, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, WindowHandleOut, \
                             CVLRectRgnRows, CVLRectRgnCols)</l>
<c>        </c>
<l>    endif</l>
<c>    </c>
<l>    gen_empty_obj (TeachCoverLayerRgn)</l>
<l>    for CVLi := 0 to NoOfRegions-1 by 1</l>
<c>        </c>
<l>        select_obj (CVLTeachRgn, ObjectSelected, CVLi+1)</l>
<l>        reduce_domain (Image, ObjectSelected, ImageReduced)</l>
<c>        </c>
<l>        CVLContrast1 := 180</l>
<l>        CVLLength1 := 500</l>
<l>        MaskSize1 := 5.5</l>
<l>        MinCVLHeight1 := 15</l>
<l>        MaskWidth := 0.5</l>
<l>        MaskHeight := 0.5</l>
<c></c>
<l>        _FCI_Inspect_CoverLayer (Image, ObjectSelected, CoverLayerRegion4EachRgn, DebugImageOut, DebugRegionOut, IsStepMode, CVLContrast1, MaskSize1, MaskWidth, MaskHeight, CVLLength1, MinCVLHeight1, FoV, nFoVs, IsCoverLayer, DebugMessageOut)</l>
<c>        </c>
<l>        if(IsCoverLayer)</l>
<l>            concat_obj (TeachCoverLayerRgn, CoverLayerRegion4EachRgn, TeachCoverLayerRgn)</l>
<l>        endif</l>
<c>        </c>
<l>        tuple_concat (CVLContrast, CVLContrast1, CVLContrast)</l>
<l>        tuple_concat (CVLLength, CVLLength1, CVLLength)</l>
<l>        tuple_concat (MaskSize, MaskSize1, MaskSize)</l>
<l>        tuple_concat (MinCVLHeight, MinCVLHeight1, MinCVLHeight)</l>
<c>        </c>
<l>    endfor</l>
<c>    </c>
<l>    if(IsCoverLayer)</l>
<l>        union1 (TeachCoverLayerRgn, RegionUnion)</l>
<l>        _FCI_AppendOverlayRegion (Image, RegionUnion, OverlayImage, OverlayRegionOut, 'green', RegionColors)        </l>
<l>    endif</l>
<c>    </c>
<l>    _FCI_SaveCVLParameter (CVLTeachDoc, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, \
                           NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLDatumRows, CVLDatumCols, CVLModelID, \
                           CVLRefRotationAngle, CVLRefPointRow, CVLRefPointColumn, CVLContrast, CVLLength, MaskSize, MinCVLHeight, TeachDocPath, FoV)</l>
<l>else    </l>
<l>    _FCI_SaveCVLParameter (CVLTeachDoc, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, \
                           NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLDatumRows, CVLDatumCols, CVLModelID, \
                           CVLRefRotationAngle, CVLRefPointRow, CVLRefPointColumn, CVLContrast, CVLLength, MaskSize, MinCVLHeight, TeachDocPath, FoV)</l>
<l>endif</l>
<c></c>
<c>*****CVL Teach Tuple Vector </c>
<l>_CVL_TeachTupleVector (CVLTupleVectorOut, CVLTeachDoc, NoOfRegions, CVLRectRgnRows, CVLRectRgnCols, NoOfUniquePatterns, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLDatumRows, CVLDatumCols, CVLModelID, CVLRefRotationAngle, CVLRefPointRow, CVLRefPointColumn, CVLContrast, CVLLength, MaskSize, MinCVLHeight, FoV, i, \
                       CVLTupleVectorOut)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_CoverLayer_Manual_Teach">
<parameters>
<parameter id="CVLTupleVector"/>
<parameter id="CVLTupleVectorOut"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="OverlayImage"/>
<parameter id="OverlayRegionOut"/>
<parameter id="TeachCoverLayerRgn"/>
<parameter id="TeachDocPath"/>
<parameter id="WindowHandleOut"/>
<parameter id="i"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Create_CVL_nccModel">
<interface>
<io>
<par name="DocImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="CVLDatumRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CVLRow1" base_type="ctrl" dimension="0"/>
<par name="CVLRow2" base_type="ctrl" dimension="0"/>
<par name="CVLColumn1" base_type="ctrl" dimension="0"/>
<par name="CVLColumn2" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>CVLDatumRows := []</l>
<l>CVLDatumCols := []</l>
<l>tuple_concat (CVLDatumRows, [CVLRow1, CVLRow2], CVLDatumRows)</l>
<l>tuple_concat (CVLDatumCols, [CVLColumn1, CVLColumn2], CVLDatumCols)</l>
<l>gen_rectangle1 (CVLDatumRegion, CVLRow1, CVLColumn1, CVLRow2, CVLColumn2)</l>
<c></c>
<l>reduce_domain (DocImage, CVLDatumRegion, CVLTemplateImage)</l>
<l>create_ncc_model(CVLTemplateImage, \
                 'auto', -rad(5), rad(MaxRotationAngle), 'auto', 'use_polarity', \
                 CVLModelID)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Create_CVL_nccModel">
<parameters>
<parameter id="CVLColumn1"/>
<parameter id="CVLColumn2"/>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRegion"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLModelID"/>
<parameter id="CVLRow1"/>
<parameter id="CVLRow2"/>
<parameter id="DocImage"/>
<parameter id="MaxRotationAngle"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CreateRegion">
<interface>
<oo>
<par name="RectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="NoOfEncapRect4EncapLoc" base_type="ctrl" dimension="0"/>
<par name="InputRectRows" base_type="ctrl" dimension="0"/>
<par name="InputRectCols" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>gen_empty_obj (RectRegion)</l>
<l>for I := 0 to NoOfEncapRect4EncapLoc-1 by 1</l>
<l>    RectRows := InputRectRows[I*2 : 2*(I+1)-1]</l>
<l>    RectCols := InputRectCols[I*2 : 2*(I+1)-1]</l>
<l>    gen_rectangle1 (Rectangle, RectRows[0], RectCols[0], RectRows[1], RectCols[1])</l>
<l>    concat_obj (RectRegion, Rectangle, RectRegion)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="_FCI_CreateRegion">
<parameters>
<parameter id="InputRectCols"/>
<parameter id="InputRectRows"/>
<parameter id="NoOfEncapRect4EncapLoc"/>
<parameter id="RectRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CVL_AutoTeach_ReadData">
<interface>
<ic>
<par name="posDTupleNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfRegions" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnRows" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnCols" base_type="ctrl" dimension="0"/>
<par name="CVLNoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="CVLMaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLPatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="CVLPatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="CVLMinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
<par name="CVLRefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointColumn" base_type="ctrl" dimension="0"/>
<par name="CVLContrast" base_type="ctrl" dimension="0"/>
<par name="CVLLength" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="MinCVLHeight" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (posDTupleNames, ['CVLTeachDoc','ignore_case'], tupleCVLTeachDoc)</l>
<l>tuple_regexp_select (posDTupleNames, ['NoOfRegions','ignore_case'], tupleNoOfRegions)           </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLRectRgnRows','ignore_case'], tupleCVLRectRgnRows)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLRectRgnCols','ignore_case'], tupleCVLRectRgnCols)         </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['CVLNoOfUniquePatterns','ignore_case'], tupleNoOfUniquePatterns)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLMaxRotationAngle','ignore_case'], tupleCVLMaxRotationAngle)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLPatternSearchAreaAlongX','ignore_case'], tupleCVLPatternSearchAreaAlongX)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLPatternSearchAreaAlongY','ignore_case'], tupleCVLPatternSearchAreaAlongY)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLMinAcceptanceScore','ignore_case'], tupleCVLMinAcceptanceScore) </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['CVLDatumRows','ignore_case'], tupleCVLDatumRows)           </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLDatumCols','ignore_case'], tupleCVLDatumCols)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLModelID','ignore_case'], tupleCVLModelID)         </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['CVLRefRotationAngle','ignore_case'], tupleCVLRefRotationAngle)           </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLRefPointRow','ignore_case'], tupleCVLRefPointRow)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLRefPointColumn','ignore_case'], tupleCVLRefPointColumn)         </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['CVLContrast','ignore_case'], tupleCVLContrast)           </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLLength','ignore_case'], tupleCVLLength)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLMaskSize','ignore_case'], tupleMaskSize)         </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLMinCVLHeight','ignore_case'], tupleMinCVLHeight)         </l>
<c></c>
<l>read_tuple(tupleCVLTeachDoc, CVLTeachDoc)</l>
<l>read_tuple(tupleNoOfRegions, NoOfRegions)</l>
<l>read_tuple(tupleCVLRectRgnRows, CVLRectRgnRows)</l>
<l>read_tuple(tupleCVLRectRgnCols, CVLRectRgnCols)          </l>
<c></c>
<l>read_tuple(tupleNoOfUniquePatterns, CVLNoOfUniquePatterns)</l>
<l>read_tuple(tupleCVLMaxRotationAngle, CVLMaxRotationAngle)</l>
<l>read_tuple(tupleCVLPatternSearchAreaAlongX, CVLPatternSearchAreaAlongX)</l>
<l>read_tuple(tupleCVLPatternSearchAreaAlongY, CVLPatternSearchAreaAlongY)          </l>
<l>read_tuple(tupleCVLMinAcceptanceScore, CVLMinAcceptanceScore)</l>
<c></c>
<l>read_tuple(tupleCVLDatumRows, CVLDatumRows)</l>
<l>read_tuple(tupleCVLDatumCols, CVLDatumCols)</l>
<l>read_tuple(tupleCVLModelID, CVLModelID)</l>
<c></c>
<l>read_tuple (tupleCVLRefRotationAngle, CVLRefRotationAngle)</l>
<l>read_tuple (tupleCVLRefPointRow, CVLRefPointRow)</l>
<l>read_tuple (tupleCVLRefPointColumn, CVLRefPointColumn)</l>
<c></c>
<l>read_tuple(tupleCVLContrast, CVLContrast)</l>
<l>read_tuple(tupleCVLLength, CVLLength)</l>
<l>read_tuple(tupleMaskSize, MaskSize)</l>
<l>read_tuple(tupleMinCVLHeight, MinCVLHeight)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_CVL_AutoTeach_ReadData">
<parameters>
<parameter id="CVLContrast"/>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLLength"/>
<parameter id="CVLMaxRotationAngle"/>
<parameter id="CVLMinAcceptanceScore"/>
<parameter id="CVLModelID"/>
<parameter id="CVLNoOfUniquePatterns"/>
<parameter id="CVLPatternSearchAreaAlongX"/>
<parameter id="CVLPatternSearchAreaAlongY"/>
<parameter id="CVLRectRgnCols"/>
<parameter id="CVLRectRgnRows"/>
<parameter id="CVLRefPointColumn"/>
<parameter id="CVLRefPointRow"/>
<parameter id="CVLRefRotationAngle"/>
<parameter id="CVLTeachDoc"/>
<parameter id="MaskSize"/>
<parameter id="MinCVLHeight"/>
<parameter id="NoOfRegions"/>
<parameter id="posDTupleNames"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CVLA_AutoTeach_ReadData">
<interface>
<ic>
<par name="posDTupleNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLAlignmentTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLARect" base_type="ctrl" dimension="0"/>
<par name="CVLAMaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLAPatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="CVLAPatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="CVLAMinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLAModelIDs" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLATeachCols" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLADatum" base_type="ctrl" dimension="0"/>
<par name="CVLADatumModelID" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachCols" base_type="ctrl" dimension="0"/>
<par name="CVLARefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointColumn" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLArectFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRowsFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachColsFL" base_type="ctrl" dimension="0"/>
<par name="MaxDistanceBtnCLFL" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (posDTupleNames, ['CVLAlignmentTeachDoc','ignore_case'], tupleCVLAlignmentTeachDoc)</l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['NoOfCVLARect','ignore_case'], tupleNoOfCVLARect)           </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLAMaxRotationAngle','ignore_case'], tupleCVLAMaxRotationAngle)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLAPatternSearchAreaAlongX','ignore_case'], tupleCVLAPatternSearchAreaAlongX)         </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLAPatternSearchAreaAlongY','ignore_case'], tupleCVLAPatternSearchAreaAlongY)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLAMinAcceptanceScore','ignore_case'], tupleCVLAMinAcceptanceScore)       </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLAModelIDs','ignore_case'], tupleCVLAModelIDs)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLATeachRows','ignore_case'], tupleCVLATeachRows)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLATeachCols','ignore_case'], tupleCVLATeachCols)    </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['NoOfCVLADatum','ignore_case'], tupleNoOfCVLADatum)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLADatumModelID','ignore_case'], tupleCVLADatumModelID)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLADatumTeachRows','ignore_case'], tupleCVLADatumTeachRows)        </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLADatumTeachCols','ignore_case'], tupleCVLADatumTeachCols)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLARefRotationAngle','ignore_case'], tupleCVLARefRotationAngle)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLARefPointRow','ignore_case'], tupleCVLARefPointRow)        </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLARefPointColumn','ignore_case'], tupleCVLARefPointColumn)</l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['NoOfCVLArectFL','ignore_case'], tupleNoOfCVLArectFL)</l>
<l>tuple_regexp_select (posDTupleNames, ['CVLATeachRowsFL','ignore_case'], tupleCVLATeachRowsFL)        </l>
<l>tuple_regexp_select (posDTupleNames, ['CVLATeachColsFL','ignore_case'], tupleCVLATeachColsFL)</l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['MaxDistanceBtnCLFL','ignore_case'], tupleMaxDistanceBtnCLFL)</l>
<c></c>
<l>read_tuple(tupleCVLAlignmentTeachDoc, CVLAlignmentTeachDoc)</l>
<c></c>
<l>read_tuple(tupleNoOfCVLARect[0], NoOfCVLARect)</l>
<l>read_tuple(tupleCVLAMaxRotationAngle, CVLAMaxRotationAngle)</l>
<l>read_tuple(tupleCVLAPatternSearchAreaAlongX, CVLAPatternSearchAreaAlongX)          </l>
<l>read_tuple(tupleCVLAPatternSearchAreaAlongY, CVLAPatternSearchAreaAlongY)</l>
<l>read_tuple(tupleCVLAMinAcceptanceScore, CVLAMinAcceptanceScore)       </l>
<l>read_tuple(tupleCVLAModelIDs, CVLAModelIDs)</l>
<l>read_tuple(tupleCVLATeachRows[0], CVLATeachRows)          </l>
<l>read_tuple(tupleCVLATeachCols[0], CVLATeachCols)</l>
<c></c>
<l>read_tuple(tupleNoOfCVLADatum, NoOfCVLADatum)</l>
<l>read_tuple(tupleCVLADatumModelID, CVLADatumModelID)          </l>
<l>read_tuple(tupleCVLADatumTeachRows, CVLADatumTeachRows)</l>
<l>read_tuple(tupleCVLADatumTeachCols, CVLADatumTeachCols)  </l>
<l>read_tuple(tupleCVLARefRotationAngle, CVLARefRotationAngle)</l>
<l>read_tuple(tupleCVLARefPointRow, CVLARefPointRow)          </l>
<l>read_tuple(tupleCVLARefPointColumn, CVLARefPointColumn)</l>
<c></c>
<l>read_tuple(tupleNoOfCVLArectFL, NoOfCVLArectFL)</l>
<l>read_tuple(tupleCVLATeachRowsFL, CVLATeachRowsFL)          </l>
<l>read_tuple(tupleCVLATeachColsFL, CVLATeachColsFL)</l>
<c>         </c>
<l>read_tuple(tupleMaxDistanceBtnCLFL, MaxDistanceBtnCLFL)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_CVLA_AutoTeach_ReadData">
<parameters>
<parameter id="CVLADatumModelID"/>
<parameter id="CVLADatumTeachCols"/>
<parameter id="CVLADatumTeachRows"/>
<parameter id="CVLAMaxRotationAngle"/>
<parameter id="CVLAMinAcceptanceScore"/>
<parameter id="CVLAModelIDs"/>
<parameter id="CVLAPatternSearchAreaAlongX"/>
<parameter id="CVLAPatternSearchAreaAlongY"/>
<parameter id="CVLARefPointColumn"/>
<parameter id="CVLARefPointRow"/>
<parameter id="CVLARefRotationAngle"/>
<parameter id="CVLATeachCols"/>
<parameter id="CVLATeachColsFL"/>
<parameter id="CVLATeachRows"/>
<parameter id="CVLATeachRowsFL"/>
<parameter id="CVLAlignmentTeachDoc"/>
<parameter id="MaxDistanceBtnCLFL"/>
<parameter id="NoOfCVLADatum"/>
<parameter id="NoOfCVLARect"/>
<parameter id="NoOfCVLArectFL"/>
<parameter id="posDTupleNames"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CVLA_ManualPointer_RgnProjection">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="InspectRgn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ProjectedRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="NoOfPointer" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (InspectRgn, ProjectedRegion, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<c></c>
<l>sort_region (ProjectedRegion, SortedRegions, 'character', 'true', 'row')</l>
<c></c>
<l>if (IsStepMode)</l>
<c></c>
<l>        Message := ['Projected Manual Pointer Teach Region']</l>
<l>        _FCI_DebugParameters (InspectImage, SortedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_CVLA_ManualPointer_RgnProjection">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="InspectImage"/>
<parameter id="InspectRgn"/>
<parameter id="IsStepMode"/>
<parameter id="NoOfPointer"/>
<parameter id="ProjectedRegion"/>
<parameter id="RotationAngle"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_CVLAlignment_Manual_Teach">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ROI4CVLAlignment" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="CVLATupleVector" base_type="ctrl" dimension="3"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CVLATupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<l>CVLATupleVectorOut := CVLATupleVector</l>
<c></c>
<l>CVLAlignmentTeachDoc := -1</l>
<c></c>
<l>NoOfCVLARect := 0</l>
<l>MaxRotationAngle := []</l>
<l>PatternSearchAreaAlongX := []</l>
<l>PatternSearchAreaAlongY := []</l>
<l>MinAcceptanceScore := []</l>
<l>CVLAModelIDs :=[]</l>
<l>CVLATeachRows := []</l>
<l>CVLATeachCols := []</l>
<c></c>
<l>NoOfCVLADatum := 0</l>
<l>CVLADatumModelID := []</l>
<l>CVLADatumTeachRows := []</l>
<l>CVLADatumTeachCols := []</l>
<c></c>
<l>CVLARefRotationAngle := []</l>
<l>CVLARefPointRow := []</l>
<l>CVLARefPointColumn := []</l>
<c></c>
<l>NoOfCVLArectFL := 0</l>
<l>CVLATeachRowsFL := []</l>
<l>CVLATeachColsFL := []</l>
<c></c>
<l>MaxDistanceBtnCLFL := []</l>
<c></c>
<l>dev_display (Image)</l>
<l>dev_get_window (WindowHandle)</l>
<l>disp_message (WindowHandle, 'CoverLayer Alignment Teach [Y/N] ?:', 'window', 20, 20, 'black', 'true')</l>
<l>stop()</l>
<l>IsCVLAlignmentTeach := 0</l>
<c></c>
<l>dev_display (Image)</l>
<l>if(IsCVLAlignmentTeach)</l>
<l>    CVLAlignmentTeachDoc := i</l>
<c>    </c>
<l>    IsCVLATeachUsingFixedPatterns := 0</l>
<l>    IsCVLATeachUsingFlexLine := 1</l>
<c>    </c>
<c>    ******Common</c>
<l>    MaxRotationAngle := 10</l>
<l>    PatternSearchAreaAlongX := 10</l>
<l>    PatternSearchAreaAlongY := 10</l>
<l>    MinAcceptanceScore := 0.65</l>
<c>    </c>
<l>    if(IsCVLATeachUsingFixedPatterns)</l>
<c>        </c>
<l>        NoOfCVLARect := 2</l>
<l>        gen_empty_obj (ROI4CVLAlignment)</l>
<c>        </c>
<l>        for RIndex := 0 to NoOfCVLARect-1 by 1</l>
<c>            </c>
<l>            CVLARows := []</l>
<l>            CVLACols := []</l>
<c>            </c>
<l>            _FCI_GenerateRectangleRegion (Image, \
                                          Row1, Column1, Row2, Column2)</l>
<c>            </c>
<l>            CVLARows := [Row1, Row2]</l>
<l>            CVLACols := [Column1, Column2]</l>
<c>            </c>
<l>            _FCI_TeachUniquePattern (Image, 1, MaxRotationAngle, CVLARows, CVLACols, \
                                     CVLAModelID)</l>
<c>            </c>
<l>            CVLAModelIDs := [CVLAModelIDs, CVLAModelID] </l>
<l>            tuple_concat (CVLATeachRows, CVLARows, CVLATeachRows)</l>
<l>            tuple_concat (CVLATeachCols, CVLACols, CVLATeachCols)</l>
<c>            </c>
<l>        endfor</l>
<c>        </c>
<l>    elseif(IsCVLATeachUsingFlexLine)</l>
<l>        stop()</l>
<l>        IsDatum := 0</l>
<l>        if(IsDatum)</l>
<c>            *******Datum Teach</c>
<l>            NoOfCVLADatum := 2</l>
<l>            _FCI_Gen_Rectangles (DatumRegions, NoOfCVLADatum, CVLADatumTeachRows, CVLADatumTeachCols, WindowHandle, \
                                 CVLADatumTeachRows, CVLADatumTeachCols)</l>
<c>            </c>
<l>            _FCI_TeachUniquePattern (Image, \
                                     NoOfCVLADatum, MaxRotationAngle, CVLADatumTeachRows, CVLADatumTeachCols, \
                                     CVLADatumModelID)</l>
<c>            </c>
<l>            _FCI_Inspect_UniquePattern (Image, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, IsFindDatum, MatchModelScore, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, DebugMessageOut)</l>
<c>            </c>
<l>        endif</l>
<l>        NoOfCVLArectFL := 3</l>
<c>        </c>
<l>        for Index := 0 to NoOfCVLArectFL-1 by 1</l>
<c>            </c>
<c>            ****** Rectangle for Flex-Line        </c>
<l>            _FCI_Gen_Rectangles (RegionForCVLAUsingFL, 1, CVLATeachRowsFL, CVLATeachColsFL, WindowHandle, \
                                 CVLATeachRowsFL, CVLATeachColsFL)</l>
<c>            </c>
<c>            ******* Vision Parameter</c>
<l>            MaxDistanceBtnCLFL1 := 80</l>
<l>            tuple_concat (MaxDistanceBtnCLFL, MaxDistanceBtnCLFL1, MaxDistanceBtnCLFL)</l>
<c>            </c>
<l>        endfor</l>
<c>        </c>
<l>    endif</l>
<c>    </c>
<l>    _FCI_SaveCVLAlignmentParameter (CVLAlignmentTeachDoc, NoOfCVLARect, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLAModelIDs, CVLATeachRows, CVLATeachCols, NoOfCVLADatum, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, NoOfCVLArectFL, CVLATeachRowsFL, CVLATeachColsFL, MaxDistanceBtnCLFL, TeachDocPath, FoV)</l>
<l>else</l>
<c>    </c>
<l>    _FCI_SaveCVLAlignmentParameter (CVLAlignmentTeachDoc, NoOfCVLARect, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLAModelIDs, CVLATeachRows, CVLATeachCols, NoOfCVLADatum, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, NoOfCVLArectFL, CVLATeachRowsFL, CVLATeachColsFL, MaxDistanceBtnCLFL, TeachDocPath, FoV)</l>
<l>endif  </l>
<c></c>
<l>_CVLA_TeachTupleVector (CVLATupleVectorOut, CVLAlignmentTeachDoc, NoOfCVLARect, MaxRotationAngle, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MinAcceptanceScore, CVLAModelIDs, CVLATeachRows, CVLATeachCols, NoOfCVLADatum, CVLADatumModelID, CVLADatumTeachRows, CVLADatumTeachCols, CVLARefRotationAngle, CVLARefPointRow, CVLARefPointColumn, NoOfCVLArectFL, CVLATeachRowsFL, CVLATeachColsFL, MaxDistanceBtnCLFL, FoV, i, CVLATupleVectorOut)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_CVLAlignment_Manual_Teach">
<parameters>
<parameter id="CVLATupleVector"/>
<parameter id="CVLATupleVectorOut"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="ROI4CVLAlignment"/>
<parameter id="TeachDocPath"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_DebugParameters">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="DebugImageIn" base_type="iconic" dimension="0"/>
<par name="DebugRegionIn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Message" base_type="ctrl" dimension="0"/>
<par name="DebugMessageIn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>count_obj(DebugImageIn, DebugImageCount)</l>
<l>count_obj(DebugRegionIn, DebugRegCount)</l>
<l>tuple_length(DebugMessageIn,DebugMsgCount)</l>
<c></c>
<l>if(DebugImageCount = DebugRegCount and DebugMsgCount = DebugRegCount)   </l>
<c>    </c>
<l>    union1 (Region, RegionUnion)</l>
<l>    area_center (RegionUnion, Area, Row, Column)</l>
<l>    if (|Area| &gt; 0 and Area &gt;= 0)</l>
<c>        </c>
<l>        gen_image_proto (Image, ImageCleared, 0)</l>
<l>        add_image (Image, ImageCleared, ImageResult, 1, 0)</l>
<c>        </c>
<l>        concat_obj (DebugImageIn, ImageResult, DebugImageOut)</l>
<l>        concat_obj (DebugRegionIn, RegionUnion, DebugRegionOut)           </l>
<l>        tuple_concat (DebugMessageIn, Message, DebugMessageOut)  </l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="_FCI_DebugParameters">
<parameters>
<parameter id="DebugImageIn"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageIn"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionIn"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="Message"/>
<parameter id="Region"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_DefaultTeach_DeviceLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="LocationTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>LocationTeachRectRows := []</l>
<l>LocationTeachRectCols := []</l>
<c></c>
<l>stop()</l>
<l>draw_rectangle1(200000, Row1, Column1, Row2, Column2)</l>
<l>tuple_concat (LocationTeachRectRows, [Row1, Row2], LocationTeachRectRows)</l>
<l>tuple_concat (LocationTeachRectCols, [ Column1,Column2], LocationTeachRectCols)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_DefaultTeach_DeviceLocation">
<parameters>
<parameter id="Image"/>
<parameter id="LocationTeachRectCols"/>
<parameter id="LocationTeachRectRows"/>
<parameter id="NoOfLocationTeachRegs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_DeviceLocation_WithOutUniquePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="IsSobelFlag" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="RefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="RefPointRow" base_type="ctrl" dimension="0"/>
<par name="RefPointColumn" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
<par name="ReferencePointType" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="RotationAngleDev" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***</c>
<l>IsPass := false</l>
<l>gen_empty_obj(DeviceLocation)</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<l>gen_rectangle1 (GrossDieLocation, LocationTeachRows[0], LocationTeachCols[0], LocationTeachRows[1], LocationTeachCols[1])</l>
<l>region_features (GrossDieLocation, 'area', DeviceArea)</l>
<l>get_image_size(Image, ImageWidth, ImageHeight)</l>
<l>smallest_rectangle2 (GrossDieLocation, Row2, Column2, Phi1, Length11, Length21)</l>
<l>gen_rectangle2(Rectangle, Row2, Column2, Phi1, ImageWidth, Length21) </l>
<c></c>
<c>**** Reduced Image</c>
<l>reduce_domain(Image, Rectangle, ImageReduced)    </l>
<l>if (IsSobelFlag)</l>
<l>    sobel_amp(ImageReduced, ImageReduced, 'sum_abs', 3)</l>
<c>    </c>
<l>    if (IsStepMode)      </l>
<l>        Message:=['Edges in the Image']</l>
<l>        _FCI_DebugParameters (ImageReduced, Rectangle, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,\
                              Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif     </l>
<l>endif  </l>
<c></c>
<l>if(MinDeviceContrast=0)</l>
<l>    min_max_gray (Rectangle, ImageReduced, 0, Min, Max, Range)</l>
<l>    threshold (ImageReduced, SegmentRegion, (Max-Min)/2, Max)</l>
<l>else</l>
<l>    threshold (ImageReduced, SegmentRegion, MinDeviceContrast, 255)</l>
<l>endif </l>
<c></c>
<l>if (IsStepMode)   </l>
<l>    Message:=['Initial Segmentation of the Image']</l>
<l>    _FCI_DebugParameters (ImageReduced, SegmentRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  \
                          Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>fill_up (SegmentRegion, RegionFillUp)</l>
<l>connection (RegionFillUp, ConnectedRegions)    </l>
<l>gen_empty_obj (DeviceEmptyObject)</l>
<c></c>
<l>if(Track = 1 or Track = 2)</l>
<c>    </c>
<c>    ********Select_Small_Regions</c>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['width','height'], 'and', [0,0], [DeviceWidth/10, DeviceHeight/10])</l>
<l>    union1 (SelectedRegions, SmallAreaRegions)</l>
<l>    difference (SegmentRegion, SmallAreaRegions, RegionDifference)</l>
<l>    closing_circle (RegionDifference, RegionClosing1, 3.5)</l>
<l>    fill_up (RegionClosing1, RegionFillUp)</l>
<c>      </c>
<c>    ******* Select Edge Location</c>
<l>    connection (RegionFillUp, ConnectedRegions1)</l>
<l>    MinSelectHeight := DeviceHeight/5</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions, ['width','height'], 'and', \
                  [DeviceWidth,MinSelectHeight], [ImageWidth, ImageHeight])</l>
<l>    count_obj (SelectedRegions, Number)</l>
<c>    </c>
<l>    if(Number &gt; 0)</l>
<l>        area_center (SelectedRegions, TestArea, Dummy, Dummy)</l>
<l>        tuple_max (TestArea, MaxTestArea)</l>
<l>        AreaFraction := MaxTestArea / (DeviceArea*1.0)</l>
<c>        </c>
<l>        if(AreaFraction &gt; 0.7)</l>
<l>            select_shape_std (SelectedRegions, SelectedRegions3, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions3, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<l>        else</l>
<c>            </c>
<l>            union1 (SelectedRegions, RegionUnion)</l>
<l>            closing_rectangle1 (RegionUnion, RegionClosing2, MaskSize, MaskSize)</l>
<l>            connection (RegionClosing2, ConnectedRegions2)</l>
<l>            select_shape (ConnectedRegions2, SelectedRegions2, ['width', 'height'], 'and', [DeviceWidth, DeviceHeight], [ImageWidth, ImageHeight])</l>
<l>            select_shape_std(SelectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions1, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<c>            </c>
<l>        endif </l>
<l>    endif</l>
<l>else</l>
<c>    </c>
<l>    intensity (ConnectedRegions, ImageReduced, Mean, Deviation)</l>
<l>    MaxGrayMean := max(Mean)</l>
<l>    select_gray (ConnectedRegions, ImageReduced, DeviceEmptyObject, 'mean', 'and', 0.95*MaxGrayMean, MaxGrayMean)</l>
<l>    count_obj (DeviceEmptyObject, Number2)</l>
<l>    if(Number2&gt;1)</l>
<l>        select_shape_std (DeviceEmptyObject, DeviceEmptyObject, 'max_area', 70)</l>
<l>    endif </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>area_center(DeviceEmptyObject, Area, Dummy, Dummy)</l>
<l>if(Area&gt;0 and |Area|&gt;0)</l>
<l>    elliptic_axis (DeviceEmptyObject, Dummy, Dummy, Phi)</l>
<l>    RotationAngle := Phi</l>
<l>    concat_obj (DeviceLocation, DeviceEmptyObject, DeviceLocation)</l>
<l>    IsPass := true</l>
<l>    TopReferencePoints (Image, DeviceLocation, FoV, nFoVs, ReferencePointType, DeviceTopPointRow, DeviceTopPointCol, DeviceAngle, Device2DCenter, DeviceSize)</l>
<l>endif</l>
<c></c>
<l>RotationAngleDev := RefRotationAngle - RotationAngle</l>
<l>ShiftAlongRow := RefPointRow - DeviceTopPointRow</l>
<l>ShiftAlongCol := RefPointColumn - DeviceTopPointCol</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmented Exact Device Location']</l>
<l>    _FCI_DebugParameters (Image, DeviceLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                          Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<c>     ** Show the top reference point found be extract the device location</c>
<l>     if(Area&gt;0 and |Area|&gt;0)</l>
<l>         Message:=[' Top Reference Point Found By Inspect Edge Device Location']</l>
<l>         gen_cross_contour_xld (TopRefCross, DeviceTopPointRow, DeviceTopPointCol, 100, 0)</l>
<l>         get_contour_xld (TopRefCross, TopRefCrossRow, TopRefCrossCol)</l>
<l>         gen_region_polygon (TopRefCrossRegion, TopRefCrossRow, TopRefCrossCol)</l>
<c>        </c>
<l>         _FCI_DebugParameters (Image, TopRefCrossRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,\
                          Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_DeviceLocation_WithOutUniquePattern">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceHeight"/>
<parameter id="DeviceLocation"/>
<parameter id="DeviceWidth"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsSobelFlag"/>
<parameter id="IsStepMode"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MinDeviceContrast"/>
<parameter id="RefPointColumn"/>
<parameter id="RefPointRow"/>
<parameter id="RefRotationAngle"/>
<parameter id="ReferencePointType"/>
<parameter id="RotationAngleDev"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
<parameter id="Track"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_DeviceLocation_WithUniquePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
<par name="RoughDeviceLocation" base_type="iconic" dimension="0"/>
<par name="FindModel" base_type="iconic" dimension="0"/>
<par name="DebugImageDE" base_type="iconic" dimension="0"/>
<par name="DebugRegionDE" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="IsDeviceLocationTeach" base_type="ctrl" dimension="0"/>
<par name="IsSobelFlag" base_type="ctrl" dimension="0"/>
<par name="MinSearchWidth" base_type="ctrl" dimension="0"/>
<par name="MinSearchHeight" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="RefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="RefMatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="RefMatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="IsFindDatum" base_type="ctrl" dimension="0"/>
<par name="RotationAngleDev" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="MatchScore" base_type="ctrl" dimension="0"/>
<par name="DebugMessageDE" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>******</c>
<l>IsPass := false</l>
<l>IsFindDatum := false</l>
<l>gen_empty_obj(MatchModelRegion)</l>
<l>gen_empty_obj(FindModel)</l>
<l>gen_empty_obj (RoughDeviceLocation)</l>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageDE)</l>
<l>gen_empty_obj (DebugRegionDE)</l>
<l>DebugMessageDE :=  []</l>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageDEOut)</l>
<l>gen_empty_obj (DebugRegionDEOut)</l>
<l>DebugMessageDEOut :=  []</l>
<c></c>
<l>dev_display(Image)</l>
<c>***Generate Gross Die Location</c>
<l>if(|LocationTeachRows| # 0)</l>
<l>    gen_rectangle1 (GrossDieLocation, LocationTeachRows[0], LocationTeachCols[0], LocationTeachRows[1], LocationTeachCols[1])</l>
<l>    area_center(GrossDieLocation, Dummy, GrossDieCenterRow, GrossDieCenterColumn)</l>
<l>    region_features (GrossDieLocation, 'width', GrossDieWidth)</l>
<l>    region_features (GrossDieLocation, 'height', GrossDieHeight)</l>
<l>endif</l>
<c></c>
<c>****Generate ROI</c>
<l>gen_empty_obj(ROI)</l>
<l>NoOfModel := |PatternTeachRows|/2</l>
<l>for Index := 0 to NoOfModel-1 by 1</l>
<l>    tuple_select_range (PatternTeachRows, 2*Index, 2*(Index+1)-1, PatternRowsCoord)</l>
<l>    tuple_select_range (PatternTeachCols, 2*Index, 2*(Index+1)-1, PatternColsCoord)</l>
<l>    gen_rectangle1(Rectangle, PatternRowsCoord[0], PatternColsCoord[0], PatternRowsCoord[1], PatternColsCoord[1])</l>
<l>    concat_obj(ROI, Rectangle, ROI)</l>
<l>endfor</l>
<l>union1 (ROI, ModelRegion)</l>
<l>area_center(ModelRegion, Dummy, CenterRow, CenterColumn)</l>
<c></c>
<l>gen_empty_obj (EmptyObject)</l>
<l>connection (ModelRegion, ConnectedRegions)</l>
<l>count_obj (ConnectedRegions, Number)</l>
<l>for SIndex := 1 to Number by 1</l>
<l>    select_obj (ConnectedRegions, ObjectSelected, SIndex)</l>
<c>    ** Method A</c>
<l>*     area_center(ObjectSelected, D, PatternCntRow, PatternCtrColumn)</l>
<l>*     gen_rectangle1 (Rectangle, PatternCntRow - MinSearchHeight, PatternCtrColumn - MinSearchWidth, \
                    PatternCntRow + MinSearchHeight, PatternCtrColumn + MinSearchWidth)</l>
<c>    ** Method B</c>
<l>    smallest_rectangle1 (ObjectSelected, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1 (Rectangle, Row1 - MinSearchHeight/2.0, Column1 - MinSearchWidth/2.0, \
                    Row2 + MinSearchHeight/2.0, Column2 + MinSearchWidth/2.0)</l>
<c>    </c>
<l>    concat_obj (EmptyObject, Rectangle, EmptyObject)</l>
<l>endfor</l>
<l>union1 (EmptyObject, SearchRegion)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Search Region For Datum Location']</l>
<l>    _FCI_DebugParameters (Image, SearchRegion, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE, Message, \
                          DebugMessageDE, DebugMessageDE)</l>
<l>endif </l>
<c></c>
<l>_Find_Model (Image, SearchRegion, ModelRegion, \
             MatchModel, \
             CenterRow, CenterColumn, ModelID, MinAcceptanceScore, MaxRotationAngle, \
             IsFindDatum, DatumMatchCR, DatumMatchCC, MatchAngle, MatchScore)</l>
<c></c>
<l>if(IsFindDatum = false)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Datum Location not Found : Update Search Parameter Values']</l>
<l>        gen_empty_region (EmptyRegion)</l>
<l>        _FCI_DebugParameters (Image, EmptyRegion, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE, Message, \
                              DebugMessageDE, DebugMessageDE)</l>
<c>    </c>
<l>    endif </l>
<l>    return()</l>
<c></c>
<l>else</l>
<l>    IsPass := true</l>
<l>    concat_obj (FindModel, MatchModel, FindModel)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Found the Datum Location']</l>
<l>        _FCI_DebugParameters (Image, FindModel, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE, Message, \
                              DebugMessageDE, DebugMessageDE)</l>
<l>    endif </l>
<c>    </c>
<l>endif</l>
<c></c>
<c>   </c>
<c>***Find Angle Of Deviation</c>
<l>RotationAngleDev := RefRotationAngle - MatchAngle</l>
<l>ShiftAlongRow := RefMatchModelCenterRow - DatumMatchCR</l>
<l>ShiftAlongCol := RefMatchModelCenterColumn - DatumMatchCC</l>
<c></c>
<c>****Rotation Of Gross Location</c>
<l>if(|LocationTeachRows| # 0)</l>
<c>    </c>
<l>    hom_mat2d_identity(HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -RotationAngleDev, GrossDieCenterRow, GrossDieCenterColumn, HomMat2DRotate)</l>
<l>    hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate1)</l>
<l>    affine_trans_region (GrossDieLocation, DieLocationAffineTrans, HomMat2DTranslate1, 'nearest_neighbor')</l>
<l>    if(not IsDeviceLocationTeach)</l>
<l>        DeviceLocation := DieLocationAffineTrans</l>
<l>*         if (IsStepMode)</l>
<l>*             Message:=['Exact Edge Location of the Image']</l>
<l>*             _FCI_DebugParameters (Image, DeviceLocation, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE,  Message, DebugMessageDE, DebugMessageDE)   </l>
<l>*         endif </l>
<l>        IsPass := true</l>
<l>    else</l>
<c>        ****Gross Die Location</c>
<l>        concat_obj (RoughDeviceLocation, DieLocationAffineTrans, RoughDeviceLocation)</l>
<c>        </c>
<c>        ***</c>
<l>        if (IsStepMode)</l>
<l>            Message:=['Projected Gross/Rough Device Location']</l>
<l>            _FCI_DebugParameters (Image, RoughDeviceLocation, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE, \
                                  Message, DebugMessageDE, DebugMessageDE)</l>
<l>        endif     </l>
<c>        ******</c>
<l>        area_center (RoughDeviceLocation, RoughDieLocationArea, Dummy, Dummy)</l>
<l>        if(RoughDieLocationArea &gt;0 and |RoughDieLocationArea| &gt; 0 )</l>
<c>            </c>
<l>            IsPass := true</l>
<l>            _FCI_Exact_DeviceLocation (Image, RoughDeviceLocation, SobelEdgeImage, DeviceLocation, DebugImageDEOut, \
                                       DebugRegionDEOut, IsStepMode, IsSobelFlag, MinDeviceContrast, DeviceWidth, DeviceHeight, \
                                       MaskSize, Track, DebugMessageDEOut)</l>
<c>         </c>
<l>        endif  </l>
<l>    endif</l>
<c>     </c>
<l>else</l>
<l>    gen_empty_region (DeviceLocation)</l>
<l>endif</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    concat_obj (DebugImageDE, DebugImageDEOut, DebugImageDE)</l>
<l>    concat_obj (DebugRegionDE, DebugRegionDEOut, DebugRegionDE)</l>
<l>    tuple_concat (DebugMessageDE, DebugMessageDEOut, DebugMessageDE)</l>
<c></c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_DeviceLocation_WithUniquePattern">
<parameters>
<parameter id="DebugImageDE"/>
<parameter id="DebugMessageDE"/>
<parameter id="DebugRegionDE"/>
<parameter id="DeviceHeight"/>
<parameter id="DeviceLocation"/>
<parameter id="DeviceWidth"/>
<parameter id="FindModel"/>
<parameter id="Image"/>
<parameter id="IsDeviceLocationTeach"/>
<parameter id="IsFindDatum"/>
<parameter id="IsPass"/>
<parameter id="IsSobelFlag"/>
<parameter id="IsStepMode"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchScore"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="MinSearchHeight"/>
<parameter id="MinSearchWidth"/>
<parameter id="ModelID"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
<parameter id="RefMatchModelCenterColumn"/>
<parameter id="RefMatchModelCenterRow"/>
<parameter id="RefRotationAngle"/>
<parameter id="RotationAngleDev"/>
<parameter id="RoughDeviceLocation"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
<parameter id="Track"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Dot_Calibration">
<interface>
<io>
<par name="DotImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DotRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsDotCalibTop" base_type="ctrl" dimension="0"/>
<par name="IsDotCalibBottom" base_type="ctrl" dimension="0"/>
<par name="IsDotCalibSide" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ResolutionAlongXInMicronPerPixel" base_type="ctrl" dimension="0"/>
<par name="ResolutionAlongYInMicronPerPixel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>************ Dot Calibration *************************</c>
<c></c>
<l>if(IsDotCalibTop)</l>
<c>    </c>
<c>    *****Halcon file for drawing rectangle</c>
<l>    dev_display (DotImage)</l>
<l>    _FCI_GenerateRectangleRegion(DotImage,\
                                 InputRegionRow1, InputRegionColumn1,InputRegionRow2, InputRegionColumn2)</l>
<c>    *****Input Vision Parameter</c>
<c>    **input Distance along x-dir in (Microns)</c>
<l>    PixelDistanceAlongXInMicron := 500  </l>
<c>    </c>
<c>    ****iput Size along y-dir in (Microns)</c>
<l>    PixelDistanceAlongYInMicron := 500</l>
<c>    </c>
<l>    _FCI_DotCalibration (DotImage, DotRegions, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2, PixelDistanceAlongXInMicron, PixelDistanceAlongYInMicron, MinRadiusDotTargetPixel, DotWidths, DotHeights, DotRows, DotColumns, ResolutionAlongXInMicronPerPixel, ResolutionAlongYInMicronPerPixel)</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>if(IsDotCalibBottom)</l>
<c>    </c>
<c>    *****Halcon file for drawing rectangle</c>
<l>    dev_display (DotImage)</l>
<l>    _FCI_GenerateRectangleRegion(DotImage,\
                                 InputRegionRow1, InputRegionColumn1,InputRegionRow2, InputRegionColumn2)</l>
<c>    *****Input Vision Parameter</c>
<c>    **input Distance along x-dir in (Microns)</c>
<l>    PixelDistanceAlongXInMicron := 500  </l>
<c>    </c>
<c>    ****iput Size along y-dir in (Microns)</c>
<l>    PixelDistanceAlongYInMicron := 500</l>
<c>    </c>
<l>    _FCI_DotCalibration (DotImage, DotRegions, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2, PixelDistanceAlongXInMicron, PixelDistanceAlongYInMicron, MinRadiusDotTargetPixel1, DotWidths, DotHeights, DotRows, DotColumns, ResolutionAlongXInMicronPerPixel, ResolutionAlongYInMicronPerPixel)</l>
<c>    </c>
<c>    </c>
<l>endif</l>
<c></c>
<l>if(IsDotCalibSide)</l>
<c>    </c>
<c>    *****Halcon file for drawing rectangle</c>
<l>    dev_display (DotImage)</l>
<l>    _FCI_GenerateRectangleRegion(DotImage,\
                                 InputRegionRow1, InputRegionColumn1,InputRegionRow2, InputRegionColumn2)</l>
<c>    *****Input Vision Parameter</c>
<c>    **input Distance along x-dir in (Microns)</c>
<l>    PixelDistanceAlongXInMicron := 500  </l>
<c>    </c>
<c>    ****input Size along y-dir in (Microns)</c>
<l>    PixelDistanceAlongYInMicron := 500</l>
<c>    </c>
<l>    _FCI_DotCalibration (DotImage, DotRegions, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2, PixelDistanceAlongXInMicron, PixelDistanceAlongYInMicron, MinRadiusDotTargetPixel2, DotWidths, DotHeights, DotRows, DotColumns, ResolutionAlongXInMicronPerPixel, ResolutionAlongYInMicronPerPixel)</l>
<c>    </c>
<l>endif</l>
<c></c>
<c>******Dot Calibration Finish ********</c>
<l>return ()</l>
</body>
<docu id="_FCI_Dot_Calibration">
<parameters>
<parameter id="DotImage"/>
<parameter id="DotRegions"/>
<parameter id="IsDotCalibBottom"/>
<parameter id="IsDotCalibSide"/>
<parameter id="IsDotCalibTop"/>
<parameter id="ResolutionAlongXInMicronPerPixel"/>
<parameter id="ResolutionAlongYInMicronPerPixel"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_DotCalibration">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DotRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="InputRegionRow1" base_type="ctrl" dimension="0"/>
<par name="InputRegionColumn1" base_type="ctrl" dimension="0"/>
<par name="InputRegionRow2" base_type="ctrl" dimension="0"/>
<par name="InputRegionColumn2" base_type="ctrl" dimension="0"/>
<par name="PixelDistanceAlongXInMicron" base_type="ctrl" dimension="0"/>
<par name="PixelDistanceAlongYInMicron" base_type="ctrl" dimension="0"/>
<par name="MinRadiusDotTargetPixel" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DotWidths" base_type="ctrl" dimension="0"/>
<par name="DotHeights" base_type="ctrl" dimension="0"/>
<par name="DotRowsAlongX" base_type="ctrl" dimension="0"/>
<par name="DotColumnsAlongY" base_type="ctrl" dimension="0"/>
<par name="ResolutionAlongXInMicronPerPixel" base_type="ctrl" dimension="0"/>
<par name="ResolutionAlongYInMicronPerPixel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>MinCircularity := 0.5</l>
<l>gen_rectangle1(Region, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2)</l>
<l>reduce_domain(Image, Region, ImageReduced)</l>
<l>binary_threshold(ImageReduced, Region1, 'max_separability', 'dark', UsedThreshold)</l>
<l>fill_up(Region1, RegionFillUp)</l>
<l>opening_circle(RegionFillUp, RegionOpening, 0.5*MinRadiusDotTargetPixel)</l>
<l>connection(RegionOpening, ConnectedRegions)</l>
<l>area_center(ConnectedRegions, Area, Dummy, Dummy)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, ['circularity','area'], 'and', [MinCircularity, 0.5*max(Area)] , [1, 2.5*max(Area)])</l>
<l>sort_region(SelectedRegions, DotRegions, 'character', 'true', 'row')</l>
<l>region_features(DotRegions, 'width', DotWidths)</l>
<l>region_features(DotRegions, 'height', DotHeights)</l>
<l>area_center(DotRegions, Dummy, DotRowsHM, DotColumnsHM)</l>
<c></c>
<l>count_obj(DotRegions, Number)</l>
<l>OffsetDistance := 25</l>
<l>PixelDistanceAlongX := []</l>
<l>for i := 1 to Number-1 by 1</l>
<c>    </c>
<l>    DistanceAlongX := abs(DotColumnsHM[i-1] - DotColumnsHM[i])</l>
<l>    DistanceAlongY := abs(DotRowsHM[i-1] - DotRowsHM[i])</l>
<l>    if(DistanceAlongY &gt; OffsetDistance)</l>
<l>        continue</l>
<l>    endif</l>
<l>    tuple_concat(PixelDistanceAlongX, DistanceAlongX, PixelDistanceAlongX)</l>
<c></c>
<l>endfor</l>
<l>tuple_mean(PixelDistanceAlongX, AveragePixelDistanceAlongX)</l>
<l>ResolutionAlongXInMicronPerPixel := PixelDistanceAlongXInMicron/AveragePixelDistanceAlongX</l>
<c></c>
<c></c>
<l>sort_region(SelectedRegions, SortedRegions, 'character', 'true', 'column')</l>
<l>area_center(SortedRegions, Dummy, DotRowsVM, DotColumnsVM)</l>
<l>count_obj(SortedRegions, Number1)</l>
<l>OffsetDistance := 25</l>
<l>PixelDistanceAlongY := []</l>
<l>for i := 1 to Number1-1 by 1</l>
<c>    </c>
<l>    DistanceAlongY := abs(DotRowsVM[i-1]-DotRowsVM[i])</l>
<l>    DistanceAlongX := abs(DotColumnsVM[i-1]-DotColumnsVM[i])</l>
<c>    </c>
<l>    if(DistanceAlongX &gt; OffsetDistance)</l>
<l>        continue</l>
<l>    endif</l>
<l>    tuple_concat(PixelDistanceAlongY, DistanceAlongY, PixelDistanceAlongY)</l>
<l>endfor</l>
<l>tuple_mean(PixelDistanceAlongY, AveragePixelDistanceAlongY)</l>
<l>ResolutionAlongYInMicronPerPixel := PixelDistanceAlongYInMicron/AveragePixelDistanceAlongY</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_DotCalibration">
<parameters>
<parameter id="DotColumnsAlongY"/>
<parameter id="DotHeights"/>
<parameter id="DotRegions"/>
<parameter id="DotRowsAlongX"/>
<parameter id="DotWidths"/>
<parameter id="Image"/>
<parameter id="InputRegionColumn1"/>
<parameter id="InputRegionColumn2"/>
<parameter id="InputRegionRow1"/>
<parameter id="InputRegionRow2"/>
<parameter id="MinRadiusDotTargetPixel"/>
<parameter id="PixelDistanceAlongXInMicron"/>
<parameter id="PixelDistanceAlongYInMicron"/>
<parameter id="ResolutionAlongXInMicronPerPixel"/>
<parameter id="ResolutionAlongYInMicronPerPixel"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Draw_UniquePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PatternTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>PatternTeachRectRows := []</l>
<l>PatternTeachRectCols := []</l>
<c></c>
<l>for rect:=1 to NoOfUniquePatterns by 1</l>
<l>    stop()</l>
<l>    draw_rectangle1(200000, Row1, Column1, Row2, Column2)</l>
<c></c>
<l>    gen_rectangle1(Rectangle, Row1, Column1, Row2, Column2)</l>
<l>    tuple_concat (PatternTeachRectRows, [Row1, Row2], PatternTeachRectRows)</l>
<l>    tuple_concat (PatternTeachRectCols, [Column1, Column2], PatternTeachRectCols)</l>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Draw_UniquePattern">
<parameters>
<parameter id="Image"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternTeachRectCols"/>
<parameter id="PatternTeachRectRows"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Encap_AutoTeach_ReadData">
<interface>
<ic>
<par name="posDTupleNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EncapTeachDoc" base_type="ctrl" dimension="0"/>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEncapContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfEncapRect4EncapLoc" base_type="ctrl" dimension="0"/>
<par name="EncapRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapRectCols" base_type="ctrl" dimension="0"/>
<par name="NoOfRectangle4EncapInsp" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (posDTupleNames, ['EncapTeachDoc','ignore_case'], tupleEncapTeachDoc)           </l>
<l>tuple_regexp_select (posDTupleNames, ['MinEncapContrast','ignore_case'], tupleMinEncapContrast)                                             </l>
<l>tuple_regexp_select (posDTupleNames, ['MaxEncapContrast','ignore_case'], tupleMaxEncapContrast)           </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['NoOfEncapRect4EncapLoc','ignore_case'], tupleNoOfEncapRect4EncapLoc)                                             </l>
<l>tuple_regexp_select (posDTupleNames, ['EncapRectRows','ignore_case'], tupleEncapRectRows)                                             </l>
<l>tuple_regexp_select (posDTupleNames, ['EncapRectCols','ignore_case'], tupleEncapRectCols)           </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['NoOfRectangle4EncapInsp','ignore_case'], tupleNoOfRectangle4EncapInsp)                                             </l>
<l>tuple_regexp_select (posDTupleNames, ['EncapInspectRectRows','ignore_case'], tupleEncapInspectRectRows)</l>
<l>tuple_regexp_select (posDTupleNames, ['EncapInspectRectCols','ignore_case'], tupleEncapInspectRectCols)</l>
<c></c>
<c></c>
<l>read_tuple(tupleEncapTeachDoc, EncapTeachDoc)</l>
<l>read_tuple(tupleMinEncapContrast, MinEncapContrast)</l>
<l>read_tuple(tupleMaxEncapContrast, MaxEncapContrast)</l>
<c></c>
<l>read_tuple(tupleNoOfEncapRect4EncapLoc, NoOfEncapRect4EncapLoc)</l>
<l>read_tuple(tupleEncapRectRows, EncapRectRows)</l>
<l>read_tuple(tupleEncapRectCols, EncapRectCols)</l>
<c></c>
<l>read_tuple(tupleNoOfRectangle4EncapInsp, NoOfRectangle4EncapInsp)</l>
<l>read_tuple(tupleEncapInspectRectRows, EncapInspectRectRows)</l>
<l>read_tuple(tupleEncapInspectRectCols, EncapInspectRectCols)</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="_FCI_Encap_AutoTeach_ReadData">
<parameters>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapRectCols"/>
<parameter id="EncapRectRows"/>
<parameter id="EncapTeachDoc"/>
<parameter id="MaxEncapContrast"/>
<parameter id="MinEncapContrast"/>
<parameter id="NoOfEncapRect4EncapLoc"/>
<parameter id="NoOfRectangle4EncapInsp"/>
<parameter id="posDTupleNames"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Encap_Border_LayOn_Recheck">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
<par name="EncapDefectRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ActualEncapDefect" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="ErosionOffset" base_type="ctrl" dimension="0"/>
<par name="MaxLayOnPartPercentageAllow" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<l>ActualEncapDefect := EncapDefectRegion</l>
<l>OffsetChecking := 3.5</l>
<l>IsPass := true</l>
<c></c>
<c>**</c>
<l>if(MaxLayOnPartPercentageAllow == 100)</l>
<l>    count_obj (ActualEncapDefect, ActualEncapDefectCount)</l>
<l>    if(ActualEncapDefectCount &gt; 0)</l>
<l>        IsPass := false</l>
<l>    endif</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>EncapLocationInspected := EncapLocation</l>
<l>if (ErosionOffset &gt; 0)</l>
<l>    erosion_circle (EncapLocationInspected, EncapLocationInspected, ErosionOffset)   </l>
<l>endif</l>
<c></c>
<l>erosion_circle (EncapLocationInspected, RegionErosion, OffsetChecking)</l>
<l>difference (EncapLocationInspected, RegionErosion, EncapBorderChecking)</l>
<l>connection (EncapDefectRegion, ConnectedEncapDefectRegion)</l>
<c></c>
<c>** Checking how much the defect is lay on the encap border</c>
<l>region_features (ConnectedEncapDefectRegion, 'contlength', EncapDefectRegionContLength)</l>
<l>intersection (ConnectedEncapDefectRegion, EncapBorderChecking, RegionIntersection)</l>
<l>region_features (RegionIntersection, 'contlength', DefectLayOnContLength)</l>
<c></c>
<l>if(|EncapDefectRegionContLength| &gt; 0 and |DefectLayOnContLength| &gt; 0 and |EncapDefectRegionContLength| = |DefectLayOnContLength|)</l>
<c>    </c>
<l>    ElementZero := find(EncapDefectRegionContLength, 0)</l>
<l>    if(ElementZero[0] == -1)</l>
<l>        LayOnPercentage := 100.0 * DefectLayOnContLength / EncapDefectRegionContLength</l>
<c>        </c>
<l>        IsAllowed := LayOnPercentage [&lt;=] MaxLayOnPartPercentageAllow</l>
<l>        Indices := find(IsAllowed, 1)</l>
<l>        if(Indices[0] &gt;= 0)</l>
<l>            select_obj (EncapDefectRegion, ActualEncapDefect, Indices + 1)</l>
<l>        else</l>
<l>            gen_empty_obj(ActualEncapDefect)</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>count_obj (ActualEncapDefect, ActualEncapDefectCount)</l>
<l>if(ActualEncapDefectCount &gt; 0)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>if(IsStepMode)</l>
<l>    Message := ['Intersection Of The Defect And Encap Border']</l>
<l>    _FCI_DebugParameters (InspectImage, RegionIntersection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>     Message := ['Final Encap Defect After Checking The Lay On Percentage']</l>
<l>    _FCI_DebugParameters (InspectImage, ActualEncapDefect, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Encap_Border_LayOn_Recheck">
<parameters>
<parameter id="ActualEncapDefect"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapDefectRegion"/>
<parameter id="EncapLocation"/>
<parameter id="ErosionOffset"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxLayOnPartPercentageAllow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Encap_Extraction">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="EncapInspectedImage" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="ErosionOffset" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>EncapLocationOut := EncapLocation</l>
<l>if(ErosionOffset &gt; 0)</l>
<l>    erosion_circle (EncapLocationOut, EncapLocationOut, ErosionOffset)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Encap Region after Erosion']</l>
<l>        _FCI_DebugParameters (InspectImage, EncapLocationOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<l>endif</l>
<c></c>
<l>reduce_domain (InspectImage, EncapLocationOut, EncapInspectedImage)</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Encap Image ROI For Encap Surface Inspection']</l>
<l>    _FCI_DebugParameters (EncapInspectedImage, EncapLocationOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif   </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Encap_Extraction">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapInspectedImage"/>
<parameter id="EncapLocation"/>
<parameter id="ErosionOffset"/>
<parameter id="InspectImage"/>
<parameter id="IsStepMode"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Encap_InnOuter_RgnProjection">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="InspectRgn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ProjectedRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (InspectRgn, ProjectedRegion, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<c></c>
<l>sort_region (ProjectedRegion, SortedRegions, 'character', 'true', 'row')</l>
<l>if (IsStepMode)</l>
<l>    select_obj (SortedRegions, OuterProjectedRgn, 1)</l>
<l>    Message := ['Projected Outer Teach Region']</l>
<l>    _FCI_DebugParameters (InspectImage, OuterProjectedRgn, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>if (IsStepMode)</l>
<l>    select_obj (SortedRegions, InnerProjectedRgn, 2)</l>
<l>    Message := ['Projected Inner Teach Region']</l>
<l>    _FCI_DebugParameters (InspectImage, InnerProjectedRgn, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Encap_InnOuter_RgnProjection">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="InspectImage"/>
<parameter id="InspectRgn"/>
<parameter id="IsStepMode"/>
<parameter id="ProjectedRegion"/>
<parameter id="RotationAngle"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Encap_RegionProjection">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="InspectRgn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ProjectedRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (InspectRgn, ProjectedRegion, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=['Projected Encap Teach Region']</l>
<l>    _FCI_DebugParameters (InspectImage, ProjectedRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Encap_RegionProjection">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="InspectImage"/>
<parameter id="InspectRgn"/>
<parameter id="IsStepMode"/>
<parameter id="ProjectedRegion"/>
<parameter id="RotationAngle"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_EncapDefect_Extraction">
<interface>
<io>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="EncapDefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="ErosionOffset" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrast" base_type="ctrl" dimension="0"/>
<par name="MinDefectArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsDefectFound" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>EncapLocationOut := EncapLocation</l>
<l>IsDefectFound := false</l>
<l>gen_empty_obj (EncapDefectRegion)</l>
<l>if(ErosionOffset &gt; 0)</l>
<l>    erosion_circle (EncapLocationOut, EncapLocationOut, ErosionOffset)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Encap Region after Erosion']</l>
<l>        _FCI_DebugParameters (InspectImage, EncapLocationOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<l>endif</l>
<c></c>
<l>reduce_domain (InspectImage, EncapLocationOut, EncapErodeImage)</l>
<l>deviation_image (EncapErodeImage, ImageDeviation1, 13.5, 13.5)</l>
<l>emphasize (ImageDeviation1, ImageEmphasize, 7, 7, 1)</l>
<l>threshold (ImageDeviation1, Region1, MinDefectContrast, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmenting the Deviation Image']</l>
<l>    _FCI_DebugParameters (ImageDeviation1, Region1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif     </l>
<c></c>
<l>connection (Region1, ConnectedRegions1)</l>
<l>fill_up (ConnectedRegions1, RegionFillUp1)</l>
<l>select_shape (RegionFillUp1, EncapDefectRegion, \
              'area', 'and', MinDefectArea, 99999)</l>
<c> </c>
<l>count_obj (EncapDefectRegion, Number)</l>
<l>if(Number&gt;0)</l>
<l>    IsDefectFound := true   </l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Encap Defects']</l>
<l>        _FCI_DebugParameters (InspectImage, EncapDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_EncapDefect_Extraction">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapDefectRegion"/>
<parameter id="EncapLocation"/>
<parameter id="ErosionOffset"/>
<parameter id="InspectImage"/>
<parameter id="IsDefectFound"/>
<parameter id="IsStepMode"/>
<parameter id="MinDefectArea"/>
<parameter id="MinDefectContrast"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Exact_DeviceLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="RoughDieLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SobelEdgeImage" base_type="iconic" dimension="0"/>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageDE" base_type="iconic" dimension="0"/>
<par name="DebugRegionDE" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="SobelFlag" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageDE" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>***Initialization Parameter</c>
<l>gen_empty_obj(DeviceLocation)</l>
<l>gen_empty_obj (DeviceEmptyObject)</l>
<l>gen_empty_obj(SobelEdgeImage)</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageDE)</l>
<l>gen_empty_obj (DebugRegionDE)</l>
<l>DebugMessageDE :=  []</l>
<c></c>
<c></c>
<l>region_features (RoughDieLocation, 'area', DeviceArea)</l>
<l>get_image_size(Image, ImageWidth, ImageHeight)</l>
<l>smallest_rectangle2 (RoughDieLocation, Row2, Column2, Phi1, Length11, Length21)</l>
<l>gen_rectangle2(Rectangle, Row2, Column2, Phi1, ImageWidth, Length21) </l>
<c></c>
<c>**** Reduced Image</c>
<l>reduce_domain(Image, Rectangle, ImageReduced)    </l>
<l>if (SobelFlag)</l>
<l>    sobel_amp(ImageReduced, ImageReduced, 'sum_abs', 3)</l>
<c>    </c>
<l>    if (IsStepMode)      </l>
<l>        Message:=['Edges in the Image']</l>
<l>        _FCI_DebugParameters (ImageReduced, Rectangle, DebugImageDE, DebugRegionDE,  DebugImageDE, DebugRegionDE, Message, DebugMessageDE, DebugMessageDE)</l>
<l>    endif      </l>
<l>endif  </l>
<c></c>
<l>if(MinDeviceContrast=0)</l>
<l>    min_max_gray (Rectangle, ImageReduced, 0, Min, Max, Range)</l>
<l>    threshold (ImageReduced, SegmentRegion, (Max-Min)/2, Max)</l>
<l>else</l>
<l>    threshold (ImageReduced, SegmentRegion, MinDeviceContrast, 255)</l>
<l>endif </l>
<c></c>
<l>if (IsStepMode)   </l>
<l>    Message:=['Initial Segmentation of the Image']</l>
<l>    _FCI_DebugParameters (ImageReduced, SegmentRegion, DebugImageDE, DebugRegionDE,  DebugImageDE, DebugRegionDE, Message, DebugMessageDE, DebugMessageDE)</l>
<l>endif    </l>
<c></c>
<l>fill_up (SegmentRegion, RegionFillUp)</l>
<l>connection (RegionFillUp, ConnectedRegions)    </l>
<l>gen_empty_obj (DeviceEmptyObject)</l>
<c></c>
<l>if(Track = 1 or Track = 2)</l>
<c>    </c>
<c>    ********Select_Small_Regions</c>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['width','height'], 'and', [0,0], [DeviceWidth/10, DeviceHeight/10])</l>
<l>    union1 (SelectedRegions, SmallAreaRegions)</l>
<l>    difference (SegmentRegion, SmallAreaRegions, RegionDifference)</l>
<l>    closing_circle (RegionDifference, RegionClosing1, 3.5)</l>
<l>    fill_up (RegionClosing1, RegionFillUp)</l>
<c>    </c>
<c>    ******* Select Edge Location</c>
<l>    connection (RegionFillUp, ConnectedRegions1)</l>
<l>    MinSelectHeight := DeviceHeight/5</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions, ['width','height'], 'and', \
                  [DeviceWidth,MinSelectHeight], [ImageWidth, ImageHeight])</l>
<l>    count_obj (SelectedRegions, Number)</l>
<c>    </c>
<l>    if(Number &gt; 0)</l>
<l>        area_center (SelectedRegions, TestArea, Dummy, Dummy)</l>
<l>        tuple_max (TestArea, MaxTestArea)</l>
<l>        AreaFraction := MaxTestArea / (DeviceArea*1.0)</l>
<c>        </c>
<l>        if(AreaFraction &gt; 0.7)</l>
<l>            select_shape_std (SelectedRegions, SelectedRegions3, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions3, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<l>        else</l>
<c>            </c>
<l>            union1 (SelectedRegions, RegionUnion)</l>
<l>            closing_rectangle1 (RegionUnion, RegionClosing2, MaskSize, MaskSize)</l>
<l>            connection (RegionClosing2, ConnectedRegions2)</l>
<l>            select_shape (ConnectedRegions2, SelectedRegions2, ['width', 'height'], 'and', [DeviceWidth, DeviceHeight], [ImageWidth, ImageHeight])</l>
<l>            select_shape_std(SelectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions1, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<c>            </c>
<l>        endif </l>
<l>    endif</l>
<l>else</l>
<c>    </c>
<l>    intensity (ConnectedRegions, ImageReduced, Mean, Deviation)</l>
<l>    MaxGrayMean := max(Mean)</l>
<l>    select_gray (ConnectedRegions, ImageReduced, DeviceEmptyObject, 'mean', 'and', 0.95*MaxGrayMean, MaxGrayMean)</l>
<l>    count_obj (DeviceEmptyObject, Number2)</l>
<l>    if(Number2&gt;1)</l>
<l>        select_shape_std (DeviceEmptyObject, DeviceEmptyObject, 'max_area', 70)</l>
<l>    endif </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>area_center(DeviceEmptyObject, DeviceArea, Row, Column)</l>
<l>if(DeviceArea &gt;0 and |DeviceArea|&gt;0)</l>
<l>    concat_obj(DeviceLocation,DeviceEmptyObject, DeviceLocation)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Exact Edge Location of the Image']</l>
<l>        _FCI_DebugParameters (Image, DeviceLocation, DebugImageDE, DebugRegionDE, DebugImageDE, DebugRegionDE,  Message, DebugMessageDE, DebugMessageDE)   </l>
<l>    endif </l>
<c></c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Exact_DeviceLocation">
<parameters>
<parameter id="DebugImageDE"/>
<parameter id="DebugMessageDE"/>
<parameter id="DebugRegionDE"/>
<parameter id="DeviceHeight"/>
<parameter id="DeviceLocation"/>
<parameter id="DeviceWidth"/>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="MaskSize"/>
<parameter id="MinDeviceContrast"/>
<parameter id="RoughDieLocation"/>
<parameter id="SobelEdgeImage"/>
<parameter id="SobelFlag"/>
<parameter id="Track"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Extract_FlexLine">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ProjectedFlexLine" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="FlexLineRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (FlexLineRegion)</l>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>count_obj (ProjectedFlexLine, Number)</l>
<l>for i := 1 to Number by 1</l>
<l>    select_obj (ProjectedFlexLine, ObjectSelected, i)</l>
<l>    reduce_domain (Image, ObjectSelected, ImageReduced)</l>
<l>    binary_threshold (ImageReduced, Region, 'max_separability', 'dark', UsedThreshold)</l>
<l>    fill_up (Region, RegionFillUp)</l>
<l>    connection (RegionFillUp, ConnectedRegions)</l>
<l>    select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>    concat_obj (FlexLineRegion, SelectedRegions, FlexLineRegion)</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmented Flex Line']</l>
<l>    _FCI_DebugParameters (Image, FlexLineRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Extract_FlexLine">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FlexLineRegion"/>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="ProjectedFlexLine"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Extract_LocationParameterData">
<interface>
<ic>
<par name="ConcatProjectionParam" base_type="ctrl" dimension="0"/>
<par name="CompletedEdgeTeachDocs" base_type="ctrl" dimension="0"/>
<par name="EnableEdgeTeachDocs" base_type="ctrl" dimension="0"/>
<par name="ConcatDatumTeachTuple" base_type="ctrl" dimension="0"/>
<par name="I" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsSelect" base_type="ctrl" dimension="0"/>
<par name="InspectRotationAngle" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsSelect := true</l>
<l>tuple_find (CompletedEdgeTeachDocs, 1, IsCompletedEdgeTeach)</l>
<l>tuple_find (EnableEdgeTeachDocs, 1, IsEnableEdgeTeach)</l>
<l>tuple_find (ConcatDatumTeachTuple, 1, IsEnableDatumTeach)</l>
<c></c>
<l>if(IsEnableDatumTeach = -1 and IsEnableEdgeTeach = -1)</l>
<l>    IsSelect := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>if(IsEnableDatumTeach # -1)</l>
<c>    ** Get shifted information from the datum of the current Doc</c>
<l>    if(ConcatDatumTeachTuple[I] = 1 and EnableEdgeTeachDocs[I] = 1)</l>
<l>        ExtractData := ConcatProjectionParam[3*I:3*(I+1)-1]</l>
<l>        InspectRotationAngle    := ExtractData[0]</l>
<l>        InspectShiftAlongRow    := ExtractData[1]</l>
<l>        InspectShiftAlongColumn := ExtractData[2]</l>
<l>    else</l>
<c>        ** Get shifted information from the datum of the others Doc</c>
<l>        IsSelect := false</l>
<l>        for j := 0 to |ConcatDatumTeachTuple| - 1 by 1</l>
<l>            if(ConcatDatumTeachTuple[j] = 1 and EnableEdgeTeachDocs[j] = 1)</l>
<l>                IsSelect := true</l>
<l>                ExtractData := ConcatProjectionParam[3*j:3*(j+1)-1]</l>
<l>                InspectRotationAngle    := ExtractData[0]</l>
<l>                InspectShiftAlongRow    := ExtractData[1]</l>
<l>                InspectShiftAlongColumn := ExtractData[2]</l>
<l>                break</l>
<l>            endif</l>
<l>         endfor</l>
<c>        </c>
<c>        ** Get shifted information from the device edge of the others Doc</c>
<l>        if(not IsSelect)</l>
<l>            for k := 0 to |EnableEdgeTeachDocs|-1 by 1</l>
<l>                if(EnableEdgeTeachDocs[k] = 1)</l>
<l>                    IsSelect := true</l>
<l>                    ExtractData := ConcatProjectionParam[3*k:3*(k+1)-1]</l>
<l>                    InspectRotationAngle    := ExtractData[0]</l>
<l>                    InspectShiftAlongRow    := ExtractData[1]</l>
<l>                    InspectShiftAlongColumn := ExtractData[2]</l>
<l>                    break</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<l>    endif</l>
<l>else</l>
<c>    ** Get shifted information from the device edge of the current Doc</c>
<l>    if (EnableEdgeTeachDocs[I] = 1)</l>
<l>        ExtractData := ConcatProjectionParam[3*I:3*(I+1)-1]</l>
<l>        InspectRotationAngle    := ExtractData[0]</l>
<l>        InspectShiftAlongRow    := ExtractData[1]</l>
<l>        InspectShiftAlongColumn := ExtractData[2]</l>
<l>    else</l>
<c>        ** Get shifted information from the device edge of the others Doc</c>
<l>        IsSelect := false</l>
<l>        for j := 0 to |EnableEdgeTeachDocs| - 1 by 1</l>
<l>            if(EnableEdgeTeachDocs[j] = 1)</l>
<l>                IsSelect := true</l>
<l>                ExtractData := ConcatProjectionParam[3*j:3*(j+1)-1]</l>
<l>                InspectRotationAngle    := ExtractData[0]</l>
<l>                InspectShiftAlongRow    := ExtractData[1]</l>
<l>                InspectShiftAlongColumn := ExtractData[2]</l>
<l>                break</l>
<l>            endif</l>
<l>         endfor</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Extract_LocationParameterData">
<parameters>
<parameter id="CompletedEdgeTeachDocs"/>
<parameter id="ConcatDatumTeachTuple"/>
<parameter id="ConcatProjectionParam"/>
<parameter id="EnableEdgeTeachDocs"/>
<parameter id="I"/>
<parameter id="InspectRotationAngle"/>
<parameter id="InspectShiftAlongColumn"/>
<parameter id="InspectShiftAlongRow"/>
<parameter id="IsSelect"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_ExtractExactEdge">
<interface>
<io>
<par name="DocImage" base_type="iconic" dimension="0"/>
<par name="EdgeRectangle" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SelectedRegions1" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinEdgeContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEdgeContrast" base_type="ctrl" dimension="0"/>
<par name="EdgeRegionOpening" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassEdge" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPassEdge:=false</l>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>reduce_domain (DocImage, EdgeRectangle, ImageReduced)</l>
<l>threshold (ImageReduced, Region, MinEdgeContrast, MaxEdgeContrast)</l>
<l>fill_up (Region, RegionFillUp)</l>
<l>if (IsStepMode)</l>
<l>     Message:=[' Initial segmentation to obtain Exact Edge of Area['+(nPVIArea+1)+']']</l>
<l>     _FCI_DebugParameters (ImageReduced, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>connection (RegionFillUp, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions1, 'area', 'and', 5000, 999999999)</l>
<l>opening_circle (SelectedRegions1, RegionOpening, EdgeRegionOpening)</l>
<l>if (IsStepMode)</l>
<l>     Message:=[' Edge region opened up using EdgeRegionOpening of Area['+(nPVIArea+1)+']']</l>
<l>     _FCI_DebugParameters (ImageReduced, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<l>connection (RegionOpening, ConnectedRegions1)</l>
<l>select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', 5000, 999999999)</l>
<c></c>
<l>area_center (SelectedRegions1, EdgeArea, Dummy, Dummy)</l>
<l>if (EdgeArea&gt;0 and |EdgeArea|&gt;0)</l>
<l>     IsPassEdge := true</l>
<l>     if (IsStepMode)</l>
<l>          Message:=[' Exact Edge Region of Area['+(nPVIArea+1)+']']</l>
<l>          _FCI_DebugParameters (ImageReduced, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_ExtractExactEdge">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DocImage"/>
<parameter id="EdgeRectangle"/>
<parameter id="EdgeRegionOpening"/>
<parameter id="IsPassEdge"/>
<parameter id="IsStepMode"/>
<parameter id="MaxEdgeContrast"/>
<parameter id="MinEdgeContrast"/>
<parameter id="SelectedRegions1"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Finding_CVL_Datum">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="MatchModel" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsFindCVLDatum" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>IsFindCVLDatum := false</l>
<c></c>
<l>SearchLimitAlongX := 1000</l>
<l>SearchLimitAlongY := 1000</l>
<l>IncrementStep := 100</l>
<l>nSteps := SearchLimitAlongX/IncrementStep</l>
<c></c>
<l>gen_rectangle1 (ModelRegion, CVLDatumRows[0], CVLDatumCols[0], CVLDatumRows[1], CVLDatumCols[1])</l>
<l>smallest_rectangle2 (ModelRegion, CVLDatumCenterRow, CVLDatumCenterColumn, Phi, PrimaryLength1, SecondaryLength2)</l>
<c></c>
<l>for StepIndex := 1 to nSteps by 1</l>
<l>    if (PatternSearchAreaAlongX &lt; SearchLimitAlongX and PatternSearchAreaAlongY &lt; SearchLimitAlongY)</l>
<l>        gen_rectangle2 (SearchRegion4CVL, CVLDatumCenterRow, CVLDatumCenterColumn, Phi, PatternSearchAreaAlongX, PatternSearchAreaAlongY)</l>
<l>        reduce_domain (InspectImage, SearchRegion4CVL, SearchImage4CVL)</l>
<l>        _Find_Model (InspectImage, SearchRegion4CVL, ModelRegion, MatchModel, CVLDatumCenterRow, CVLDatumCenterColumn, CVLModelID, MinAcceptanceScore, MaxRotationAngle, IsFindDatum, MatchRow, MatchColumn, MatchAngle, MatchScore)</l>
<c>        </c>
<l>        if(|MatchRow| = 0)</l>
<l>            PatternSearchAreaAlongX := PatternSearchAreaAlongX + IncrementStep</l>
<l>            PatternSearchAreaAlongY := PatternSearchAreaAlongY + IncrementStep</l>
<l>        else</l>
<l>            IsFindCVLDatum := true</l>
<l>        endif</l>
<c>        </c>
<l>        if(IsFindCVLDatum)</l>
<l>            break</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Finding_CVL_Datum">
<parameters>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLModelID"/>
<parameter id="InspectImage"/>
<parameter id="IsFindCVLDatum"/>
<parameter id="MatchModel"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Finding_TiltInspectionParameter">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="TiltRegion" base_type="iconic" dimension="0"/>
<par name="InspectTiltRegionPortion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="TiltRectRows" base_type="ctrl" dimension="0"/>
<par name="TiltRectCols" base_type="ctrl" dimension="0"/>
<par name="InspectRotationAngle" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongColumn" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="Distance4TiltInsp" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TiltHeight" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>gen_empty_obj (TiltRegion)</l>
<l>gen_empty_obj (InspectTiltRegionPortion)</l>
<l>area_center (DeviceLocationSelected, Du, DeviceCenterRow, DeviceCenterColumn)</l>
<c></c>
<l>if(Track = 1 or Track = 2)</l>
<c></c>
<c>    *****07-08</c>
<l>    gen_rectangle1 (Rectangle, TiltRectRows[0], TiltRectCols[0], TiltRectRows[1], TiltRectCols[1])</l>
<c>    </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -InspectRotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>    hom_mat2d_translate (HomMat2DRotate, -InspectShiftAlongRow, -InspectShiftAlongColumn, HomMat2DTranslate)</l>
<l>    affine_trans_region (Rectangle, RegionAffineTrans, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Projected Teach Region for Tilt Inspection']</l>
<l>        _FCI_DebugParameters (InspectImage, RegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    </c>
<c>    </c>
<l>    reduce_domain (InspectImage, RegionAffineTrans, TiltInspectImage)  </l>
<l>    if(Contrast=0)</l>
<l>        min_max_gray (RegionAffineTrans, TiltInspectImage, 0, Min, Max, Range)</l>
<l>        threshold (TiltInspectImage, SegmentRegion, (Max-Min)/2, Max)</l>
<l>    else</l>
<l>        threshold (TiltInspectImage, SegmentRegion, Contrast, 255)</l>
<l>    endif</l>
<l>    fill_up (SegmentRegion, RegionFillUp)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Initial segmentation of the image']</l>
<l>        _FCI_DebugParameters (TiltInspectImage, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<c>    </c>
<l>    connection (RegionFillUp, ConnectedRegions)</l>
<l>    intensity (ConnectedRegions, TiltInspectImage, Mean, Deviation)</l>
<l>    MaxGrayMean := max(Mean)</l>
<l>    select_gray (ConnectedRegions, TiltInspectImage, TiltRegion, 'mean', 'and', 0.95*MaxGrayMean, MaxGrayMean)</l>
<l>    count_obj (TiltRegion, Number2)</l>
<l>    if(Number2&gt;1)</l>
<l>        select_shape_std (TiltRegion, TiltRegion, 'max_area', 70)</l>
<l>    endif</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Segmented Exact Tilt Region']</l>
<l>        _FCI_DebugParameters (TiltInspectImage, TiltRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<c></c>
<c>    ******Rotate to horizontal axis</c>
<l>    elliptic_axis (TiltRegion, Dummy, Dummy, Phi)</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -Phi, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>    affine_trans_region (TiltRegion, HorTiltRegion, HomMat2DRotate, 'nearest_neighbor')</l>
<c></c>
<l>    partition_dynamic (HorTiltRegion, Partitioned, Distance4TiltInsp, 20)</l>
<l>    count_obj (Partitioned, Number)</l>
<l>    if(FoV = 1)</l>
<l>        select_obj (Partitioned, InspectTiltRegionPortion, 1)</l>
<l>    elseif(FoV = nFoVs)</l>
<l>        select_obj (Partitioned, InspectTiltRegionPortion, Number)</l>
<l>    endif</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Inspected Tilt Region']</l>
<l>        _FCI_DebugParameters (TiltInspectImage, InspectTiltRegionPortion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    region_features (InspectTiltRegionPortion, 'height', TiltHeight)</l>
<c></c>
<l>endif</l>
<c></c>
<l>if(Track = 3)</l>
<c>    </c>
<l>    concat_obj (TiltRegion, DeviceLocationSelected, TiltRegion)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Segmented Exact Tilt Region']</l>
<l>        _FCI_DebugParameters (InspectImage, TiltRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<c></c>
<l>    elliptic_axis (TiltRegion, Dummy, Dummy, Phi)</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -Phi, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>    affine_trans_region (TiltRegion, HorTiltRegion, HomMat2DRotate, 'nearest_neighbor')</l>
<c></c>
<l>    partition_dynamic (HorTiltRegion, Partitioned, Distance4TiltInsp, 20)</l>
<l>    count_obj (Partitioned, Number)</l>
<l>    if(FoV = 1)</l>
<l>        select_obj (Partitioned, InspectTiltRegionPortion, 1)</l>
<l>    elseif(FoV = nFoVs)</l>
<l>        select_obj (Partitioned, InspectTiltRegionPortion, Number)</l>
<l>    endif</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Inspected Tilt Region']</l>
<l>        _FCI_DebugParameters (InspectImage, InspectTiltRegionPortion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    region_features (InspectTiltRegionPortion, 'height', TiltHeight)</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Finding_TiltInspectionParameter">
<parameters>
<parameter id="Contrast"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="Distance4TiltInsp"/>
<parameter id="FoV"/>
<parameter id="InspectImage"/>
<parameter id="InspectRotationAngle"/>
<parameter id="InspectShiftAlongColumn"/>
<parameter id="InspectShiftAlongRow"/>
<parameter id="InspectTiltRegionPortion"/>
<parameter id="IsStepMode"/>
<parameter id="TiltHeight"/>
<parameter id="TiltRectCols"/>
<parameter id="TiltRectRows"/>
<parameter id="TiltRegion"/>
<parameter id="Track"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Finding_TiltInspectionParameter4Side">
<interface>
<io>
<par name="SideImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SelectedRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Contrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="SideTiltHeight" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>threshold(SideImage, SideImageRegion, Contrast, 255)</l>
<l>connection(SideImageRegion, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>region_features(SelectedRegions, 'height', SideTiltHeight)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Finding_TiltInspectionParameter4Side">
<parameters>
<parameter id="Contrast"/>
<parameter id="SelectedRegions"/>
<parameter id="SideImage"/>
<parameter id="SideTiltHeight"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Finding_TiltInspectionParameterTop">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SortedRegions" base_type="iconic" dimension="0"/>
<par name="SelectedRegion4SlotInspection" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Contrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TiltHeight" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>DilationMask := 100</l>
<c></c>
<c>***** Threshold of the Inspected Image</c>
<l>threshold(InspectImage, InspectedRegion, Contrast, 255)</l>
<c></c>
<c>***** Slot Region</c>
<l>intersection(DeviceLocationSelected, InspectedRegion, SlotRegion)</l>
<c></c>
<c></c>
<c>***** Dilation of the Device Location of a given Structuring Mask</c>
<l>dilation_rectangle1(DeviceLocationSelected, RegionDilation, DilationMask, DilationMask)</l>
<l>intersection(InspectedRegion, RegionDilation, RegionIntersection)</l>
<c></c>
<c>*****</c>
<l>difference(RegionIntersection, SlotRegion, RegionDifference)</l>
<l>connection(RegionDifference, ConnectedRegions)</l>
<l>region_features(ConnectedRegions, 'width', Width)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, 'width', 'and', 0.8*max(Width), 1.5*max(Width))</l>
<l>union1(SelectedRegions, RegionUnion)</l>
<c></c>
<c>*****Finding the Exact One</c>
<l>connection(InspectedRegion, ConnectedRegions1)</l>
<l>intersection(ConnectedRegions1, RegionUnion, RegionIntersection2)</l>
<l>area_center(RegionIntersection2, Area, Row3, Column3)</l>
<l>tuple_greater_elem(Area, 1, Greater1)</l>
<l>tuple_find(Greater1, 1, Indices)</l>
<c></c>
<l>gen_empty_obj(EmptyObject)</l>
<l>for i:= 0 to |Indices|-1 by 1</l>
<l>    select_obj(ConnectedRegions1, ObjectSelected, Indices[i]+1)</l>
<l>    concat_obj(EmptyObject, ObjectSelected, EmptyObject)</l>
<l>endfor</l>
<c></c>
<l>sort_region (EmptyObject, SortedRegions, 'character', 'true', 'row')</l>
<l>count_obj (SortedRegions, Number1)</l>
<l>select_obj (SortedRegions, SelectedRegion4SlotInspection, Number1)</l>
<l>region_features (SelectedRegion4SlotInspection, 'height', TiltHeight)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Finding_TiltInspectionParameterTop">
<parameters>
<parameter id="Contrast"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="InspectImage"/>
<parameter id="SelectedRegion4SlotInspection"/>
<parameter id="SortedRegions"/>
<parameter id="TiltHeight"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_FitEncapInspectRectangles">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="EncapInspectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterRow" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterColumn" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_X_Shift" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_Y_Shift" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceRow" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceColumn" base_type="ctrl" dimension="0"/>
<par name="AngleOfDeviation" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>dev_display(Image)</l>
<c></c>
<l>nEncapRect := |EncapInspectCenterRow|</l>
<l>gen_empty_obj (EncapInspectRegion)</l>
<c></c>
<l>for i := 0 to nEncapRect - 1 by 1</l>
<c> </c>
<l>    SelectedEncapRows := EncapInspectRectRows[2*i: 2*(i+1)-1]</l>
<l>    SelectedEncapCols := EncapInspectRectCols[2*i: 2*(i+1)-1]</l>
<c>    </c>
<l>    SelectEncapCenterRow := EncapInspectCenterRow[i]</l>
<l>    SelectEncapCenterColumn := EncapInspectCenterColumn[i]</l>
<c>    </c>
<l>    SelectedEncap_X_ShiftFromMidPoint := EncaptoEdge_X_Shift[i]</l>
<l>    SelectedEncap_Y_ShiftFromMidPoint := EncaptoEdge_Y_Shift[i]</l>
<c>    </c>
<l>    gen_rectangle1 (GeneratedEncapRegion, SelectedEncapRows[0], SelectedEncapCols[0], SelectedEncapRows[1], SelectedEncapCols[1])</l>
<c></c>
<l>    vector_angle_to_rigid (SelectEncapCenterRow, SelectEncapCenterColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, -rad(AngleOfDeviation), EncapRegionHomMat2D)</l>
<l>    hom_mat2d_translate_local (EncapRegionHomMat2D, -SelectedEncap_X_ShiftFromMidPoint, -SelectedEncap_Y_ShiftFromMidPoint, EncapRegionHomMat2DTranslate)</l>
<l>    affine_trans_region (GeneratedEncapRegion, FitGeneratedEncapRegion, EncapRegionHomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<l>    concat_obj(EncapInspectRegion, FitGeneratedEncapRegion, EncapInspectRegion)</l>
<c>  </c>
<l>endfor</l>
<c></c>
<l>dev_display (Image)</l>
<l>dev_display (EncapInspectRegion)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_FitEncapInspectRectangles">
<parameters>
<parameter id="AngleOfDeviation"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EncapInspectCenterColumn"/>
<parameter id="EncapInspectCenterRow"/>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapInspectRegion"/>
<parameter id="EncaptoEdge_X_Shift"/>
<parameter id="EncaptoEdge_Y_Shift"/>
<parameter id="Image"/>
<parameter id="IsStepMode"/>
<parameter id="MidInspectDeviceColumn"/>
<parameter id="MidInspectDeviceRow"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Gen_Rectangles">
<interface>
<oo>
<par name="RectRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="NoOfRect" base_type="ctrl" dimension="0"/>
<par name="RectRows" base_type="ctrl" dimension="0"/>
<par name="RectCols" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RectRowsOut" base_type="ctrl" dimension="0"/>
<par name="RectColsOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>RectColsOut := RectCols</l>
<l>RectRowsOut := RectRows</l>
<l>gen_empty_obj (RectRegion)</l>
<l>for rect := 1 to NoOfRect by 1</l>
<l>    stop()</l>
<l>    draw_rectangle1(WindowHandle, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1(Rectangle, Row1, Column1, Row2, Column2)</l>
<l>    concat_obj (RectRegion, Rectangle, RectRegion)</l>
<l>    tuple_concat (RectRowsOut, [Row1, Row2], RectRowsOut)</l>
<l>    tuple_concat (RectColsOut, [Column1, Column2], RectColsOut)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="_FCI_Gen_Rectangles">
<parameters>
<parameter id="NoOfRect"/>
<parameter id="RectCols"/>
<parameter id="RectColsOut"/>
<parameter id="RectRegion"/>
<parameter id="RectRows"/>
<parameter id="RectRowsOut"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_GenerateRectangle">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>stop()</l>
<c></c>
<l>draw_rectangle1 (WindowHandle, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1 (EncapRectangle, Row1, Column1, Row2, Column2)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_GenerateRectangle">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_GenerateRectangleRegion">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>stop()</l>
<l>draw_rectangle1(200000, Row1, Column1, Row2, Column2)</l>
<l>gen_rectangle1(Rectangle, Row1, Column1, Row2, Column2)</l>
<l>return ()</l>
</body>
<docu id="_FCI_GenerateRectangleRegion">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="Image"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_GetRegionToDeviceRelativeDistance">
<interface>
<io>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="MidRow" base_type="ctrl" dimension="0"/>
<par name="MidColumn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RegionToDevice_X_Shift" base_type="ctrl" dimension="0"/>
<par name="RegionToDevice_Y_Shift" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>            GetLocationCenter (DeviceLocationSelected, LocationCenterRow, LocationCenterColumn)</l>
<c>                    </c>
<l>            GetRegionCenter (TeachRegion, Row1, Column1, Row2, Column2, RegionCenterRow, RegionCenterColumn)</l>
<c>                        </c>
<l>            GetRelativeDistance (LocationCenterRow, LocationCenterColumn, RegionCenterRow, RegionCenterColumn, RegionToDevice_X_Shift, RegionToDevice_Y_Shift)</l>
<l>return ()</l>
</body>
<docu id="_FCI_GetRegionToDeviceRelativeDistance">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="MidColumn"/>
<parameter id="MidRow"/>
<parameter id="RegionToDevice_X_Shift"/>
<parameter id="RegionToDevice_Y_Shift"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Image_Sub_PVI">
<interface>
<io>
<par name="TeachObj" base_type="iconic" dimension="0"/>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageSub" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="PVITeachRows" base_type="ctrl" dimension="0"/>
<par name="PVITeachColumns" base_type="ctrl" dimension="0"/>
<par name="PVIAreaCenterRow" base_type="ctrl" dimension="0"/>
<par name="PVIAreaCenterColumn" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceRow" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceColumn" base_type="ctrl" dimension="0"/>
<par name="PVItoEdge_Y_Shift" base_type="ctrl" dimension="0"/>
<par name="PVItoEdge_X_Shift" base_type="ctrl" dimension="0"/>
<par name="AngleOfDeviation" base_type="ctrl" dimension="0"/>
<par name="DefectCharacteristics" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="IntensityIndex" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>GeneratedPVIRegionRow := PVIAreaCenterRow</l>
<l>GeneratedPVIRegionColumn := PVIAreaCenterColumn</l>
<c></c>
<c>**** Teach Image Orientation wrt Inspected Image</c>
<l>if(FoV = 1 or FoV = nFoVs)</l>
<l>    vector_angle_to_rigid (GeneratedPVIRegionRow, GeneratedPVIRegionColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, -rad(AngleOfDeviation), PVIRegionHomMat2D)</l>
<l>    hom_mat2d_translate_local(PVIRegionHomMat2D, -PVItoEdge_X_Shift, -PVItoEdge_Y_Shift, PVIRegionHomMat2DTranslate)</l>
<l>    affine_trans_image (TeachObj, ImageAffineTrans, PVIRegionHomMat2DTranslate, 'constant', 'false')</l>
<l>else</l>
<l>    vector_angle_to_rigid (GeneratedPVIRegionRow, GeneratedPVIRegionColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, rad(AngleOfDeviation), PVIRegionHomMat2D)</l>
<l>    hom_mat2d_translate_local(PVIRegionHomMat2D, -PVItoEdge_X_Shift, -PVItoEdge_Y_Shift, PVIRegionHomMat2DTranslate)</l>
<l>    affine_trans_image (TeachObj, ImageAffineTrans, PVIRegionHomMat2DTranslate, 'constant', 'false')                      </l>
<l>endif</l>
<c></c>
<c>**** Reduced PVI region in shifted and oriented image ****</c>
<l>reduce_domain (ImageAffineTrans, RegionForPVI_Inspection, ImageReducedInTeach)</l>
<c></c>
<c></c>
<c>**** Image Subtraction to highlight the defect region ***</c>
<l>if(DefectCharacteristics=0)</l>
<l>    sub_image (ImageReducedInTeach, ImageForPVI_Inspection, ImageSub, 1, 0)</l>
<l>else</l>
<l>    sub_image (ImageForPVI_Inspection, ImageReducedInTeach, ImageSub, 1, 0)</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    count_obj(DebugRegionOut, DebugRegNo)</l>
<l>    count_obj(DebugImageOut,DebugImageNo)</l>
<l>    tuple_length(DebugMessageOut,DebugMsgNo)</l>
<l>    if(DebugImageNo=DebugRegNo and DebugMsgNo=DebugRegNo)</l>
<l>        Message:=['IntensityIndex: Subtracted Image of Teach and Inspection' ]</l>
<l>        _FCI_DebugParameters (InspectImage, RegionForPVI_Inspection, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>endif </l>
<l>return ()</l>
</body>
<docu id="_FCI_Image_Sub_PVI">
<parameters>
<parameter id="AngleOfDeviation"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectCharacteristics"/>
<parameter id="FoV"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="ImageSub"/>
<parameter id="InspectImage"/>
<parameter id="IntensityIndex"/>
<parameter id="IsStepMode"/>
<parameter id="MidInspectDeviceColumn"/>
<parameter id="MidInspectDeviceRow"/>
<parameter id="PVIAreaCenterColumn"/>
<parameter id="PVIAreaCenterRow"/>
<parameter id="PVITeachColumns"/>
<parameter id="PVITeachRows"/>
<parameter id="PVItoEdge_X_Shift"/>
<parameter id="PVItoEdge_Y_Shift"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="TeachObj"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_BlowHole">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="BHDefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrast" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinCircularity" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="GrayMean" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AllEBHDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllEBHDefecMinLength" base_type="ctrl" dimension="0"/>
<par name="AllEBHDefecMinSquareSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> ***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<l>gen_empty_obj (BHDefectRegion)</l>
<c>                </c>
<c>** Segmentation image based on square size of the defect</c>
<l>if(MinSquareSize &gt; 3)</l>
<l>    deviation_image (InspectImage, ImageDeviation, MinSquareSize, MinSquareSize)</l>
<l>else</l>
<l>    deviation_image (InspectImage, ImageDeviation, 3, 3)</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmenting the Deviation Image Based On Defect Square Size']</l>
<l>    _FCI_DebugParameters (ImageDeviation, DebugRegionOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c></c>
<l>threshold (ImageDeviation, CandidateDefectRegion, MinDefectContrast, 255)</l>
<l>connection (CandidateDefectRegion, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, RegionFillUp)</l>
<c></c>
<c>** Select blow hole shape based on size</c>
<l>select_shape (RegionFillUp, DefectRegion, 'area', 'and', \
              MinSize, 99999)</l>
<l>count_obj (DefectRegion, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Blow Hole Defect Shape Based On Min Size']</l>
<l>        _FCI_DebugParameters (InspectImage, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<l>connection (DefectRegion, ConnectedDefectRegion)</l>
<l>select_shape (ConnectedDefectRegion, SelectedDefectRegion, \
              ['circularity','max_diameter','width','height'], 'and', \
              [MinCircularity, MinLength, MinSquareSize, MinSquareSize] , [1, 99999, 99999, 99999])</l>
<c>                                                        </c>
<l>select_gray (SelectedDefectRegion, InspectImage, BHDefectRegion, \
             'mean', 'and', 0, GrayMean)</l>
<c></c>
<c>** Expand step by step for end-user                          </c>
<l>if(IsStepMode)</l>
<l>    select_shape (ConnectedDefectRegion, SelectedDefectRegion, ['width','height'], \
                  'and', [MinSquareSize, MinSquareSize], [99999, 99999])</l>
<l>    count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>    if(SelectedDefectRegionCount &gt; 0)</l>
<l>        Message:=['Blow Hole Defect Region Based On Min Square Size']</l>
<l>        _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedDefectRegion, SelectedDefectRegion, 'max_diameter', \
                  'and', MinLength, 99999)</l>
<l>        count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>        if(SelectedDefectRegionCount &gt; 0)</l>
<l>              Message:=['Blow Hole Defect Region Based On Min Length']</l>
<l>              _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>              </c>
<l>              select_shape (SelectedDefectRegion, SelectedDefectRegion, 'circularity', \
                  'and', MinCircularity, 1)</l>
<l>              count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>              if(SelectedDefectRegionCount &gt; 0)</l>
<l>                  Message:=['Blow Hole Defect Region Based On Min Circularity']</l>
<l>                  _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>              endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>count_obj (BHDefectRegion, BHDefectRegionCount)</l>
<l>if(BHDefectRegionCount &gt; 0)</l>
<l>    IsPass := false</l>
<c>    </c>
<l>    region_features (BHDefectRegion, ['area','max_diameter','width','height'], Value)</l>
<l>    AllEBHDefectMinSize             := Value[0]</l>
<l>    AllEBHDefecMinLength            := Value[1]</l>
<l>    AllEBHDefecMinSquareSize        := min2(Value[2],Value[3])</l>
<c></c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Final Blow Hole Defect Region Based On Maximum Gray Value']</l>
<l>        _FCI_DebugParameters (InspectImage, BHDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif    </l>
<l>endif </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_BlowHole">
<parameters>
<parameter id="AllEBHDefecMinLength"/>
<parameter id="AllEBHDefecMinSquareSize"/>
<parameter id="AllEBHDefectMinSize"/>
<parameter id="BHDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="GrayMean"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinCircularity"/>
<parameter id="MinDefectContrast"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Contamination">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ContaminationDefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrast" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLengthCT" base_type="ctrl" dimension="0"/>
<par name="MinSquareSizeCT" base_type="ctrl" dimension="0"/>
<par name="MaxCircularityCT" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AllECTDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllECTDefecMinLength" base_type="ctrl" dimension="0"/>
<par name="AllECTDefecMinSquareSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsPass := true</l>
<l>gen_empty_obj (ContaminationDefectRegion)</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>** Segmentation image based on square size of the defect</c>
<l>if(MinSquareSizeCT &gt; 3)</l>
<l>    deviation_image (InspectImage, ImageDeviation, MinSquareSizeCT, MinSquareSizeCT)</l>
<l>else</l>
<l>    deviation_image (InspectImage, ImageDeviation, 3, 3)</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmenting the Deviation Image Based On Defect Square Size']</l>
<l>    _FCI_DebugParameters (ImageDeviation, DebugRegionOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif  </l>
<c></c>
<l>threshold (ImageDeviation, CandidateDefectRegion, MinDefectContrast, 255)</l>
<l>connection (CandidateDefectRegion, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, RegionFillUp)</l>
<c></c>
<c>** Select contamination based on size</c>
<l>select_shape (RegionFillUp, DefectRegion, 'area', 'and', \
              MinSize, 99999)</l>
<l>count_obj (DefectRegion, DefectRegionCount)</l>
<l>if(DefectRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Contamination Defect Shape Based On Min Size']</l>
<l>        _FCI_DebugParameters (InspectImage, DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<l>connection (DefectRegion, ConnectedDefectRegion)</l>
<l>select_shape (ConnectedDefectRegion, ContaminationDefectRegion, \
              ['circularity','max_diameter','width','height'], 'and', \
              [0, MinLengthCT, MinSquareSizeCT, MinSquareSizeCT] , [MaxCircularityCT, 99999, 99999, 99999])</l>
<c></c>
<c>** Expand step by step for end-user                          </c>
<l>if(IsStepMode)</l>
<l>    select_shape (ConnectedDefectRegion, SelectedDefectRegion, ['width','height'], \
                  'and', [MinSquareSizeCT, MinSquareSizeCT], [99999, 99999])</l>
<l>    count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>    if(SelectedDefectRegionCount &gt; 0)</l>
<l>        Message:=['Contamination Defect Region Based On Min Square Size']</l>
<l>        _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedDefectRegion, SelectedDefectRegion, 'max_diameter', \
                  'and', MinLengthCT, 99999)</l>
<l>        count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>        if(SelectedDefectRegionCount &gt; 0)</l>
<l>            Message:=['Contamination Defect Region Based On Min Length']</l>
<l>            _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>            count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>            if(SelectedDefectRegionCount &gt; 0)</l>
<l>                  select_shape (SelectedDefectRegion, SelectedDefectRegion, 'circularity', \
                                'and', 0, MaxCircularityCT)</l>
<l>                  count_obj(SelectedDefectRegion, SelectedDefectRegionCount)</l>
<l>                  if(SelectedDefectRegionCount &gt; 0)</l>
<l>                       Message:=['Contamination Defect Region Based On Max Circularity']</l>
<l>                       _FCI_DebugParameters (InspectImage, SelectedDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>                  endif</l>
<l>            endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>count_obj (ContaminationDefectRegion, ContaminationDefectRegionCount)</l>
<l>if(ContaminationDefectRegionCount &gt; 0)        </l>
<l>    IsPass := false</l>
<c></c>
<l>    region_features (ContaminationDefectRegion, ['area','max_diameter','width','height'], Value)</l>
<l>    AllECTDefectMinSize             := Value[0]</l>
<l>    AllECTDefecMinLength            := Value[1]</l>
<l>    AllECTDefecMinSquareSize        := min2(Value[2],Value[3])</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Final Encap Contamination Defect Region']</l>
<l>        _FCI_DebugParameters (InspectImage, ContaminationDefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)    </l>
<l>    endif </l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_Contamination">
<parameters>
<parameter id="AllECTDefecMinLength"/>
<parameter id="AllECTDefecMinSquareSize"/>
<parameter id="AllECTDefectMinSize"/>
<parameter id="ContaminationDefectRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxCircularityCT"/>
<parameter id="MinDefectContrast"/>
<parameter id="MinLengthCT"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSizeCT"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_CoverLayer">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="CVLCheckRgn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="CoverLayerRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="MaskWidth" base_type="ctrl" dimension="0"/>
<par name="MaskHeight" base_type="ctrl" dimension="0"/>
<par name="LengthOfCVL" base_type="ctrl" dimension="0"/>
<par name="MinCVLHeight" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsCoverLayer" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>***Parameter</c>
<l>IsCoverLayer := false</l>
<c></c>
<c>*****</c>
<l>gen_empty_obj (CoverLayerRegion)</l>
<c></c>
<l>get_image_size (InspectImage, ImageWidth, ImageHeight)</l>
<l>reduce_domain (InspectImage, CVLCheckRgn, ImageReduced)</l>
<l>region_features (CVLCheckRgn, ['width', 'height'], Value)</l>
<l>Width := Value[0]</l>
<l>Height := Value[1]</l>
<c></c>
<l>if(Width &gt; Height)</l>
<l>    gray_closing_rect (ImageReduced, ImageClosing, MaskSize, 0.5)  </l>
<l>    gray_opening_rect (ImageClosing, ImageOpening, 0.5, MaskSize)</l>
<l>    mean_image (ImageOpening, ImageMean, MaskSize, 1)</l>
<c>    </c>
<l>else</l>
<l>    gray_closing_rect (ImageReduced, ImageClosing, 0.5, MaskSize)</l>
<l>    gray_opening_rect (ImageClosing, ImageOpening, MaskSize, 0.5)</l>
<l>    mean_image (ImageOpening, ImageMean, 1, MaskSize)</l>
<l>*     if(FoV = 1)       </l>
<l>*         gray_closing_rect (ImageReduced, ImageClosing, 0.5, MaskSize)</l>
<l>*         gray_opening_rect (ImageClosing, ImageOpening, MaskSize, 0.5)</l>
<l>*         mean_image (ImageOpening, ImageMean, 1, MaskSize)</l>
<c>        </c>
<l>*     elseif(FoV = nFoVs)        </l>
<l>*         gray_closing_rect (ImageReduced, ImageClosing, MaskSize, 0.5)</l>
<l>*         gray_opening_rect (ImageClosing, ImageOpening, MaskSize, 0.5)</l>
<l>*         mean_image (ImageOpening, ImageMean, 1, MaskSize)</l>
<l>*     endif</l>
<l>endif</l>
<c></c>
<l>threshold (ImageMean, Region, 0, Contrast)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Inspected CoverLayer Image']</l>
<l>    _FCI_DebugParameters (ImageMean, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<c></c>
<c>*********8888</c>
<l>* opening_rectangle1 (Region, RegionOpening1, MaskSize, MaskSize)</l>
<l>* connection (RegionOpening1, ConnectedRegions3)</l>
<c> </c>
<c></c>
<c></c>
<c></c>
<c>*******</c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>closing_rectangle1 (Region, RegionClosing, MaskWidth+0.5, MaskHeight)</l>
<l>fill_up (RegionClosing, RegionFillUp1)</l>
<l>connection (RegionFillUp1, ConnectedRegions)</l>
<l>region_features (ConnectedRegions, 'height', Height)</l>
<c></c>
<l>select_shape (ConnectedRegions, SelectedRegions, \
              ['max_diameter', 'height'], 'and', [LengthOfCVL,MinCVLHeight], [ImageWidth, ImageHeight])</l>
<l>count_obj (SelectedRegions, Number)</l>
<l>if(Number &lt;= 0)</l>
<l>    return ()</l>
<l>elseif (Number &gt; 1)</l>
<l>    select_shape_std (SelectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>endif</l>
<c></c>
<l>* union1 (SelectedRegions, RegionUnion1)</l>
<l>* opening_rectangle1 (RegionUnion1, RegionOpening, MaskWidth, MaskHeight)</l>
<l>* closing_rectangle1 (RegionOpening, RegionOpening, 1.5, 1.5)</l>
<l>* connection (RegionOpening, ConnectedRegions1)</l>
<l>* region_features (ConnectedRegions1, 'height', Height)</l>
<l>* select_shape (ConnectedRegions1, SelectedRegions1, \
              ['max_diameter','height'], 'and', [LengthOfCVL, MinCVLHeight], [ImageWidth, ImageHeight])</l>
<c></c>
<l>* union1 (SelectedRegions1, RegionUnion)</l>
<l>* closing_rectangle1 (RegionUnion, RegionClosing1, MaskHeight, MaskWidth)</l>
<l>* fill_up (RegionClosing1, RegionFillUp)</l>
<l>* connection (RegionFillUp, ConnectedRegions2)</l>
<l>* select_shape_std (ConnectedRegions2, SelectedRegions2, 'max_area', 70)</l>
<c></c>
<c></c>
<l>area_center (SelectedRegions, Area, Row, Column)</l>
<l>if(Area &gt; 0 and |Area| &gt; 0)</l>
<l>    IsCoverLayer := true</l>
<l>    CoverLayerRegion := SelectedRegions</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Segmented CoverLayer Region']</l>
<l>        _FCI_DebugParameters (InspectImage, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif    </l>
<l>endif  </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_CoverLayer">
<parameters>
<parameter id="CVLCheckRgn"/>
<parameter id="Contrast"/>
<parameter id="CoverLayerRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FoV"/>
<parameter id="InspectImage"/>
<parameter id="IsCoverLayer"/>
<parameter id="IsStepMode"/>
<parameter id="LengthOfCVL"/>
<parameter id="MaskHeight"/>
<parameter id="MaskSize"/>
<parameter id="MaskWidth"/>
<parameter id="MinCVLHeight"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_CoverLayerAlignmentUsingFL">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="FlexLineRegion" base_type="iconic" dimension="0"/>
<par name="CVLRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SelectedFL" base_type="iconic" dimension="0"/>
<par name="SelectedCL" base_type="iconic" dimension="0"/>
<par name="SelectedFLSkeleton" base_type="iconic" dimension="0"/>
<par name="SelectedCLSkeleton" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CVLATolerance" base_type="ctrl" dimension="0"/>
<par name="ConcatMaxDistanceBtnCLFL" base_type="ctrl" dimension="0"/>
<par name="FLIndex" base_type="ctrl" dimension="0"/>
<par name="CVLRgnDir" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="GetDistance" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>******</c>
<l>IsPass := false</l>
<c></c>
<l>select_obj (FlexLineRegion, SelectedFL, FLIndex)</l>
<l>tuple_select (ConcatMaxDistanceBtnCLFL, FLIndex-1, TeachDistanceBtnCLFL)</l>
<c></c>
<l>if(CVLRgnDir = 1)   </l>
<l>    DilationWidth := 0.5</l>
<l>    DilationHeight := 1.8 * TeachDistanceBtnCLFL</l>
<l>else  </l>
<l>    DilationWidth := 1.8 *TeachDistanceBtnCLFL</l>
<l>    DilationHeight := 0.5 </l>
<l>endif</l>
<c></c>
<l>dilation_rectangle1 (SelectedFL, RegionDilation, DilationWidth, DilationHeight)</l>
<l>intersection (RegionDilation, CVLRegion, SelectedCL)</l>
<l>area_center (SelectedCL, Area, Row, Column)</l>
<l>if(Area = 0)</l>
<l>    return()</l>
<l>endif</l>
<l>region_features (SelectedCL, 'width', Width)</l>
<l>region_features (SelectedCL, 'height', Height)</l>
<c></c>
<l>if(CVLRgnDir = 1)   </l>
<l>    OpeningWidth := Width/2</l>
<l>    OpeningHeight := 0.5</l>
<l>else  </l>
<l>    OpeningWidth := 0.5</l>
<l>    OpeningHeight := Height/2</l>
<l>endif</l>
<c></c>
<l>opening_rectangle1 (SelectedCL, RegionOpening, OpeningWidth, OpeningHeight)</l>
<l>connection (RegionOpening, ConnectedRegions)</l>
<l>select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<c></c>
<l>skeleton (SelectedFL, SelectedFLSkeleton)</l>
<l>skeleton (SelectedRegions, SelectedCLSkeleton)</l>
<l>distance_rr_min (SelectedCLSkeleton, SelectedFLSkeleton, GetDistance, Row1, Column1, Row2, Column2)</l>
<c></c>
<l>UpperLimit := TeachDistanceBtnCLFL + CVLATolerance</l>
<l>LowerLimit := TeachDistanceBtnCLFL - CVLATolerance</l>
<l>if (GetDistance &gt; LowerLimit and GetDistance &lt; UpperLimit)</l>
<l>    IsPass := true</l>
<l>else</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="_FCI_Inspect_CoverLayerAlignmentUsingFL">
<parameters>
<parameter id="CVLATolerance"/>
<parameter id="CVLRegion"/>
<parameter id="CVLRgnDir"/>
<parameter id="ConcatMaxDistanceBtnCLFL"/>
<parameter id="FLIndex"/>
<parameter id="FlexLineRegion"/>
<parameter id="GetDistance"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="SelectedCL"/>
<parameter id="SelectedCLSkeleton"/>
<parameter id="SelectedFL"/>
<parameter id="SelectedFLSkeleton"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_CoverLayerAlignmentUsingManualPointer">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="CVLAPointerRegions" base_type="iconic" dimension="0"/>
<par name="CoverLayerRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ObjectSelected" base_type="iconic" dimension="0"/>
<par name="CVLSkeleton" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ToleranceDist" base_type="ctrl" dimension="0"/>
<par name="CVLRgnDir" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassCVLA" base_type="ctrl" dimension="0"/>
<par name="Fraction" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>IsPassCVLA := false</l>
<l>Fraction := 0.0</l>
<c></c>
<c></c>
<c>****Pointer</c>
<l>select_obj (CVLAPointerRegions, ObjectSelected, Index)</l>
<l>region_features (ObjectSelected, 'width', PntWidth)</l>
<l>region_features (ObjectSelected, 'height', PntHeight)</l>
<l>area_center (ObjectSelected, PointerArea, Row1, Column1)</l>
<c>****CVL</c>
<c></c>
<l>if(CVLRgnDir)</l>
<l>    dilation_rectangle1(ObjectSelected, ObjectSelected, 0.5, ToleranceDist)</l>
<l>else</l>
<l>    dilation_rectangle1(ObjectSelected, ObjectSelected, ToleranceDist, 0.5)</l>
<c></c>
<l>endif</l>
<l>intersection (ObjectSelected, CoverLayerRegion, RegionIntersection)</l>
<l>area_center (RegionIntersection, IntersectionArea, Row, Column)</l>
<l>if (IntersectionArea == 0 or |IntersectionArea|&lt;0)</l>
<l>    return()</l>
<l>else</l>
<l>    if(CVLRgnDir)</l>
<l>        opening_rectangle1 (RegionIntersection, RegionOpening, PntWidth/2, 0.5)</l>
<l>    else</l>
<l>        opening_rectangle1 (RegionIntersection, RegionOpening, 0.5, PntHeight/2)</l>
<l>    endif</l>
<l>    skeleton (RegionOpening, CVLSkeleton)</l>
<l>    IsPassCVLA := true</l>
<l>    Fraction := IntersectionArea/(PointerArea/2.0) * 100</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
</body>
<docu id="_FCI_Inspect_CoverLayerAlignmentUsingManualPointer">
<parameters>
<parameter id="CVLAPointerRegions"/>
<parameter id="CVLRgnDir"/>
<parameter id="CVLSkeleton"/>
<parameter id="CoverLayerRegion"/>
<parameter id="Fraction"/>
<parameter id="Image"/>
<parameter id="Index"/>
<parameter id="IsPassCVLA"/>
<parameter id="ObjectSelected"/>
<parameter id="ToleranceDist"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_CoverLayerAlignmentUsingPointer">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="CVLAPointerRegions" base_type="iconic" dimension="0"/>
<par name="CoverLayerRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ObjectSelected" base_type="iconic" dimension="0"/>
<par name="CVLSkeleton" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ToleranceDist" base_type="ctrl" dimension="0"/>
<par name="CVLRgnDir" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassCVLA" base_type="ctrl" dimension="0"/>
<par name="Fraction" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>****Initialization</c>
<l>IsPassCVLA := false</l>
<l>Fraction := 0.0</l>
<c></c>
<c></c>
<c>****Pointer</c>
<l>select_obj (CVLAPointerRegions, ObjectSelected, Index)</l>
<l>region_features (ObjectSelected, 'width', PntWidth)</l>
<l>region_features (ObjectSelected, 'height', PntHeight)</l>
<c></c>
<c>****CVL</c>
<l>dilation_rectangle1 (ObjectSelected, RegionDilation, 100, 100)</l>
<l>intersection (RegionDilation, CoverLayerRegion, RegionIntersection1)</l>
<l>region_features (RegionIntersection1, 'width', Width)</l>
<l>region_features (RegionIntersection1, 'height', Height)</l>
<c></c>
<l>if(CVLRgnDir)</l>
<l>    opening_rectangle1 (RegionIntersection1, RegionOpening, Width/2, 0.5)</l>
<l>    dilation_rectangle1(ObjectSelected, ObjectSelected, 0.5, ToleranceDist)    </l>
<l>else</l>
<l>    opening_rectangle1 (RegionIntersection1, RegionOpening, 0.5, Height/2)</l>
<l>    dilation_rectangle1(ObjectSelected, ObjectSelected, ToleranceDist, 0.5)</l>
<l>endif</l>
<c></c>
<l>skeleton (RegionOpening, CVLSkeleton)</l>
<l>intersection (CVLSkeleton, ObjectSelected, RegionIntersection)</l>
<l>area_center (RegionIntersection, IntersectionArea, Row, Column)</l>
<c></c>
<c>***</c>
<l>area_center (ObjectSelected, PonterArea, Row1, Column1)</l>
<l>if(IntersectionArea&gt;0 and |IntersectionArea| &gt; 0)</l>
<l>    IsPassCVLA := true</l>
<l>    Fraction := IntersectionArea/(PonterArea/2.0) * 100</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>* if(Area&gt;0 and |Area| &gt; 0)</l>
<l>*     difference (ObjectSelected, CVLSkeleton, RegionDifference)</l>
<l>*     connection (RegionDifference, ConnectedRegions)</l>
<l>*     region_features (ConnectedRegions, 'width', GetWidth)</l>
<l>*     region_features (ConnectedRegions, 'height', GetHeight)</l>
<l>*     Number1 := |GetWidth|</l>
<c>    </c>
<l>*     if(CVLRgnDir)</l>
<l>*         if(Number1 = 1)</l>
<l>*             Diff := PntHeight - GetHeight</l>
<l>*             Fraction := Diff / (PntHeight/2.0)</l>
<l>*         else</l>
<l>*             tuple_min (GetHeight, MinHeight)</l>
<l>*             Fraction := (MinHeight+1)/(PntHeight/2.0)</l>
<l>*         endif</l>
<l>*     else</l>
<l>*         if(Number1 = 1)</l>
<l>*             Diff := PntWidth - GetWidth</l>
<l>*             Fraction := Diff / (PntWidth/2.0)</l>
<l>*         else</l>
<l>*             tuple_min (GetWidth, MinWidth)</l>
<l>*             Fraction := (MinWidth+1)/(PntWidth/2.0)</l>
<l>*         endif</l>
<l>*     endif</l>
<c>    </c>
<l>*     Fraction := Fraction * 100.0</l>
<l>*     if (Fraction &gt;= ToleranceDist and Fraction &lt;= 100.0)</l>
<l>*         IsPassCVLA := true</l>
<l>*     else</l>
<l>*         return()</l>
<l>*     endif</l>
<l>* else</l>
<l>*     return()</l>
<l>* endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_CoverLayerAlignmentUsingPointer">
<parameters>
<parameter id="CVLAPointerRegions"/>
<parameter id="CVLRgnDir"/>
<parameter id="CVLSkeleton"/>
<parameter id="CoverLayerRegion"/>
<parameter id="Fraction"/>
<parameter id="Image"/>
<parameter id="Index"/>
<parameter id="IsPassCVLA"/>
<parameter id="ObjectSelected"/>
<parameter id="ToleranceDist"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Cross_Point">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DeviceHorizontalContrast" base_type="ctrl" dimension="0"/>
<par name="DeviceHorizontalDirection" base_type="ctrl" dimension="0"/>
<par name="DeviceVerticalContrast" base_type="ctrl" dimension="0"/>
<par name="DeviceVerticalDirection" base_type="ctrl" dimension="0"/>
<par name="EdgeLocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="EdgeLocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="MaxAngleRotation" base_type="ctrl" dimension="0"/>
<par name="IsSmoothingImage" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPointRow" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPointCol" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>******</c>
<l>IsPass := false</l>
<c></c>
<l>RotationAngle := 0</l>
<l>DeviceTopPointRow := 0</l>
<l>DeviceTopPointCol := 0</l>
<c></c>
<c>* //Side id: 0: Left to right, 1: Top to bottom, 2: Right to left, 3: Bottom to top </c>
<l>LEFT_TO_RIGHT := 0</l>
<l>TOP_TO_BOTTOM := 1</l>
<l>RIGHT_TO_LEFT := 2</l>
<l>BOTTOM_TO_TOP := 3</l>
<l>NONE := 4</l>
<c>******* Debug Initialization</c>
<l>gen_empty_obj(DebugImageOut)</l>
<l>gen_empty_obj(DebugRegionOut)</l>
<l>DebugMessageOut := []</l>
<c></c>
<c>** Create ROI</c>
<l>if(DeviceHorizontalDirection != NONE)</l>
<l>    gen_rectangle1 (HorizontalROI, EdgeLocationTeachRows[0], EdgeLocationTeachCols[0], \
                EdgeLocationTeachRows[1], EdgeLocationTeachCols[1])</l>
<l>endif</l>
<c></c>
<l>if(DeviceVerticalDirection != NONE)</l>
<l>    gen_rectangle1 (VerticalROI, EdgeLocationTeachRows[2], EdgeLocationTeachCols[2], \
                EdgeLocationTeachRows[3], EdgeLocationTeachCols[3])</l>
<l>endif</l>
<c></c>
<c></c>
<l>if(IsStepMode)</l>
<l>    Message:=['Projected Rough Search ROI For Edge Detection']</l>
<l>    if(DeviceHorizontalDirection != NONE)</l>
<l>        _FCI_DebugParameters (Image, HorizontalROI, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                                  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    if(DeviceVerticalDirection != NONE)</l>
<l>        _FCI_DebugParameters (Image, VerticalROI, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                                  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c>    </c>
<c>**** Find The Horizontal Line</c>
<l>if(DeviceHorizontalDirection != NONE)</l>
<l>    reduce_domain (Image, HorizontalROI, ImageReduced)</l>
<l>    if(IsSmoothingImage)</l>
<l>        smooth_image (ImageReduced, ImageReduced, 'deriche2', 0.5)</l>
<l>        emphasize(ImageReduced, ImageReduced, 3, 3, 1.2)</l>
<l>        erosion_circle(VerticalROI, RegionErosion, 3.5)</l>
<l>        reduce_domain (ImageReduced, RegionErosion, ImageReduced)</l>
<l>    endif</l>
<c>    </c>
<l>    GetEdgeLine(ImageReduced, HorizontalROI, DeviceHorizontalDirection, DeviceHorizontalContrast, MaxAngleRotation, HorizontalLinePoints, IsHorizontalLinePass)</l>
<l>else</l>
<c>    ** Create the fake line</c>
<l>    HorizontalLinePoints := [0, 0, 0, 5]</l>
<l>    IsHorizontalLinePass := true</l>
<l>endif</l>
<c></c>
<c>**** Find The Vertical Line</c>
<l>if(DeviceVerticalDirection != NONE)</l>
<l>    reduce_domain (Image, VerticalROI, ImageReduced)</l>
<l>    if(IsSmoothingImage)</l>
<l>        smooth_image (ImageReduced, ImageReduced, 'deriche2', 0.5)</l>
<l>        erosion_circle(VerticalROI, RegionErosion, 3.5)</l>
<l>        reduce_domain (ImageReduced, RegionErosion, ImageReduced)</l>
<l>    endif</l>
<c>    </c>
<l>    GetEdgeLine(ImageReduced, VerticalROI, DeviceVerticalDirection, DeviceVerticalContrast, MaxAngleRotation, VerticallLinePoints, IsVerticalLinePass)</l>
<l>else</l>
<c>    ** Create the fake line</c>
<l>    VerticallLinePoints := [0, 0, 5, 0]</l>
<l>    IsVerticalLinePass := true</l>
<l>endif</l>
<c></c>
<c></c>
<l>if(IsHorizontalLinePass and IsVerticalLinePass)</l>
<l>    intersection_lines(HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3],\
                       VerticallLinePoints[0], VerticallLinePoints[1], VerticallLinePoints[2], VerticallLinePoints[3],\
                       DeviceTopPointRow, DeviceTopPointCol, IsOverlapping)</l>
<c>    </c>
<l>    angle_ll(HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3],\
                       VerticallLinePoints[0], VerticallLinePoints[1], VerticallLinePoints[2], VerticallLinePoints[3],\
                       RotationAngle)</l>
<l>    RotationAngle := abs(RotationAngle)</l>
<l>    IsPass := true</l>
<l>endif</l>
<c></c>
<c></c>
<l>if(IsStepMode)</l>
<l>    if(IsHorizontalLinePass and DeviceHorizontalDirection != NONE)</l>
<l>        Message:=['Found The Horizontal Device Lines']</l>
<l>        gen_region_line (HorizontalLineRegionDebug, HorizontalLinePoints[0], HorizontalLinePoints[1], HorizontalLinePoints[2], HorizontalLinePoints[3])</l>
<l>        _FCI_DebugParameters (Image, HorizontalLineRegionDebug, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                                  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<c>    </c>
<l>    if(IsVerticalLinePass and DeviceVerticalDirection != NONE)</l>
<l>        Message:=['Found The Vertical Device Lines']</l>
<l>         gen_region_line (VerticalLineRegionDebug, VerticallLinePoints[0], VerticallLinePoints[1], VerticallLinePoints[2], VerticallLinePoints[3])</l>
<l>        _FCI_DebugParameters (Image, VerticalLineRegionDebug, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                                  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    </c>
<l>    if(IsPass)</l>
<l>        Message:=['Found The Cross Reference Point']</l>
<l>        gen_cross_contour_xld (TopRefCross, DeviceTopPointRow, DeviceTopPointCol, 100, 0)</l>
<l>        get_contour_xld (TopRefCross, TopRefCrossRow, TopRefCrossCol)</l>
<l>        gen_region_polygon (TopRefCrossRegion, TopRefCrossRow, TopRefCrossCol)</l>
<l>         _FCI_DebugParameters (Image, TopRefCrossRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, \
                                  Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspect_Cross_Point">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceHorizontalContrast"/>
<parameter id="DeviceHorizontalDirection"/>
<parameter id="DeviceTopPointCol"/>
<parameter id="DeviceTopPointRow"/>
<parameter id="DeviceVerticalContrast"/>
<parameter id="DeviceVerticalDirection"/>
<parameter id="EdgeLocationTeachCols"/>
<parameter id="EdgeLocationTeachRows"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsSmoothingImage"/>
<parameter id="IsStepMode"/>
<parameter id="MaxAngleRotation"/>
<parameter id="RotationAngle"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_DeviceLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
<par name="MatchModelRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsDatumTeach" base_type="ctrl" dimension="0"/>
<par name="IsDeviceLocationTeach" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="IsSobelFlag" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="RefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="RefPointRow" base_type="ctrl" dimension="0"/>
<par name="RefPointColumn" base_type="ctrl" dimension="0"/>
<par name="EdgeRefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="EdgeRefPointRow" base_type="ctrl" dimension="0"/>
<par name="EdgeRefPointColumn" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
<par name="ReferencePointType" base_type="ctrl" dimension="0"/>
<par name="IsDeviceEdgeDetection" base_type="ctrl" dimension="0"/>
<par name="DeviceHorizontalContrast" base_type="ctrl" dimension="0"/>
<par name="DeviceHorizontalDirection" base_type="ctrl" dimension="0"/>
<par name="DeviceVerticalContrast" base_type="ctrl" dimension="0"/>
<par name="DeviceVerticalDirection" base_type="ctrl" dimension="0"/>
<par name="EdgeLocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="EdgeLocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="IsSmoothingImage" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="IsFindDatum" base_type="ctrl" dimension="0"/>
<par name="RotationAngleDev" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="MatchModelScore" base_type="ctrl" dimension="0"/>
<par name="TopRefRotationAngleDev" base_type="ctrl" dimension="0"/>
<par name="TopRefShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="TopRefShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***</c>
<l>IsPass := false</l>
<l>IsFindDatum := false</l>
<l>gen_empty_region (DeviceLocation)</l>
<l>gen_empty_region (MatchModelRegion)</l>
<c></c>
<l>MatchModelScore := 0</l>
<l>RotationAngleDev := []</l>
<l>ShiftAlongRow := []</l>
<l>ShiftAlongCol := []</l>
<c></c>
<l>TopRefRotationAngleDev := []</l>
<l>TopRefShiftAlongRow := []</l>
<l>TopRefShiftAlongCol := []</l>
<c></c>
<c>******* Debug Initialization</c>
<l>gen_empty_obj(DebugImageOut)</l>
<l>gen_empty_obj(DebugRegionOut)</l>
<l>DebugMessageOut := []</l>
<c></c>
<c>*****</c>
<l>if(IsDatumTeach and IsDeviceLocationTeach)</l>
<l>    gen_empty_obj(DebugImageDeviceLocationOut)</l>
<l>    gen_empty_obj(DebugRegionDeviceLocationOut)</l>
<l>    DebugMessageDeviceLocationOut := []</l>
<c>    </c>
<c>    ** Find cross reference point to get the rough estimation of the datum search region</c>
<l>    if(NoOfLocationTeachRegs &gt; 0 and not IsDeviceEdgeDetection)</l>
<l>        _FCI_DeviceLocation_WithOutUniquePattern (Image, DeviceLocation, DebugImageDeviceLocationOut, DebugRegionDeviceLocationOut, IsStepMode, IsSobelFlag, DeviceWidth, DeviceHeight, MinDeviceContrast, LocationTeachRows, LocationTeachCols, EdgeRefRotationAngle, EdgeRefPointRow, EdgeRefPointColumn, MaskSize, FoV, nFoVs, Track, ReferencePointType, IsPass, TopRefRotationAngleDev, TopRefShiftAlongRow, TopRefShiftAlongCol, DebugMessageDeviceLocationOut)</l>
<l>    else</l>
<l>        _FCI_Inspect_Cross_Point (Image, DebugImageDeviceLocationOut, DebugRegionDeviceLocationOut, DeviceHorizontalContrast, DeviceHorizontalDirection, DeviceVerticalContrast, DeviceVerticalDirection, EdgeLocationTeachRows, EdgeLocationTeachCols, MaxRotationAngle, IsSmoothingImage, IsStepMode, EdgeRotationAngle, CrossPointRow, CrossPointCol, DebugMessageDeviceLocationOut, IsPass)</l>
<c>        </c>
<l>        TopRefRotationAngleDev := EdgeRefRotationAngle - EdgeRotationAngle</l>
<l>        TopRefShiftAlongRow := EdgeRefPointRow - CrossPointRow</l>
<l>        TopRefShiftAlongCol := EdgeRefPointColumn - CrossPointCol</l>
<c>        </c>
<c>        ** No need to extract the Device Location by Blob Detection if we use the Edge Detection To Find Cross Ref Point</c>
<c>        *Turn Off "_FCI_Exact_DeviceLocation" inside the _FCI_DeviceLocation_WithUniquePattern procedure</c>
<l>        IsDeviceLocationTeach := false</l>
<l>    endif</l>
<c>     </c>
<l>    if(IsPass)</l>
<l>        hom_mat2d_identity (HomMat2DIdentity)</l>
<l>        hom_mat2d_translate (HomMat2DIdentity, -TopRefShiftAlongRow, -TopRefShiftAlongCol, HomMat2DTranslate)</l>
<l>        hom_mat2d_rotate (HomMat2DTranslate, -TopRefRotationAngleDev, (LocationTeachRows[0] + LocationTeachRows[1])/2, (LocationTeachCols[0] + LocationTeachCols[1])/2, HomMat2DRotate)</l>
<c>        </c>
<l>        affine_trans_point_2d (HomMat2DTranslate, PatternTeachRows, PatternTeachCols, PatternTeachRowsFollowTopRef, PatternTeachColsFollowTopRef)</l>
<c>        </c>
<l>        _FCI_DeviceLocation_WithUniquePattern (Image, DeviceLocation, RoughDeviceLocation, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, IsDeviceLocationTeach, IsSobelFlag, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, ModelID, RefRotationAngle, RefPointRow, RefPointColumn, DeviceWidth, DeviceHeight, MinDeviceContrast, PatternTeachRowsFollowTopRef, PatternTeachColsFollowTopRef, LocationTeachRows, LocationTeachCols, MaskSize, Track, IsPass, IsFindDatum, RotationAngleDev, ShiftAlongRow, ShiftAlongCol, MatchModelScore, DebugMessageOut)</l>
<l>    endif</l>
<c>     </c>
<c>    ** If can not find the datum based on the device/edge location, then try again with the datum teach region</c>
<l>    if(not IsFindDatum)</l>
<l>        _FCI_DeviceLocation_WithUniquePattern (Image, DeviceLocation, RoughDeviceLocation, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, IsDeviceLocationTeach, IsSobelFlag, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, ModelID, RefRotationAngle, RefPointRow, RefPointColumn, DeviceWidth, DeviceHeight, MinDeviceContrast, PatternTeachRows, PatternTeachCols, LocationTeachRows, LocationTeachCols, MaskSize, Track, IsPass, IsFindDatum, RotationAngleDev, ShiftAlongRow, ShiftAlongCol, MatchModelScore, DebugMessageOut)</l>
<l>    endif</l>
<c>        </c>
<c>        </c>
<l>     if(IsStepMode)</l>
<l>         concat_obj (DebugImageDeviceLocationOut, DebugImageOut, DebugImageOut)</l>
<l>         concat_obj (DebugRegionDeviceLocationOut, DebugRegionOut, DebugRegionOut)</l>
<l>         tuple_concat (DebugMessageDeviceLocationOut, DebugMessageOut, DebugMessageOut)</l>
<l>     endif</l>
<c>     </c>
<c>     </c>
<l>elseif(IsDatumTeach)  </l>
<l>    _FCI_DeviceLocation_WithUniquePattern (Image, DeviceLocation, RoughDeviceLocation, MatchModelRegion, DebugImageOut, DebugRegionOut, IsStepMode, IsDeviceLocationTeach, IsSobelFlag, PatternSearchAreaAlongX, PatternSearchAreaAlongY, MaxRotationAngle, MinAcceptanceScore, ModelID, RefRotationAngle, RefPointRow, RefPointColumn, DeviceWidth, DeviceHeight, MinDeviceContrast, PatternTeachRows, PatternTeachCols, LocationTeachRows, LocationTeachCols, MaskSize, Track, IsPass, IsFindDatum, RotationAngleDev, ShiftAlongRow, ShiftAlongCol, MatchModelScore, DebugMessageOut)</l>
<c>    </c>
<l>else    </l>
<l>    if(NoOfLocationTeachRegs &gt; 0 and not IsDeviceEdgeDetection)</l>
<l>        _FCI_DeviceLocation_WithOutUniquePattern (Image, DeviceLocation, DebugImageOut, DebugRegionOut, IsStepMode, IsSobelFlag, DeviceWidth, DeviceHeight, MinDeviceContrast, LocationTeachRows, LocationTeachCols, EdgeRefRotationAngle, EdgeRefPointRow, EdgeRefPointColumn, MaskSize, FoV, nFoVs, Track, ReferencePointType, IsPass, RotationAngleDev, ShiftAlongRow, ShiftAlongCol, DebugMessageOut)</l>
<l>    else</l>
<l>        _FCI_Inspect_Cross_Point (Image, DebugImageOut, DebugRegionOut, DeviceHorizontalContrast, DeviceHorizontalDirection, DeviceVerticalContrast, DeviceVerticalDirection, EdgeLocationTeachRows, EdgeLocationTeachCols, MaxRotationAngle, IsSmoothingImage, IsStepMode, EdgeRotationAngle, CrossPointRow, CrossPointCol, DebugMessageOut, IsPass)</l>
<c>        </c>
<l>        TopRefRotationAngleDev := EdgeRefRotationAngle - EdgeRotationAngle</l>
<l>        TopRefShiftAlongRow := EdgeRefPointRow - CrossPointRow</l>
<l>        TopRefShiftAlongCol := EdgeRefPointColumn - CrossPointCol</l>
<c>        </c>
<l>        RotationAngleDev := TopRefRotationAngleDev</l>
<l>        ShiftAlongRow := TopRefShiftAlongRow</l>
<l>        ShiftAlongCol := TopRefShiftAlongCol</l>
<c>        </c>
<c>        *Create pseudo device location</c>
<l>        gen_rectangle1( DeviceLocation, CrossPointRow, CrossPointCol, CrossPointRow + DeviceHeight, CrossPointCol + DeviceWidth)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>*** Validation the output</c>
<l>if(|MatchModelScore| = 0)</l>
<l>    MatchModelScore := 0</l>
<l>endif</l>
<l>if(|RotationAngleDev| = 0)</l>
<l>    RotationAngleDev := 0</l>
<l>endif</l>
<l>if(|ShiftAlongRow| = 0)</l>
<l>    ShiftAlongRow := 0</l>
<l>endif</l>
<l>if(|ShiftAlongCol| = 0)</l>
<l>    ShiftAlongCol := 0</l>
<l>endif</l>
<c></c>
<l>if(|TopRefRotationAngleDev| = 0)</l>
<l>    TopRefRotationAngleDev := 0</l>
<l>endif</l>
<l>if(|TopRefShiftAlongRow| = 0)</l>
<l>    TopRefShiftAlongRow := 0</l>
<l>endif</l>
<l>if(|TopRefShiftAlongCol| = 0)</l>
<l>    TopRefShiftAlongCol := 0</l>
<l>endif</l>
<c></c>
<l>area_center (DeviceLocation, DeviceLocationArea, Dummy, Dummy)</l>
<l>if(|DeviceLocationArea| &gt; 0)</l>
<l>    tuple_max(DeviceLocationArea, DeviceLocationArea)</l>
<l>else</l>
<l>    DeviceLocationArea := 0</l>
<l>endif</l>
<c></c>
<l>if(DeviceLocationArea = 0 and IsPass)</l>
<l>    if(|LocationTeachRows| &gt;= 2 and (IsDatumTeach or not IsDeviceEdgeDetection))</l>
<l>        gen_rectangle1 (DeviceLocation, LocationTeachRows[0], LocationTeachCols[0], LocationTeachRows[1], LocationTeachCols[1])</l>
<l>    else</l>
<l>        gen_rectangle1(DeviceLocation, 0, 0, 0, 0)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_DeviceLocation">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceHeight"/>
<parameter id="DeviceHorizontalContrast"/>
<parameter id="DeviceHorizontalDirection"/>
<parameter id="DeviceLocation"/>
<parameter id="DeviceVerticalContrast"/>
<parameter id="DeviceVerticalDirection"/>
<parameter id="DeviceWidth"/>
<parameter id="EdgeLocationTeachCols"/>
<parameter id="EdgeLocationTeachRows"/>
<parameter id="EdgeRefPointColumn"/>
<parameter id="EdgeRefPointRow"/>
<parameter id="EdgeRefRotationAngle"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="IsDatumTeach"/>
<parameter id="IsDeviceEdgeDetection"/>
<parameter id="IsDeviceLocationTeach"/>
<parameter id="IsFindDatum"/>
<parameter id="IsPass"/>
<parameter id="IsSmoothingImage"/>
<parameter id="IsSobelFlag"/>
<parameter id="IsStepMode"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelRegion"/>
<parameter id="MatchModelScore"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelID"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
<parameter id="RefPointColumn"/>
<parameter id="RefPointRow"/>
<parameter id="RefRotationAngle"/>
<parameter id="ReferencePointType"/>
<parameter id="RotationAngleDev"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
<parameter id="TopRefRotationAngleDev"/>
<parameter id="TopRefShiftAlongCol"/>
<parameter id="TopRefShiftAlongRow"/>
<parameter id="Track"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_EdgeLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsSobelFlag" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="Track" base_type="ctrl" dimension="0"/>
<par name="ReferencePointType" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPointRow" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPointCol" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>******</c>
<l>gen_empty_obj(DeviceLocation)</l>
<c></c>
<l>RotationAngle := 0</l>
<l>DeviceTopPointRow := 0</l>
<l>DeviceTopPointCol := 0</l>
<c></c>
<c>****</c>
<l>gen_rectangle1 (GrossDieLocation, LocationTeachRows[0], LocationTeachCols[0], LocationTeachRows[1], LocationTeachCols[1])</l>
<l>region_features (GrossDieLocation, 'area', DeviceArea)</l>
<l>get_image_size(Image, ImageWidth, ImageHeight)</l>
<l>smallest_rectangle2 (GrossDieLocation, Row2, Column2, Phi1, Length11, Length21)</l>
<l>gen_rectangle2(Rectangle, Row2, Column2, Phi1, ImageWidth, Length21) </l>
<c></c>
<c>**** Reduced Image</c>
<l>reduce_domain(Image, Rectangle, ImageReduced)    </l>
<l>if (IsSobelFlag)</l>
<l>    sobel_amp(ImageReduced, ImageReduced, 'sum_abs', 3)   </l>
<l>endif  </l>
<c></c>
<l>if(MinDeviceContrast=0)</l>
<l>    min_max_gray (Rectangle, ImageReduced, 0, Min, Max, Range)</l>
<l>    threshold (ImageReduced, SegmentRegion, (Max-Min)/2, Max)</l>
<l>else</l>
<l>    threshold (ImageReduced, SegmentRegion, MinDeviceContrast, 255)</l>
<l>endif </l>
<l>fill_up (SegmentRegion, RegionFillUp)</l>
<l>connection (RegionFillUp, ConnectedRegions)    </l>
<l>gen_empty_obj (DeviceEmptyObject)</l>
<c></c>
<l>if(Track = 1 or Track = 2)</l>
<c>    </c>
<c>    ********Select_Small_Regions</c>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['width','height'], 'and', [0,0], [DeviceWidth/10, DeviceHeight/10])</l>
<l>    union1 (SelectedRegions, SmallAreaRegions)</l>
<l>    difference (SegmentRegion, SmallAreaRegions, RegionDifference)</l>
<l>    closing_circle (RegionDifference, RegionClosing1, 3.5)</l>
<l>    fill_up (RegionClosing1, RegionFillUp)</l>
<c>      </c>
<c>    ******* Select Edge Location</c>
<l>    connection (RegionFillUp, ConnectedRegions1)</l>
<l>    MinSelectHeight := DeviceHeight/5</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions, ['width','height'], 'and', \
                  [DeviceWidth,MinSelectHeight], [ImageWidth, ImageHeight])</l>
<l>    count_obj (SelectedRegions, Number)</l>
<c>    </c>
<l>    if(Number &gt; 0)</l>
<l>        area_center (SelectedRegions, TestArea, Dummy, Dummy)</l>
<l>        tuple_max (TestArea, MaxTestArea)</l>
<l>        AreaFraction := MaxTestArea / (DeviceArea*1.0)</l>
<c>        </c>
<l>        if(AreaFraction &gt; 0.7)</l>
<l>            select_shape_std (SelectedRegions, SelectedRegions3, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions3, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<l>        else</l>
<c>            </c>
<l>            union1 (SelectedRegions, RegionUnion)</l>
<l>            closing_rectangle1 (RegionUnion, RegionClosing2, MaskSize, MaskSize)</l>
<l>            connection (RegionClosing2, ConnectedRegions2)</l>
<l>            select_shape (ConnectedRegions2, SelectedRegions2, ['width', 'height'], 'and', [DeviceWidth, DeviceHeight], [ImageWidth, ImageHeight])</l>
<l>            select_shape_std(SelectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<l>            closing_rectangle1(SelectedRegions1, RegionClosing, MaskSize, MaskSize)</l>
<l>            concat_obj (DeviceEmptyObject, RegionClosing, DeviceEmptyObject)</l>
<c>            </c>
<l>        endif </l>
<l>    endif</l>
<l>else</l>
<c>    </c>
<l>    intensity (ConnectedRegions, ImageReduced, Mean, Deviation)</l>
<l>    MaxGrayMean := max(Mean)</l>
<l>    select_gray (ConnectedRegions, ImageReduced, DeviceEmptyObject, 'mean', 'and', 0.95*MaxGrayMean, MaxGrayMean)</l>
<l>    count_obj (DeviceEmptyObject, Number2)</l>
<l>    if(Number2&gt;1)</l>
<l>        select_shape_std (DeviceEmptyObject, DeviceEmptyObject, 'max_area', 70)</l>
<l>    endif </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>area_center(DeviceEmptyObject, Area, Dummy, Dummy)</l>
<l>if(Area&gt;0 and |Area|&gt;0)</l>
<l>    elliptic_axis (DeviceEmptyObject, Dummy, Dummy, Phi)</l>
<l>    RotationAngle := Phi</l>
<l>    concat_obj (DeviceLocation, DeviceEmptyObject, DeviceLocation)</l>
<l>    TopReferencePoints (Image, DeviceLocation, FoV, nFoVs, ReferencePointType, DeviceTopPointRow, DeviceTopPointCol, DeviceAngle, Device2DCenter, DeviceSize)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspect_EdgeLocation">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceLocation"/>
<parameter id="DeviceTopPointCol"/>
<parameter id="DeviceTopPointRow"/>
<parameter id="DeviceWidth"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="IsSobelFlag"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MinDeviceContrast"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="ReferencePointType"/>
<parameter id="RotationAngle"/>
<parameter id="Track"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Encap_Crack">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="FinalCrackRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinDefectContrast" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AllECRDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllECRDefectMinLength" base_type="ctrl" dimension="0"/>
<par name="AllECRDefectMinSquareSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> ***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (FinalCrackRegion)</l>
<l>DebugMessageOut :=  []</l>
<l>IsPass := true</l>
<c></c>
<c>** Segmentation image based on square size of the defect</c>
<l>if(MinSquareSize &gt; 3)</l>
<l>    deviation_image (InspectImage, ImageDeviation, MinSquareSize, MinSquareSize)</l>
<l>else</l>
<l>    deviation_image (InspectImage, ImageDeviation, 3, 3)</l>
<l>endif</l>
<c></c>
<l>* emphasize( ImageDeviation1, ImageEmphasize, 7, 7, 1)</l>
<l>if (IsStepMode)</l>
<l>    Message := ['Segmenting the Deviation Image Based On Defect Square Size']</l>
<l>    _FCI_DebugParameters (ImageDeviation, DebugRegionOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut,  Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif     </l>
<c></c>
<l>threshold (ImageDeviation, CandidateDefectRegion, MinDefectContrast, 255)</l>
<l>connection (CandidateDefectRegion, ConnectedRegions)</l>
<l>fill_up (ConnectedRegions, RegionFillUp)</l>
<c></c>
<c>** Select crack shape based on size and 'compactness' factor (This factor value of a circle is 1. If the region is long or has holes C is larger than 1.)</c>
<l>MinCompactness := 1.1</l>
<l>select_shape (RegionFillUp, CrackRegion, ['area', 'compactness'], 'and', \
              [MinSize, MinCompactness], [99999, 99999])</l>
<c></c>
<l>count_obj (CrackRegion, CrackRegionCount)</l>
<l>if(CrackRegionCount &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['All Possible Encap Crack Shape Based On Min Size']</l>
<l>        _FCI_DebugParameters (InspectImage, CrackRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif   </l>
<l>endif</l>
<c></c>
<c>** Select crack defect based on length and square size</c>
<l>connection (CrackRegion, ConnectedCrackRegion)</l>
<l>select_shape (ConnectedCrackRegion, FinalCrackRegion, ['max_diameter','width','height'], \
              'and', [MinLength, MinSquareSize, MinSquareSize], [99999, 99999, 99999])</l>
<c> </c>
<c>** Expand step by step for end-user                          </c>
<l>if(IsStepMode)</l>
<l>    select_shape (ConnectedCrackRegion, SelectedCrackRegion, ['width','height'], \
                  'and', [MinSquareSize, MinSquareSize], [99999, 99999])</l>
<l>    count_obj(SelectedCrackRegion, SelectedCrackRegionCount)</l>
<l>    if(SelectedCrackRegionCount &gt; 0)</l>
<l>        Message:=['Crack Defect Region Based On Min Square Size']</l>
<l>        _FCI_DebugParameters (InspectImage, SelectedCrackRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedCrackRegion, SelectedCrackRegion, 'max_diameter', \
                  'and', MinLength, 99999)</l>
<l>        count_obj(SelectedCrackRegion, SelectedCrackRegionCount)</l>
<l>        if(SelectedCrackRegionCount &gt; 0)</l>
<l>              Message:=['Crack Defect Region Based On Min Length']</l>
<l>              _FCI_DebugParameters (InspectImage, SelectedCrackRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>count_obj (FinalCrackRegion, FinalCrackRegionCount)</l>
<l>if(FinalCrackRegionCount &gt; 0)</l>
<l>    IsPass := false</l>
<c>    </c>
<l>    region_features (FinalCrackRegion, ['area','max_diameter','width','height'], Value)</l>
<l>    AllECRDefectMinSize             := Value[0]</l>
<l>    AllECRDefectMinLength            := Value[1]</l>
<l>    AllECRDefectMinSquareSize        := min2(Value[2],Value[3])</l>
<c></c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Finale Crack Defect Region Based On Square Size And Length']</l>
<l>        _FCI_DebugParameters (InspectImage, FinalCrackRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif    </l>
<l>endif </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_Encap_Crack">
<parameters>
<parameter id="AllECRDefectMinLength"/>
<parameter id="AllECRDefectMinSize"/>
<parameter id="AllECRDefectMinSquareSize"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FinalCrackRegion"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinDefectContrast"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_EncapDefect_ExceptInsufficientExcess">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>******Defects</c>
<c>***Wicking</c>
<l>offset := 50</l>
<l>WickingRadius := 60.5</l>
<l>MinGrayMean := 25</l>
<l>MinWickWidth := 40</l>
<c></c>
<l>gen_empty_obj (WickEmptyObject)</l>
<l>IsPass := true</l>
<c></c>
<l>inner_rectangle1 (EncapLocation, EncapRow1, EncapColumn1, EncapRow2, EncapColumn2)</l>
<l>gen_rectangle1 (Rectangle, EncapRow1, EncapColumn1-offset, EncapRow2, EncapColumn2+offset)</l>
<l>difference (EncapLocation, Rectangle, RegionDifference)</l>
<l>connection (RegionDifference, ConnectedRegions)</l>
<l>count_obj (ConnectedRegions, Number1)</l>
<l>for WickIndex := 1 to Number1 by 1</l>
<l>    select_obj (ConnectedRegions, ObjectSelected, WickIndex)</l>
<l>    closing_circle (ObjectSelected, RegionClosing, WickingRadius)</l>
<l>    difference (RegionClosing, ObjectSelected, RegionDifference1)</l>
<l>    opening_circle (RegionDifference1, RegionOpening, 5.5)</l>
<c>    </c>
<l>    connection (RegionOpening, ConnectedRegions1)</l>
<l>    area_center (ConnectedRegions1, Area, Row, Column)</l>
<l>    if(Area &gt; 0 and |Area| &gt; 0)</l>
<l>        select_shape (ConnectedRegions1, SelectedRegions, 'width', 'and', 0.5*MinWickWidth, 1.5*MinWickWidth)</l>
<l>        connection (SelectedRegions, ConnectedRegions2)</l>
<l>        count_obj (ConnectedRegions2, Number)</l>
<l>        if(Number &gt; 0)</l>
<l>            for i := 1 to Number by 1</l>
<l>                select_obj (ConnectedRegions1, ObjectSelected1, i)</l>
<l>                intensity (ObjectSelected1, Image, Mean, Deviation)</l>
<l>                if(Mean &lt; MinGrayMean)</l>
<l>                    concat_obj (WickEmptyObject, ObjectSelected1, WickEmptyObject)</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<l>    else</l>
<l>        IsPass := false</l>
<l>        return()</l>
<l>    endif</l>
<l>endfor</l>
<l>connection (WickEmptyObject, ConnectedRegions3)</l>
<l>count_obj (WickEmptyObject, Number2)</l>
<l>if(Number2 # 2)</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>*******Encap Blow Hole</c>
<c></c>
<c>*** select dark region Blow hole (hollow)</c>
<l>reduce_domain (Image, EncapLocation, EncapImage)</l>
<l>highpass_image (EncapImage, Highpass, 9, 9)</l>
<l>threshold (Highpass, Region, 0, 105)</l>
<l>closing_circle (Region, RegionClosing, 3.5)</l>
<l>fill_up (RegionClosing, RegionFillUp1)</l>
<l>opening_circle (RegionFillUp1, RegionOpening, 3.5)</l>
<c></c>
<l>connection (RegionOpening, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, ['area','circularity'], 'and', [60,0.8], [99999,1])</l>
<c></c>
<l>gen_empty_obj (EmptyObject)</l>
<l>count_obj (SelectedRegions, Number)</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (SelectedRegions, ObjectSelected, Index)</l>
<l>    dilation_circle (ObjectSelected, RegionDilation, 2.5)</l>
<l>    erosion_circle (ObjectSelected, RegionErosion, 4.5)</l>
<c>    </c>
<l>    difference (RegionDilation, RegionErosion, RegionDifference)</l>
<l>    reduce_domain (EncapImage, RegionDifference, ImageReduced3)</l>
<l>    intensity (RegionDifference, ImageReduced3, Mean, Deviation)</l>
<l>    if(Mean &lt; 90)</l>
<l>        concat_obj (EmptyObject, ObjectSelected, EmptyObject)</l>
<l>    endif</l>
<l>endfor</l>
<l>area_center (EmptyObject, BlowHoleArea, Dummy, Dummy)</l>
<l>if(BlowHoleArea&gt;0 and |BlowHoleArea|&gt;0)</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>*******</c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_EncapDefect_ExceptInsufficientExcess">
<parameters>
<parameter id="EncapLocation"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_EncapDefects">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
<par name="EncapInspectRegion" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="IsPass4Insufficient" base_type="ctrl" dimension="0"/>
<par name="IsPass4Excess" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>****Encap Flag Initialization</c>
<l>IsPass := true</l>
<l>IsPass4Insufficient := true</l>
<l>IsPass4Excess := true</l>
<c></c>
<c>***</c>
<c>****Outer Rectangle</c>
<l>region_features (EncapInspectRegion, 'height', EncapRectHeight)</l>
<l>if(|EncapRectHeight|=0)</l>
<l>    return()</l>
<l>endif</l>
<l>tuple_greater_equal_elem (EncapRectHeight, max(EncapRectHeight), Greatereq)</l>
<l>tuple_find (Greatereq, 1, OuterIndex)</l>
<l>select_obj (EncapInspectRegion, OuterRectangle, OuterIndex+1)</l>
<c></c>
<c>****Inner Rectangle</c>
<l>tuple_find (Greatereq, 0, InnerIndex)</l>
<l>if(InnerIndex # -1)</l>
<l>    select_obj (EncapInspectRegion, InnerRectangle, InnerIndex+1)</l>
<l>endif</l>
<c></c>
<c>*****</c>
<l>smallest_rectangle2 (OuterRectangle, Dummy, Dummy, OuterPhi, OuterPriLength, OuterPriLength)</l>
<c></c>
<l>smallest_rectangle2 (InnerRectangle, InnerRow, InnerColumn, InnerPhi, InnerPriLength, InnerSecLength)</l>
<l>gen_rectangle2 (Rectangle, InnerRow, InnerColumn, InnerPhi, InnerPriLength, 2*OuterPriLength)</l>
<l>intersection (Rectangle, OuterRectangle, InnerRectangle)</l>
<c></c>
<c>***Check for Encap Insufficient</c>
<c>****Step 1</c>
<l>difference (EncapLocation, InnerRectangle, RegionDiffBetweenEncapAndInner)</l>
<l>area_center (RegionDiffBetweenEncapAndInner, Area, Dummy, Dummy)</l>
<l>if(Area = 0 or |Area| = 0)</l>
<l>    IsPass4Insufficient := false</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>***Step 2</c>
<l>difference (OuterRectangle, InnerRectangle, RegionDiffBetweenOuterAndInner)</l>
<l>opening_circle (RegionDiffBetweenOuterAndInner, RegionOpening, 5.5)</l>
<l>connection (RegionOpening, ConnectedRegions1)</l>
<l>count_obj (ConnectedRegions1, Number)</l>
<l>if(Number &lt;= 1)</l>
<l>    IsPass4Insufficient := false</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>for i := 1 to Number by 1 </l>
<l>    select_obj (ConnectedRegions1, ObjectSelected, i)</l>
<l>    intersection (ObjectSelected, EncapLocation, RegionIntersection)</l>
<l>    area_center (RegionIntersection, Area1, Dummy, Dummy)</l>
<l>    if(Area1 = 0 or |Area1| = 0)</l>
<l>        IsPass4Insufficient := false</l>
<l>        IsPass := false</l>
<l>        return()</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<c>******Check for Encap Excess</c>
<c>****Step 1</c>
<l>difference (EncapLocation, OuterRectangle, RegionDiffBetweenEncapAndOuter)</l>
<l>opening_circle (RegionDiffBetweenEncapAndOuter, RegionOpening1, 1.5)</l>
<l>area_center (RegionOpening1, Area2, Dummy, Dummy)</l>
<l>if(Area2 &gt;0 and |Area2| &gt; 0)</l>
<l>    IsPass4Excess := false</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspect_EncapDefects">
<parameters>
<parameter id="EncapInspectRegion"/>
<parameter id="EncapLocation"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsPass4Excess"/>
<parameter id="IsPass4Insufficient"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_EncapLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="DeviceLocation" base_type="iconic" dimension="0"/>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="EncapLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="WireColor" base_type="ctrl" dimension="0"/>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEncapContrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPassEncap" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****Initialization</c>
<l>IsPassEncap := false</l>
<l>gen_empty_obj (EncapLocation)</l>
<c></c>
<c>***</c>
<l>reduce_domain (Image, PVIRegion, ImageReduced)</l>
<l>difference (PVIRegion, DeviceLocation, RegionDifference1)</l>
<l>reduce_domain (ImageReduced, RegionDifference1, ImageReduced1)</l>
<c></c>
<l>if(WireColor)</l>
<c>    </c>
<l>    threshold (ImageReduced1, Regions, MinEncapContrast, MaxEncapContrast)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=[' Initial Segmentation of the Encap Region']</l>
<l>        _FCI_DebugParameters (ImageReduced1, Regions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)  </l>
<l>    endif</l>
<c>    </c>
<l>    opening_circle (Regions, RegionsOpening, 2.5)</l>
<l>    fill_up (RegionsOpening, RegionFillUp)</l>
<l>    opening_circle (RegionFillUp, RegionOpening1, 3.5)</l>
<l>    fill_up (RegionOpening1, RegionFillUp1)</l>
<l>    opening_circle (RegionFillUp1, RegionOpening2, 9.5)</l>
<l>    connection (RegionOpening2, ConnectedRegions)</l>
<c>    </c>
<l>    region_features (ConnectedRegions, 'width', WidthOfEncap)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions3, 'width', 'and', 0.5*max(WidthOfEncap), max(WidthOfEncap))</l>
<l>    union1 (SelectedRegions3, RegionUnion)</l>
<l>    closing_circle (RegionUnion, RegionClosing, 5.5)</l>
<l>    connection (RegionClosing, ConnectedRegions2)    </l>
<l>    select_shape_std (ConnectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<c></c>
<l>else</l>
<c></c>
<l>    threshold (ImageReduced1, Region, MinEncapContrast, MaxEncapContrast)</l>
<l>    fill_up (Region, RegionFillUp)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Initial Segmentation of the Encap Region']</l>
<l>        _FCI_DebugParameters (ImageReduced1, RegionFillUp, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>    endif</l>
<c>    </c>
<l>    connection (RegionFillUp, ConnectedRegions)</l>
<l>    select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>    opening_circle (SelectedRegions, RegionOpening3, 5.5)</l>
<l>    connection (RegionOpening3, ConnectedRegions1)</l>
<c>   </c>
<l>    region_features (ConnectedRegions1, 'width', WidthOfEncap)</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions3, 'width', 'and', 0.5*max(WidthOfEncap), max(WidthOfEncap))</l>
<l>    union1 (SelectedRegions3, RegionUnion)</l>
<l>    closing_circle (RegionUnion, RegionClosing, 5.5)</l>
<l>    connection (RegionClosing, ConnectedRegions2)    </l>
<l>    select_shape_std (ConnectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<c></c>
<l>endif</l>
<c></c>
<l>area_center (SelectedRegions1, EncapArea, Dummy, Dummy)</l>
<l>if (EncapArea&gt;0 and |EncapArea|&gt;0)</l>
<l>    IsPassEncap := true</l>
<l>    concat_obj (EncapLocation, SelectedRegions1, EncapLocation)</l>
<c>    </c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Segmented Exact Encap Location']</l>
<l>        _FCI_DebugParameters (Image, EncapLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif  </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>****Initialization</c>
<l>* IsPassEncap := false</l>
<l>* gen_empty_obj (EncapLocation)</l>
<c></c>
<c>***Debug Parameter</c>
<l>* gen_empty_obj (DebugImageOut)</l>
<l>* gen_empty_obj (DebugRegionOut)</l>
<l>* DebugMessageOut :=  []</l>
<c></c>
<c>***Check Whether Consider Device Loc or not</c>
<l>* region_features (PVIRegion, 'width', PVIWidth)</l>
<l>* region_features (PVIRegion, 'height', PVIHeight)</l>
<l>* if(PVIWidth &gt; PVIHeight)</l>
<l>*     gen_empty_obj (DeviceLocation)</l>
<l>* endif</l>
<c></c>
<c>*** Remove Device Location Region from the PVI Region</c>
<l>* reduce_domain (Image, PVIRegion, ImageReduced)</l>
<l>* erosion_circle (DeviceLocation, DeviceLocation, 3.5)</l>
<l>* difference (PVIRegion, DeviceLocation, RegionDifference)</l>
<l>* reduce_domain (ImageReduced, RegionDifference, ImageReduced1)</l>
<c></c>
<c>****Segmentation</c>
<l>* threshold (ImageReduced1, Regions, MinEncapContrast, MaxEncapContrast)</l>
<l>* if (IsStepMode)</l>
<l>*     Message:=[' Initial Segmentation of the Encap Region']</l>
<l>*     _FCI_DebugParameters (ImageReduced1, Regions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)  </l>
<l>* endif</l>
<c></c>
<c></c>
<l>* fill_up_shape (Regions, RegionFillUp, 'area', 1, 500)</l>
<l>* opening_circle (RegionFillUp, RegionOpening, 5.5)</l>
<l>* fill_up (RegionOpening, RegionFillUp1)</l>
<l>* connection (RegionFillUp1, ConnectedRegions)</l>
<l>* select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<c></c>
<c>****For Bottom Images</c>
<l>* shape_trans (SelectedRegions, RegionTrans, 'convex')</l>
<l>* difference (RegionTrans, SelectedRegions, RegionDifferenceX)</l>
<l>* reduce_domain (ImageReduced1, RegionDifferenceX, ImageReduced2)</l>
<c></c>
<c></c>
<l>* threshold (ImageReduced2, Region1, 225, 255)</l>
<l>* opening_circle (Region1, RegionOpening1, 3.5)</l>
<l>* connection (RegionOpening1, ConnectedRegions1)</l>
<l>* area_center (ConnectedRegions1, Area1, Row3, Column3)</l>
<l>* if(Area1 &gt;0 and |Area1|&gt;0)</l>
<l>*     select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', 20, max(Area1))</l>
<l>* else</l>
<l>*     SelectedRegions1 := ConnectedRegions1</l>
<l>* endif</l>
<l>* union2 (SelectedRegions1, SelectedRegions, RegionUnion)</l>
<l>* union1 (RegionUnion, RegionUnion1)</l>
<l>* closing_circle (RegionUnion1, RegionClosing, 3.5)</l>
<l>* fill_up (RegionClosing, RegionFillUp2)</l>
<l>* connection (RegionFillUp2, ConnectedRegions3)</l>
<l>* select_shape_std (ConnectedRegions3, SelectedRegions2, 'max_area', 70)</l>
<c></c>
<c>****</c>
<l>* area_center (DeviceLocation, Area, Row2, Column2)</l>
<l>* gen_empty_obj (EmptyObject)</l>
<l>* if(Area &gt; 0 and |Area| &gt; 0)</l>
<l>*     get_image_size (ImageReduced1, ImageWidth, ImageHeight)</l>
<l>*     smallest_rectangle2 (DeviceLocation, Row, Column, Phi, Length1, Length2)</l>
<l>*     gen_rectangle2 (Rectangle, Row, Column, Phi, Length1, Length2/2)</l>
<l>*     intersection (DeviceLocation, Rectangle, RegionIntersection)</l>
<l>*     smallest_rectangle2 (RegionIntersection, Row1, Column1, Phi1, Length11, Length21)</l>
<l>*     gen_rectangle2 (Rectangle1, Row1, Column1, Phi1, Length11, ImageHeight)</l>
<l>*     difference (SelectedRegions2, Rectangle1, RegionDifference1)</l>
<l>*     connection (RegionDifference1, ConnectedRegions2)</l>
<l>*     select_shape_std (ConnectedRegions2, SelectedRegions3, 'max_area', 70)</l>
<l>*     concat_obj (EmptyObject, SelectedRegions3, EmptyObject)</l>
<l>* else</l>
<l>*     concat_obj (EmptyObject, SelectedRegions2, EmptyObject)</l>
<l>* endif</l>
<c></c>
<l>* area_center (EmptyObject, EncapArea, Dummy, Dummy)</l>
<l>* if (EncapArea&gt;0 and |EncapArea|&gt;0)</l>
<l>*     IsPassEncap := true</l>
<l>*     concat_obj (EncapLocation, EmptyObject, EncapLocation)</l>
<c>    </c>
<l>*     if (IsStepMode)</l>
<l>*         Message:=['Segmented Exact Encap Location']</l>
<l>*         _FCI_DebugParameters (Image, EncapLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>*     endif  </l>
<c>    </c>
<l>* endif</l>
<c></c>
<l>* return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspect_EncapLocation">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceLocation"/>
<parameter id="EncapLocation"/>
<parameter id="Image"/>
<parameter id="IsPassEncap"/>
<parameter id="IsStepMode"/>
<parameter id="MaxEncapContrast"/>
<parameter id="MinEncapContrast"/>
<parameter id="PVIRegion"/>
<parameter id="WireColor"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_Location">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DieLocationBottom" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="StepMode" base_type="ctrl" dimension="0"/>
<par name="SelectedNoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="SelectedNoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="SelectedMaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="SelectedLocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="SelectedLocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="SelectedModelIDs" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternDegree" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c>***</c>
<c></c>
<c></c>
<l>gen_empty_obj(DieLocationBottom)</l>
<l>count_obj(InspectImage,Number)</l>
<l>x := 0</l>
<l>for i := 0 to Number-1 by 1</l>
<c>    </c>
<l>    select_obj(InspectImage, SelectedImage, i+1)</l>
<l>    tuple_select (SelectedNoOfUniquePatterns, i, NoOfUniquePatterns4EachInt)</l>
<l>    tuple_select(SelectedNoOfLocationTeachRegs, i, NoOfLocationTeachRegs4EachInt)</l>
<c>    </c>
<l>    if(NoOfUniquePatterns4EachInt &gt;= 2)</l>
<l>        tuple_select(SelectedMaxRotationAngle, i, MaxRotationAngle4EachInt)</l>
<l>        tuple_select_range(SelectedPatternTeachRows, 2*NoOfUniquePatterns4EachInt*x, 2*(x+1)*NoOfUniquePatterns4EachInt-1, PatternTeachRows4EachInt)</l>
<l>        tuple_select_range(SelectedPatternTeachCols, 2*NoOfUniquePatterns4EachInt*x, 2*(x+1)*NoOfUniquePatterns4EachInt-1, PatternTeachCol4EachInt)</l>
<l>        tuple_select_range(SelectedLocationTeachRows, 2*x, 2*(x+1)-1, LocationTeachRows4EachInt)</l>
<l>        tuple_select_range(SelectedLocationTeachCols, 2*x, 2*(x+1)-1, LocationTeachCols4EachInt)</l>
<l>        tuple_select_range(SelectedModelIDs, 2*x, 2*(x+1)-1, ModelIDs4EachInt)</l>
<l>        tuple_select(SelectedPatternDegree, 0, PatternDegree4EachInt)</l>
<l>        x:= x+1</l>
<c>        </c>
<l>        MinSearchWidth := 100</l>
<l>        MinSearchHeight := 100</l>
<c>        </c>
<l>        _FCI_DeviceLocation_WithUniquePattern (SelectedImage, DieLocation1, RoughDieLocation, FindModel, DebugImageOut, DebugRegionOut, StepMode, SobelFlag, MinSearchWidth, MinSearchHeight, MaxRotationAngle4EachInt, MinAcceptanceScore4EachInt1, ModelIDs4EachInt, PatternDegree4EachInt, RefMatchModelCenterRow, RefMatchModelCenterColumn, DeviceWidth, DeviceHeight, MinDeviceContrast, PatternTeachRows4EachInt, PatternTeachCol4EachInt, LocationTeachRows4EachInt, LocationTeachCols4EachInt, MaskSize, Track, IsPass1, IsFindDatum, AngleDev2, ShiftAlongRow, ShiftAlongCol, MatchScore, DebugMessageOut)</l>
<c>         </c>
<l>        area_center(RoughDieLocation, RoughDieLocationArea, Dummy, Dummy)</l>
<l>        if(RoughDieLocationArea &gt;0 and |RoughDieLocationArea| &gt; 0 )</l>
<c>            </c>
<l>            _FCI_Exact_Die_Location_Bottom (SelectedImage, RoughDieLocation, DieLocationBottom, DebugImageOut, DebugRegionOut, StepMode, DebugMessageOut)</l>
<c></c>
<l>        else</l>
<l>            return()</l>
<l>        endif</l>
<c>   </c>
<l>    else</l>
<c>        </c>
<l>        if(NoOfLocationTeachRegs4EachInt &gt; 0 )</l>
<c>            </c>
<l>            tuple_select_range(SelectedLocationTeachRows, 2*x, 2*(x+1)-1, LocationTeachRows4EachInt)</l>
<l>            tuple_select_range(SelectedLocationTeachCols, 2*x, 2*(x+1)-1, LocationTeachCols4EachInt)</l>
<c>            </c>
<l>            _FCI_Finding_DieLocation_Bottom (SelectedImage, DieLocationBottom, DebugImageOut, DebugRegionOut, StepMode, LocationTeachRows4EachInt, LocationTeachCols4EachInt)</l>
<l>        endif</l>
<c>        </c>
<l>    endif</l>
<c></c>
<l>endfor</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c>***</c>
<c></c>
<c></c>
<l>gen_empty_obj(DieLocation)</l>
<l>count_obj(InspectImage,Number)</l>
<l>x := 0</l>
<l>for i := 0 to Number-1 by 1</l>
<c>    </c>
<l>    select_obj(InspectImage, SelectedImage, i+1)</l>
<l>    tuple_select (SelectedNoOfUniquePatterns, i, NoOfUniquePatterns4EachInt)</l>
<l>    tuple_select(SelectedNoOfLocationTeachRegs, i, NoOfLocationTeachRegs4EachInt)</l>
<c>    </c>
<l>    if(NoOfUniquePatterns4EachInt &gt;= 2)</l>
<l>        tuple_select(SelectedMaxRotationAngle, i, MaxRotationAngle4EachInt)</l>
<l>        tuple_select_range(SelectedPatternTeachRows, 2*NoOfUniquePatterns4EachInt*x, 2*(x+1)*NoOfUniquePatterns4EachInt-1, PatternTeachRows4EachInt)</l>
<l>        tuple_select_range(SelectedPatternTeachCols, 2*NoOfUniquePatterns4EachInt*x, 2*(x+1)*NoOfUniquePatterns4EachInt-1, PatternTeachCol4EachInt)</l>
<l>        tuple_select_range(SelectedLocationTeachRows, 2*x, 2*(x+1)-1, LocationTeachRows4EachInt)</l>
<l>        tuple_select_range(SelectedLocationTeachCols, 2*x, 2*(x+1)-1, LocationTeachCols4EachInt)</l>
<l>        tuple_select_range(SelectedModelIDs, 2*x, 2*(x+1)-1, ModelIDs4EachInt)</l>
<l>        tuple_select(SelectedPatternDegree, 0, PatternDegree4EachInt)</l>
<l>        x:= x+1</l>
<c>        </c>
<l>        MinSearchWidth := SelectedPatternSearchAreaAlongX[i]</l>
<l>        MinSearchHeight := SelectedPatternSearchAreaAlongY[i]</l>
<c>        </c>
<l>        _FCI_DeviceLocation_WithUniquePattern (SelectedImage, DieLocation2, RoughDieLocation, FindModel, DebugImageOut, DebugRegionOut, IsStepMode, SobelFlag1, MinSearchWidth, MinSearchHeight, MaxRotationAngle4EachInt, MinAcceptanceScore4EachInt, ModelIDs4EachInt, PatternDegree4EachInt, RefMatchModelCenterRow1, RefMatchModelCenterColumn1, DeviceWidth1, DeviceHeight1, MinDeviceContrast1, PatternTeachRows4EachInt, PatternTeachCol4EachInt, LocationTeachRows4EachInt, LocationTeachCols4EachInt, MaskSize1, Track1, IsPass2, IsFindDatum1, AngleDev3, ShiftAlongRow1, ShiftAlongCol1, MatchScore1, DebugMessageOut)</l>
<c>         </c>
<l>        area_center(RoughDieLocation, RoughDieLocationArea, Dummy, Dummy)</l>
<l>        if(RoughDieLocationArea &gt;0 and |RoughDieLocationArea| &gt; 0 )</l>
<c>            </c>
<l>            _FCI_Exact_Die_Location_Top (SelectedImage, RoughDieLocation, DieLocation, DebugImageOut, DebugRegionOut, IsStepMode, DebugMessageOut)</l>
<l>        else</l>
<l>            return()</l>
<l>        endif</l>
<c>   </c>
<l>    else</l>
<c>        </c>
<l>        if(NoOfLocationTeachRegs4EachInt &gt; 0 )</l>
<c>            </c>
<l>            tuple_select_range(SelectedLocationTeachRows, 2*x, 2*(x+1)-1, LocationTeachRows4EachInt)</l>
<l>            tuple_select_range(SelectedLocationTeachCols, 2*x, 2*(x+1)-1, LocationTeachCols4EachInt)</l>
<c>            </c>
<l>            _FCI_Finding_DieLocation_Top (SelectedImage, DieLocation, DebugImageOut, DebugRegionOut, IsStepMode, LocationTeachRows4EachInt, LocationTeachCols4EachInt)</l>
<l>        endif</l>
<c>        </c>
<l>    endif</l>
<c></c>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_Location">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DieLocationBottom"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="SelectedLocationTeachCols"/>
<parameter id="SelectedLocationTeachRows"/>
<parameter id="SelectedMaxRotationAngle"/>
<parameter id="SelectedModelIDs"/>
<parameter id="SelectedNoOfLocationTeachRegs"/>
<parameter id="SelectedNoOfUniquePatterns"/>
<parameter id="SelectedPatternDegree"/>
<parameter id="SelectedPatternSearchAreaAlongX"/>
<parameter id="SelectedPatternSearchAreaAlongY"/>
<parameter id="SelectedPatternTeachCols"/>
<parameter id="SelectedPatternTeachRows"/>
<parameter id="StepMode"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_SlotDefect">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="SlotLocation" base_type="iconic" dimension="0"/>
<par name="SlotLimit" base_type="iconic" dimension="0"/>
<par name="SlotSurfaceMasking" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SlotDefect" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="EdgeOffset" base_type="ctrl" dimension="0"/>
<par name="MinContrast" base_type="ctrl" dimension="0"/>
<par name="MaxIntensity" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="MinCount" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
<par name="AllDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllDefectMinLength" base_type="ctrl" dimension="0"/>
<par name="AllDefectMinSquareSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**Initialize</c>
<l>IsPass := true</l>
<l>gen_empty_obj(SlotDefect)</l>
<l>gen_empty_obj(SlotCandidate)</l>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c>**Check Insufficient</c>
<l>difference(SlotLimit, SlotLocation, RegionDifference1)</l>
<l>area_center(RegionDifference1, Area, Row, Column)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Slot Region Found']</l>
<l>    _FCI_DebugParameters (Image, SlotLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>    Message:=['Project Slot Limit To Check Region Insufficient']</l>
<l>    _FCI_DebugParameters (Image, SlotLimit, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>    Message:=['Region Insufficient']</l>
<l>    _FCI_DebugParameters (Image, RegionDifference1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>if(Area &gt;0)</l>
<l>    concat_obj(SlotCandidate, RegionDifference1, SlotCandidate)</l>
<l>endif</l>
<c></c>
<c>**Check Surface</c>
<l>if(EdgeOffset &gt; 1)</l>
<l>    erosion_circle(SlotSurfaceMasking, SlotSurfaceMasking, EdgeOffset)</l>
<l>endif</l>
<l>reduce_domain(Image, SlotSurfaceMasking, ImageReduced1)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Surface to Inspect']</l>
<l>    _FCI_DebugParameters (Image, SlotSurfaceMasking, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<l>mean_image(ImageReduced1, ImageMean, 9, 31)</l>
<l>dyn_threshold(ImageReduced1, ImageMean, Region1, MaxIntensity, 'dark')</l>
<l>* threshold(ImageReduced1, Region1, 0, MaxIntensity)</l>
<l>area_center(Region1, Area1, Row1, Column1)</l>
<l>if(Area1 &gt; 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Candidate Defect Base On Contrast']</l>
<l>        _FCI_DebugParameters (Image, Region1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>    connection(Region1, ConnectedRegions)</l>
<l>    gray_features(ConnectedRegions, Image, 'mean', InnerGray)</l>
<c>    </c>
<l>    dilation_circle(ConnectedRegions, RegionDilation, 3.5)</l>
<l>    difference(RegionDilation, ConnectedRegions, RegionDifference)</l>
<l>    gray_features(RegionDifference, Image, 'mean', OuterGray)</l>
<l>    DiffGray := OuterGray - InnerGray</l>
<l>    tuple_greater_elem(DiffGray, MinContrast, Greater)</l>
<l>    tuple_find(Greater, 1, Indices)</l>
<l>    if(Indices = -1)</l>
<l>        gen_empty_obj(Region1)</l>
<l>    else</l>
<l>        select_obj(ConnectedRegions, ObjectSelected, Indices+1)</l>
<l>        union1(ObjectSelected, Region1)</l>
<l>       if (IsStepMode)</l>
<l>            Message:=['Candidate Defect Base On Min Mean Gray Value Difference']</l>
<l>            _FCI_DebugParameters (Image, Region1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>        endif</l>
<l>        concat_obj(SlotCandidate, Region1,SlotCandidate)</l>
<l>    endif</l>
<l>endif</l>
<l>* deviation_image(ImageReduced1, ImageDeviation, 3, 3)</l>
<l>* threshold(ImageDeviation, Region, MinContrast, 255)</l>
<l>* if (IsStepMode)</l>
<l>*     Message:=['Defect Contrast']</l>
<l>*     _FCI_DebugParameters (Image, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>* endif</l>
<l>* concat_obj(SlotCandidate, Region, SlotCandidate)</l>
<l>connection(SlotCandidate, ConnectedRegions1)</l>
<l>select_shape(ConnectedRegions1, SelectedRegions1, ['area','max_diameter','inner_width', 'inner_height'], 'and', [MinSize,MinLength,MinSquareSize,MinSquareSize], [999999999,999999999,999999999,999999999])</l>
<l>if(IsStepMode)</l>
<l>    select_shape (ConnectedRegions1, SelectedRegion, ['inner_width','inner_height'], \
                  'and', [MinSquareSize, MinSquareSize], [99999999999999, 999999999])</l>
<l>    count_obj(SelectedRegion, RegionCount)</l>
<l>    if(RegionCount &gt; 0)</l>
<l>        Message:=['Defect Region Based On Min Square Size']</l>
<l>        _FCI_DebugParameters (Image, SelectedRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>        select_shape (SelectedRegion, SelectedRegion, 'max_diameter', \
                  'and', MinLength, 999999999)</l>
<l>        count_obj(SelectedRegion, RegionCount)</l>
<l>        if(RegionCount &gt; 0)</l>
<l>              Message:=[' Defect Region Based On Min Length']</l>
<l>              _FCI_DebugParameters (Image, SelectedRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>                select_shape (SelectedRegion, SelectedRegion, 'area', \
                          'and', MinSize, 999999999)</l>
<l>                count_obj(SelectedRegion, RegionCount)</l>
<l>                if(RegionCount &gt; 0)</l>
<l>                      Message:=[' Defect Region Based On Min Area']</l>
<l>                      _FCI_DebugParameters (Image, SelectedRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>                endif</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<l>count_obj(SelectedRegions1,Number1)</l>
<l>if(Number1 &gt;= MinCount)</l>
<l>    IsPass := false</l>
<l>    union2(SlotDefect,SelectedRegions1, SlotDefect)</l>
<l>    region_features (SelectedRegions1, ['area','max_diameter','inner_width','inner_height'], Value)</l>
<l>    AllDefectMinSize             := Value[0]</l>
<l>    AllDefectMinLength            := Value[1]</l>
<l>    AllDefectMinSquareSize        := min2(Value[2],Value[3])</l>
<c></c>
<l>    if (IsStepMode)</l>
<l>        Message:=['Finale Defect Region Based On Square Size And Length']</l>
<l>        _FCI_DebugParameters (Image, SelectedRegions1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif    </l>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_SlotDefect">
<parameters>
<parameter id="AllDefectMinLength"/>
<parameter id="AllDefectMinSize"/>
<parameter id="AllDefectMinSquareSize"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EdgeOffset"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxIntensity"/>
<parameter id="MinContrast"/>
<parameter id="MinCount"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
<parameter id="SlotDefect"/>
<parameter id="SlotLimit"/>
<parameter id="SlotLocation"/>
<parameter id="SlotSurfaceMasking"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_SlotInsufficient">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="SlotLocation" base_type="iconic" dimension="0"/>
<par name="SlotLimit" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SlotInsufficient" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MaxIntensity" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>gen_empty_obj(SlotInsufficient)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<l>difference(SlotLimit, SlotLocation,SlotDifference)</l>
<l>area_center(SlotDifference, Area, Row, Column)</l>
<l>if(Area &gt; 0)</l>
<l>    IsPass := false</l>
<l>    union2(SlotInsufficient, SlotDifference, SlotInsufficient)</l>
<l>    if(IsStepMode)</l>
<l>         Message:=['Slot Location Excess Limit Region']</l>
<l>        _FCI_DebugParameters (Image, SlotInsufficient, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>    endif</l>
<l>    return()</l>
<l>endif</l>
<l>region_features(SlotLocation, 'width', LocationWidth)</l>
<l>if(LocationWidth &lt; 5)</l>
<l>    LocationWidth := 5</l>
<l>endif</l>
<l>reduce_domain(Image, SlotLocation,ImageReduced)</l>
<l>threshold(ImageReduced, Region, 0, MaxIntensity)</l>
<l>connection(Region, ConnectedRegions)</l>
<l>region_features(ConnectedRegions, 'width', InsufficientWidth)</l>
<l>tuple_greater_elem(InsufficientWidth, LocationWidth - 5, Greater)</l>
<l>tuple_find(Greater, 1, Indices)</l>
<l>if(Indices = -1)</l>
<l>    return()</l>
<l>else</l>
<l>    IsPass := 2</l>
<l>    select_obj(ConnectedRegions, ObjectSelected, Indices)</l>
<l>    union2(SlotInsufficient, ObjectSelected, SlotInsufficient)</l>
<l>    if(IsStepMode)</l>
<l>         Message:=['Slot is not linked']</l>
<l>        _FCI_DebugParameters (Image, SlotInsufficient, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_SlotInsufficient">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MaxIntensity"/>
<parameter id="SlotInsufficient"/>
<parameter id="SlotLimit"/>
<parameter id="SlotLocation"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_SlotLocation">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="SlotROI" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SlotLocation" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinSlotIntensity" base_type="ctrl" dimension="0"/>
<par name="ContrastEdge" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>****Initialization</c>
<l>gen_empty_obj(SlotLocation)</l>
<l>gen_empty_obj(TempSlotLocation)</l>
<l>IsPass := true</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>reduce_domain(Image, SlotROI, ImageReduced)</l>
<l>threshold (ImageReduced, Region, MinSlotIntensity, 255)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Segmentation of Slot Region by threshold']</l>
<l>    _FCI_DebugParameters (ImageReduced, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>endif</l>
<l>area_center(Region, Area, Row, Column)</l>
<l>if(Area = 0)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Failed by no Slot']</l>
<l>        _FCI_DebugParameters (ImageReduced, Region, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>    endif</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<l>closing_rectangle1(Region, RegionClosing, 1, 100)</l>
<l>connection(RegionClosing, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, 'area', 'and', 150, 99999999999)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Closing of Slot Region']</l>
<l>    _FCI_DebugParameters (ImageReduced, SelectedRegions, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>endif</l>
<l>area_center(SelectedRegions, Area1, Row1, Column1)</l>
<l>if(Area1 &gt; 0)</l>
<c>    ***Recheck Slot</c>
<l>    dilation_circle(SelectedRegions, RegionDilation, 5)</l>
<l>    difference(RegionDilation, SelectedRegions, RegionDifference)</l>
<l>    gray_features(RegionDifference, ImageReduced, 'mean', MeanOuter)</l>
<l>    gray_features(SelectedRegions, ImageReduced, 'mean', MeanInner)</l>
<l>    MeanDiff := abs(MeanOuter - MeanInner)</l>
<l>    tuple_greater_elem(MeanDiff, 30, Greater)</l>
<l>    tuple_find(Greater, 1, Indices)</l>
<l>    if(Indices = -1)</l>
<l>        gen_empty_obj(SlotLocation)</l>
<l>        IsPass := false</l>
<l>        if (IsStepMode)</l>
<l>            Message:=['Failed by no Slot']</l>
<l>            _FCI_DebugParameters (ImageReduced, SlotLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>        endif</l>
<l>        return()</l>
<l>    else</l>
<l>        select_obj(SelectedRegions, ObjectSelected, Indices+1)</l>
<l>        union2(TempSlotLocation, ObjectSelected, TempSlotLocation)</l>
<l>        if (IsStepMode)</l>
<l>            Message:=['Slot after checking Real Slot']</l>
<l>            _FCI_DebugParameters (ImageReduced, ObjectSelected, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>        endif</l>
<l>        reduce_domain(Image, TempSlotLocation, ImageReduced1)</l>
<l>        edges_sub_pix(ImageReduced1, Edges, 'canny', 5, ContrastEdge, 4*ContrastEdge)</l>
<l>       count_obj(Edges, edgesInspectCount)</l>
<l>        if(edgesInspectCount = 0)</l>
<l>            SlotLocation := TempSlotLocation</l>
<l>            return()</l>
<l>        endif</l>
<l>        select_shape_xld(Edges, SelectedXLD, 'contlength', 'and', 20, 99999)</l>
<l>        union_collinear_contours_xld(Edges, UnionContours1, 40, 1, 2, 0.1, 'attr_keep')</l>
<l>        union_adjacent_contours_xld(UnionContours1, UnionContours, 200, 1, 'attr_keep')</l>
<l>        smallest_rectangle2_xld(UnionContours, Row2, Column2, Phi, Length1, Length2)</l>
<l>        gen_rectangle2(Rectangle, Row2, Column2, Phi, Length1, Length2)</l>
<l>        union2(SlotLocation, Rectangle, SlotLocation)</l>
<l>        closing_rectangle1(SlotLocation, SlotLocation, 1, 10)</l>
<l>        if (IsStepMode)</l>
<l>            Message:=['Filter Slot by Edge Contrast']</l>
<l>            _FCI_DebugParameters (ImageReduced, SlotLocation, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)   </l>
<l>        endif</l>
<l>    endif</l>
<l>else</l>
<l>    gen_empty_obj(SlotLocation)</l>
<l>    IsPass := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Inspect_SlotLocation">
<parameters>
<parameter id="ContrastEdge"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Image"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinSlotIntensity"/>
<parameter id="SlotLocation"/>
<parameter id="SlotROI"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspect_UniquePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="FindModel" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="MinSearchWidth" base_type="ctrl" dimension="0"/>
<par name="MinSearchHeight" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsFindDatum" base_type="ctrl" dimension="0"/>
<par name="MatchScore" base_type="ctrl" dimension="0"/>
<par name="MatchAngle" base_type="ctrl" dimension="0"/>
<par name="DatumMatchCR" base_type="ctrl" dimension="0"/>
<par name="DatumMatchCC" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsFindDatum := false</l>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c>****</c>
<l>gen_empty_obj(FindModel)</l>
<l>MatchScore := 0</l>
<l>MatchAngle := []</l>
<l>DatumMatchCR := []</l>
<l>DatumMatchCC := []</l>
<c></c>
<c></c>
<l>dev_display(Image)</l>
<c></c>
<c>****Generate ROI</c>
<l>gen_empty_obj(ROI)</l>
<l>NoOfModel := |PatternTeachRows|/2</l>
<l>for Index := 0 to NoOfModel-1 by 1</l>
<l>    tuple_select_range (PatternTeachRows, 2*Index, 2*(Index+1)-1, PatternRowsCoord)</l>
<l>    tuple_select_range (PatternTeachCols, 2*Index, 2*(Index+1)-1, PatternColsCoord)</l>
<l>    gen_rectangle1(Rectangle, PatternRowsCoord[0], PatternColsCoord[0], PatternRowsCoord[1], PatternColsCoord[1])</l>
<l>    concat_obj(ROI, Rectangle, ROI)</l>
<l>endfor</l>
<c></c>
<c>*****</c>
<c></c>
<l>ModelID := ModelIDs</l>
<l>union1 (ROI, ModelRegion)</l>
<l>area_center(ModelRegion, Dummy, CenterRow, CenterColumn)</l>
<c></c>
<c></c>
<l>gen_empty_obj (EmptyObject)</l>
<l>connection (ModelRegion, ConnectedRegions)</l>
<l>count_obj (ConnectedRegions, Number)</l>
<l>for SIndex := 1 to Number by 1</l>
<l>    select_obj (ConnectedRegions, ObjectSelected, SIndex)</l>
<l>    smallest_rectangle1 (ObjectSelected, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1 (Rectangle, Row1 - MinSearchHeight/2.0, Column1 - MinSearchWidth/2.0, Row2 + MinSearchHeight/2.0, Column2 + MinSearchWidth/2.0)</l>
<l>    concat_obj (EmptyObject, Rectangle, EmptyObject)</l>
<l>endfor</l>
<l>union1 (EmptyObject, SearchRegion)</l>
<l>if (IsStepMode)</l>
<l>    Message:=['Searching Region for Pointers']</l>
<l>    _FCI_DebugParameters (Image, SearchRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif </l>
<c></c>
<l>_Find_Model (Image, SearchRegion, ModelRegion, \
             MatchModel, \
             CenterRow, CenterColumn, ModelID, MinAcceptanceScore, MaxRotationAngle, \
             IsFindDatum, DatumMatchCR, DatumMatchCC, MatchAngle, MatchScore)</l>
<c></c>
<l>if(IsFindDatum = false)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Pointer Region Model not Found : Update Search Parameter Values']</l>
<l>        gen_empty_region (EmptyRegion)</l>
<l>       _FCI_DebugParameters (Image, EmptyRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>        </c>
<l>    endif </l>
<l>    return()</l>
<l>else</l>
<l>    concat_obj (FindModel, MatchModel, FindModel)</l>
<l>    if (IsStepMode)</l>
<l>        Message:=['Found the Pointer Region Model' ]</l>
<l>       _FCI_DebugParameters (Image, FindModel, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c></c>
<l>    endif </l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspect_UniquePattern">
<parameters>
<parameter id="DatumMatchCC"/>
<parameter id="DatumMatchCR"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FindModel"/>
<parameter id="Image"/>
<parameter id="IsFindDatum"/>
<parameter id="IsStepMode"/>
<parameter id="MatchAngle"/>
<parameter id="MatchScore"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinSearchHeight"/>
<parameter id="MinSearchWidth"/>
<parameter id="ModelIDs"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Inspectt_CoverLayer">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="InspectRegionForCVL" base_type="iconic" dimension="0"/>
<par name="SelectedDeviceLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="CoverLayerRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="TopCloseDistance" base_type="ctrl" dimension="0"/>
<par name="TopFarDistance" base_type="ctrl" dimension="0"/>
<par name="BottomCloseDistance" base_type="ctrl" dimension="0"/>
<par name="BottomFarDistance" base_type="ctrl" dimension="0"/>
<par name="SideCloseDistance" base_type="ctrl" dimension="0"/>
<par name="SideFarDistance" base_type="ctrl" dimension="0"/>
<par name="CoverLayerCharacterstics" base_type="ctrl" dimension="0"/>
<par name="AbsThreshold" base_type="ctrl" dimension="0"/>
<par name="MaxGapForCL" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsCoverLayer" base_type="ctrl" dimension="0"/>
<par name="ResultantThickness" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>******Initialization</c>
<l>IsCoverLayer := true</l>
<l>ROIWidth := 100</l>
<l>MaskSize := 65</l>
<l>ResultantThickness := 0</l>
<l>PerGapPermit := 0.8</l>
<l>MinGrayMean := 40</l>
<c></c>
<l>gen_empty_obj(CoverLayerRegion)</l>
<c></c>
<c>*******</c>
<l>gen_empty_obj (OuterRightSideROI)</l>
<l>gen_empty_obj (InnerRightSideROI)</l>
<l>gen_empty_obj (OuterLeftSideROI)</l>
<l>gen_empty_obj (InnerLeftSideROI)</l>
<c></c>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c>***</c>
<c>****Step 1: Remove Black Encap Region</c>
<l>EncapContrast := 100</l>
<l>EncapHeight := 400</l>
<c></c>
<l>gen_empty_obj (EncapRegion)</l>
<l>if(FoV = 1 or FoV = nFoVs)</l>
<l>    threshold (Image, EncapThRegion, 0, EncapContrast)</l>
<l>    opening_rectangle1 (EncapThRegion, RegionOpening1, 0.5, EncapHeight)</l>
<l>    closing_rectangle1 (RegionOpening1, RegionClosing5, 20.5, 20.5)</l>
<l>    opening_rectangle1 (RegionClosing5, RegionOpening2, 10.5, 10.5)</l>
<l>    concat_obj (EncapRegion, RegionOpening2, EncapRegion)</l>
<l>endif</l>
<c></c>
<c></c>
<c>***Get Image Size</c>
<l>get_image_size (Image, ImageWidth, ImageHeight)   </l>
<l>smallest_rectangle2 (InspectRegionForCVL, Row, Column, Phi, Length1, Length2)</l>
<c></c>
<c>***</c>
<l>TotalImageArea := ImageWidth * ImageHeight</l>
<l>area_center (InspectRegionForCVL, DeviceArea, Dummy, Dummy)</l>
<l>Fraction := DeviceArea/(TotalImageArea*1.0)</l>
<c></c>
<c></c>
<c>****Device Edge Location</c>
<c>***Lower</c>
<l>DeviceLowerEdgeRowIndex := Row + Length2</l>
<l>DeviceLowerEdgeColumnIndex := Column</l>
<l>* gen_cross_contour_xld (Cross, DeviceLowerEdgeRowIndex, DeviceLowerEdgeColumnIndex, 60, Phi)</l>
<c></c>
<c>****Upper</c>
<l>DeviceUpperEdgeRowIndex := Row - Length2</l>
<l>DeviceUpperEdgeColumnIndex := Column</l>
<l>* gen_cross_contour_xld (Cross1, DeviceUpperEdgeRowIndex, DeviceUpperEdgeColumnIndex, 60, Phi)</l>
<c></c>
<c></c>
<c>****RightSide</c>
<l>DeviceRightSideEdgeRowIndex := Row</l>
<l>DeviceRightSideEdgeColumnIndex := Column + Length1</l>
<l>* gen_cross_contour_xld (Cross2, DeviceRightSideEdgeRowIndex, DeviceRightSideEdgeColumnIndex, 60, Phi)</l>
<c></c>
<c>*****LeftSide</c>
<l>DeviceLeftSideEdgeRowIndex := Row</l>
<l>DeviceLeftSideEdgeColumnIndex := Column - Length1</l>
<l>* gen_cross_contour_xld (Cross2, DeviceLeftSideEdgeRowIndex, DeviceLeftSideEdgeColumnIndex, 60, Phi)</l>
<c></c>
<c>****Outer ROI</c>
<l>if(Fraction &gt; 0.1)</l>
<l>    gen_rectangle2 (OuterLowerROI, DeviceLowerEdgeRowIndex + BottomFarDistance, DeviceLowerEdgeColumnIndex, Phi, ImageWidth, ROIWidth )</l>
<l>    gen_rectangle2 (OuterUpperROI, DeviceUpperEdgeRowIndex - TopFarDistance, DeviceUpperEdgeColumnIndex, Phi, ImageWidth, ROIWidth)</l>
<l>else</l>
<l>    gen_rectangle2 (OuterLowerROI, DeviceLowerEdgeRowIndex + BottomFarDistance, DeviceLowerEdgeColumnIndex, Phi, ROIWidth, ImageHeight)</l>
<l>    gen_rectangle2 (OuterUpperROI, DeviceUpperEdgeRowIndex - TopFarDistance, DeviceUpperEdgeColumnIndex, Phi, ROIWidth, ImageHeight)</l>
<l>endif</l>
<l>concat_obj (OuterLowerROI, OuterUpperROI, OuterConcatObject)</l>
<l>_FCI_Select_ROI4CoverLayer (OuterConcatObject, OuterConcatObject)</l>
<c></c>
<c>**** Inner ROI</c>
<l>if(Fraction &gt; 0.1)</l>
<l>    gen_rectangle2 (InnerLowerROI, DeviceLowerEdgeRowIndex + BottomCloseDistance, DeviceLowerEdgeColumnIndex, Phi, ImageHeight, ROIWidth)</l>
<l>    gen_rectangle2 (InnerUpperROI, DeviceUpperEdgeRowIndex - TopCloseDistance, DeviceUpperEdgeColumnIndex, Phi, ImageHeight, ROIWidth)</l>
<l>else</l>
<l>    gen_rectangle2 (InnerLowerROI, DeviceLowerEdgeRowIndex + BottomCloseDistance, DeviceLowerEdgeColumnIndex, Phi, ROIWidth, ImageWidth)</l>
<l>    gen_rectangle2 (InnerUpperROI, DeviceUpperEdgeRowIndex - TopCloseDistance, DeviceUpperEdgeColumnIndex, Phi, ROIWidth, ImageWidth)</l>
<c>    </c>
<l>endif</l>
<l>concat_obj (InnerLowerROI, InnerUpperROI, InnerConcatObjects)</l>
<l>_FCI_Select_ROI4CoverLayer (InnerConcatObjects, InnerConcatObjects)</l>
<c></c>
<c>****Side ROI</c>
<l>gen_empty_obj (SideObjects)</l>
<l>if(FoV = 1)</l>
<l>    if(Fraction &gt; 0.1)</l>
<l>        gen_rectangle2 (InnerLeftSideROI, DeviceLeftSideEdgeRowIndex, DeviceLeftSideEdgeColumnIndex - SideCloseDistance, Phi, ROIWidth, ImageWidth)</l>
<l>    else</l>
<l>        gen_rectangle2 (InnerLeftSideROI, DeviceLeftSideEdgeRowIndex, DeviceLeftSideEdgeColumnIndex - SideCloseDistance, Phi, ROIWidth, ImageWidth)</l>
<l>    endif</l>
<l>    _FCI_Select_ROI4CoverLayer (InnerLeftSideROI, SideObjects)</l>
<c>    </c>
<l>elseif(FoV = nFoVs)</l>
<c>    </c>
<l>    if(Fraction &gt; 0.1)</l>
<l>        gen_rectangle2 (OuterRightSideROI, DeviceRightSideEdgeRowIndex, DeviceRightSideEdgeColumnIndex + SideFarDistance, Phi, ROIWidth, ImageHeight)</l>
<l>        gen_rectangle2 (InnerRightSideROI, DeviceRightSideEdgeRowIndex, DeviceRightSideEdgeColumnIndex + SideCloseDistance, Phi, ROIWidth, ImageHeight)</l>
<l>    else</l>
<l>        gen_rectangle2 (OuterRightSideROI, DeviceRightSideEdgeRowIndex, DeviceRightSideEdgeColumnIndex + SideFarDistance, Phi, ImageHeight, ROIWidth)</l>
<l>        gen_rectangle2 (InnerRightSideROI, DeviceRightSideEdgeRowIndex, DeviceRightSideEdgeColumnIndex + SideCloseDistance, Phi, ImageHeight, ROIWidth)</l>
<l>    endif</l>
<l>    concat_obj (OuterRightSideROI, InnerRightSideROI, RightSideObjects)</l>
<l>    _FCI_Select_ROI4CoverLayer (RightSideObjects, SideObjects)    </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>RectROIArea := ImageHeight * ROIWidth</l>
<c>*******Outer Part</c>
<l>gen_empty_obj (OuterEmptyObject)</l>
<l>count_obj (OuterConcatObject, ABOuterObjCount)</l>
<l>if(ABOuterObjCount &gt; 0 )</l>
<l>    for ABOuterIndex := 1 to ABOuterObjCount by 1</l>
<l>        select_obj (OuterConcatObject, ABObjectSelected, ABOuterIndex)</l>
<l>        area_center (ABObjectSelected, SelectedObjArea, Dummy, Dummy)</l>
<l>        Fraction := SelectedObjArea/(RectROIArea*1.0)</l>
<l>        if(Fraction &lt; 0.6)</l>
<l>            continue</l>
<l>        endif</l>
<l>        reduce_domain (Image, ABObjectSelected, ABImageReduced)</l>
<l>        gray_closing_rect (ABImageReduced, ImageClosing, 7.5, 0.5)</l>
<c>        </c>
<l>        if(CoverLayerCharacterstics = 0)</l>
<l>            var_threshold (ImageClosing, Region, MaskSize, MaskSize, 0.5, AbsThreshold, 'dark')        </l>
<l>        elseif (CoverLayerCharacterstics = 1)</l>
<l>            var_threshold (ImageClosing, Region, MaskSize, MaskSize, 0.2, AbsThreshold, 'light')</l>
<l>        endif</l>
<c>        </c>
<l>        fill_up (Region, RegionFillUp1)</l>
<l>        closing_rectangle1 (RegionFillUp1, RegionClosing, 5.5, 0.5)</l>
<l>        connection (RegionClosing, ConnectedRegions4)</l>
<l>        select_shape (ConnectedRegions4, SelectedRegions4, 'max_diameter', 'and', 0.5*MaxGapForCL, 99999)</l>
<l>        count_obj (SelectedRegions4, Number2)</l>
<l>        if(Number2 &gt; 0)</l>
<l>            union1 (SelectedRegions4, RegionUnion1)</l>
<l>            closing_rectangle1 (RegionUnion1, RegionClosing2, PerGapPermit * MaxGapForCL, 0.5)</l>
<l>            connection (RegionClosing2, ConnectedRegions5)</l>
<l>            count_obj (ConnectedRegions5, Number3)</l>
<l>            if(Number3 &gt;= 2)</l>
<l>                select_shape (ConnectedRegions5, SelectedRegions5, 'width', 'and', 0.3*ImageWidth, 99999)</l>
<l>                dilation_rectangle1 (SelectedRegions5, RegionDilation, 0.5, 70.5)</l>
<l>                count_obj (RegionDilation, Number5)</l>
<l>                if(Number5 = 2)</l>
<l>                    select_obj (RegionDilation, ObjectSelected2, 1)</l>
<l>                    select_obj (RegionDilation, ObjectSelected3, 2)</l>
<l>                    intersection (ObjectSelected2, ObjectSelected3, RegionIntersection)</l>
<l>                    area_center (RegionIntersection, Area1, Row1, Column1)</l>
<l>                    if(Area1 &gt; 0 and |Area1| &gt; 0)</l>
<l>                        select_shape_std (SelectedRegions5, SelectedRegions, 'max_area', 70)</l>
<l>                        OuterEmptyObject := SelectedRegions</l>
<l>                    else</l>
<l>                        union1 (SelectedRegions5, RegionUnion2)</l>
<l>                        OuterEmptyObject := RegionUnion2</l>
<l>                    endif</l>
<l>                else</l>
<l>                    union1 (SelectedRegions5, RegionUnion2)</l>
<l>                    OuterEmptyObject := RegionUnion2</l>
<l>                endif</l>
<l>            else</l>
<l>                OuterEmptyObject := RegionClosing2</l>
<l>            endif</l>
<l>            concat_obj (CoverLayerRegion, OuterEmptyObject, CoverLayerRegion)</l>
<l>        else</l>
<l>            IsCoverLayer := false</l>
<l>            return()</l>
<l>        endif</l>
<l>    endfor</l>
<l>else</l>
<l>    IsCoverLayer := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>*********Inner Part</c>
<l>region_features (SelectedDeviceLocation, 'width', DeviceWidth)</l>
<l>InnerWidth := DeviceWidth + SideCloseDistance</l>
<c></c>
<l>gen_empty_obj (InnerEmptyObject)</l>
<l>sort_region (InnerConcatObjects, InnerConcatObjects, 'character', 'true', 'column')</l>
<l>count_obj (InnerConcatObjects, ABInnerCount)</l>
<l>if(ABInnerCount = 2)</l>
<l>    for ABInnerIndex := 1 to ABInnerCount by 1</l>
<l>        select_obj (InnerConcatObjects, InnerObjectSelected, ABInnerIndex)</l>
<l>        reduce_domain (Image, InnerObjectSelected, ImageReduced)</l>
<l>        gray_closing_rect (ImageReduced, ImageClosing1, 3.5, 3.5)</l>
<c>        </c>
<l>        if(CoverLayerCharacterstics = 0)</l>
<l>            var_threshold (ImageClosing1, Region, MaskSize, MaskSize, 0.5, AbsThreshold, 'dark')        </l>
<l>        elseif (CoverLayerCharacterstics = 1)</l>
<l>            var_threshold (ImageClosing1, Region, MaskSize, MaskSize, 0.2, AbsThreshold, 'light')</l>
<l>        endif</l>
<l>        closing_rectangle1 (Region, RegionClosing1, 6.5, 2.5)</l>
<l>        fill_up (RegionClosing1, RegionFillUp2)</l>
<c>        </c>
<l>        connection (RegionFillUp2, ConnectedRegions6)</l>
<l>        select_shape (ConnectedRegions6, SelectedRegions6, 'max_diameter', 'and', MaxGapForCL, 99999)</l>
<l>        count_obj (SelectedRegions6, Number4)</l>
<l>        if(Number4 &gt; 0)</l>
<c>            </c>
<l>            union1 (SelectedRegions6, RegionUnion3)</l>
<l>            closing_rectangle1 (RegionUnion3, RegionClosing3, 5.5, 0.5)            </l>
<l>            connection (RegionClosing3, ConnectedRegions7)</l>
<l>            select_shape (ConnectedRegions7, SelectedRegions7, 'max_diameter', 'and', MaxGapForCL, 99999)</l>
<l>            union1 (SelectedRegions7, RegionUnion4)</l>
<l>            closing_rectangle1 (RegionUnion4, RegionClosing4, MaxGapForCL, 0.5)</l>
<c></c>
<c>            ***</c>
<l>            connection(RegionClosing4, ConnectedRegions8)</l>
<l>            select_shape (ConnectedRegions8, SelectedRegions2, 'width', 'and', 0.8*InnerWidth, 1.5*InnerWidth)</l>
<l>            count_obj (SelectedRegions2, Number1)</l>
<l>            if(Number1 = 0 )</l>
<l>                IsCoverLayer := false</l>
<l>                return()</l>
<l>            endif</l>
<l>            if(Number1 = 1)</l>
<l>                intersection (SelectedRegions2, RegionClosing3, RegionIntersection1)</l>
<l>                if(FoV = 1 or FoV = nFoVs)</l>
<l>                    connection (RegionIntersection1, ConnectedRegions1)</l>
<l>                    select_shape_std (ConnectedRegions1, RegionIntersection1, 'max_area', 70)</l>
<l>                endif              </l>
<l>                concat_obj (CoverLayerRegion, RegionIntersection1, CoverLayerRegion)</l>
<l>            else</l>
<c>                </c>
<l>                region_features (SelectedRegions2, 'width', Value)</l>
<l>                tuple_equal_elem (Value, ImageWidth, Equal)</l>
<l>                tuple_find (Equal, 0, Indices)</l>
<l>                if(Indices = -1)</l>
<l>                    sort_region (SelectedRegions2, SortedRegions, 'character', 'true', 'column')</l>
<l>                    select_obj (SortedRegions, ObjectSelected1, ABInnerIndex)</l>
<l>                    InnerEmptyObject := ObjectSelected1</l>
<l>                else</l>
<l>                    select_shape_std (SelectedRegions2, SelectedRegions3, 'max_area', 70)</l>
<l>                    intersection (SelectedRegions3, RegionUnion3, RegionIntersection1)</l>
<l>                    InnerEmptyObject := RegionIntersection1</l>
<l>                endif</l>
<l>                concat_obj (CoverLayerRegion, InnerEmptyObject, CoverLayerRegion)</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<l>else</l>
<l>    IsCoverLayer := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>******* Side Part</c>
<l>count_obj (SideObjects, SideObjCount)</l>
<c></c>
<l>for SideIndex := 1 to SideObjCount by 1</l>
<l>    select_obj (SideObjects, SideObjectSelected, SideIndex)</l>
<l>    area_center (SideObjectSelected, SelectedObjArea, Dummy, Dummy)</l>
<l>    Fraction := SelectedObjArea/(RectROIArea*1.0)</l>
<l>    if(Fraction &lt; 0.6)</l>
<l>        if(SideObjCount = 1)</l>
<l>            IsCoverLayer := false</l>
<l>            return() </l>
<l>        else</l>
<l>            continue</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>    reduce_domain (Image, SideObjectSelected, ImageReduced1)</l>
<l>    gray_closing_shape (ImageReduced1, ImageOpening, 5.5, 5.5, 'octagon')</l>
<c>    </c>
<l>    if(CoverLayerCharacterstics = 0)</l>
<l>        var_threshold (ImageOpening, Region, MaskSize, MaskSize, 0.5, AbsThreshold, 'dark')        </l>
<l>    elseif (CoverLayerCharacterstics = 1)</l>
<l>        var_threshold (ImageOpening, Region, MaskSize, MaskSize, 0.2, AbsThreshold, 'light')</l>
<l>    endif</l>
<c>    </c>
<l>    difference (Region, EncapRegion, RegionDifference)</l>
<l>    fill_up (RegionDifference, RegionFillUp)</l>
<l>    closing_rectangle1 (RegionFillUp, RegionClosing, 0.5, 25.5)</l>
<l>    opening_rectangle1 (RegionClosing, RegionOpening, 2.5, 0.5)</l>
<l>    connection (RegionOpening, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions6, 'max_diameter', 'and', MaxGapForCL, 99999)</l>
<l>    count_obj (SelectedRegions6, Number)</l>
<l>    gen_empty_obj(CoverLayerRegion1)</l>
<l>    if(Number &gt; 0)</l>
<l>        for j := 1 to Number by 1</l>
<l>            select_obj (SelectedRegions6, ObjectSelected, j)</l>
<l>            intensity (ObjectSelected, Image, Mean, Deviation)</l>
<l>            if(Mean &gt; MinGrayMean)</l>
<l>                concat_obj (CoverLayerRegion1, ObjectSelected, CoverLayerRegion1)  </l>
<l>            endif</l>
<l>        endfor</l>
<l>        connection (CoverLayerRegion1, ConnectedRegions2)</l>
<l>        select_shape_std (ConnectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<l>        concat_obj (CoverLayerRegion, SelectedRegions1, CoverLayerRegion)</l>
<l>    else</l>
<l>        IsCoverLayer := false</l>
<l>        return() </l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>union1 (CoverLayerRegion, CoverLayerRegion)</l>
<l>area_center (CoverLayerRegion, Area, Dummy, Dummy)</l>
<l>if(Area = 0 and |Area| = 0)</l>
<l>    IsCoverLayer := false</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    count_obj(DebugRegionOut, DebugRegNo)</l>
<l>    count_obj(DebugImageOut,DebugImageNo)</l>
<l>    tuple_length(DebugMessageOut,DebugMsgNo)</l>
<l>    if(DebugImageNo=DebugRegNo and DebugMsgNo=DebugRegNo)</l>
<l>        Message:=['1: Segmented Cover Layer Region']</l>
<l>        _FCI_DebugParameters (Image, CoverLayerRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif  </l>
<l>endif</l>
<c></c>
<c>*******Upper Check</c>
<l>gen_region_line (UpperLine, ImageHeight/2, ImageWidth/2, 0, ImageWidth/2)</l>
<l>intersection (CoverLayerRegion, UpperLine, UpperRegionIntersection)</l>
<l>connection (UpperRegionIntersection, ConnectedUpperRegions)</l>
<l>count_obj (ConnectedUpperRegions, UpperCountNumber)</l>
<l>if(UpperCountNumber &gt;= 2)</l>
<l>    _Finding_CVL_Thickness (ConnectedUpperRegions, UpperCountNumber, \
                            UpperThicknessOfCVL)</l>
<l>else</l>
<l>    UpperThicknessOfCVL := 0</l>
<l>endif</l>
<c></c>
<c></c>
<c>******Lower Check</c>
<l>gen_region_line (LowerLine, ImageHeight/2, ImageWidth/2, ImageHeight, ImageWidth/2)</l>
<l>intersection (CoverLayerRegion, LowerLine, LowerRegionIntersection)</l>
<l>connection (LowerRegionIntersection, ConnectedLowerRegions)</l>
<l>count_obj (ConnectedLowerRegions, LowerCountNumber)</l>
<l>if(LowerCountNumber &gt;= 2)</l>
<l>    _Finding_CVL_Thickness (ConnectedLowerRegions, LowerCountNumber, \
                            LowerThicknessOfCVL)</l>
<l>else</l>
<l>    LowerThicknessOfCVL := 0</l>
<l>endif</l>
<c></c>
<c>******Width of Coverlayer</c>
<l>tuple_max ([LowerThicknessOfCVL, UpperThicknessOfCVL], ResultantThickness)</l>
<c></c>
<l>if(ResultantThickness = 0)</l>
<l>    IsCoverLayer := false</l>
<l>    return()</l>
<l>endif</l>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_Inspectt_CoverLayer">
<parameters>
<parameter id="AbsThreshold"/>
<parameter id="BottomCloseDistance"/>
<parameter id="BottomFarDistance"/>
<parameter id="CoverLayerCharacterstics"/>
<parameter id="CoverLayerRegion"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="InspectRegionForCVL"/>
<parameter id="IsCoverLayer"/>
<parameter id="IsStepMode"/>
<parameter id="MaxGapForCL"/>
<parameter id="ResultantThickness"/>
<parameter id="SelectedDeviceLocation"/>
<parameter id="SideCloseDistance"/>
<parameter id="SideFarDistance"/>
<parameter id="TopCloseDistance"/>
<parameter id="TopFarDistance"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Light_Coefficient_Inspect">
<interface>
<io>
<par name="LightImage" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Coefficient" base_type="ctrl" dimension="0"/>
<par name="ImageRows" base_type="ctrl" dimension="0"/>
<par name="ImageCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**Create Coefficient</c>
<l>Coefficient := []</l>
<c></c>
<l>get_image_size (LightImage, Width, Height)</l>
<l>gen_rectangle1 (Rectangle, 0, 0, Height, Width)</l>
<l>get_region_points (Rectangle, ImageRows, ImageCols)</l>
<l>get_grayval (LightImage, ImageRows, ImageCols, Grayval)</l>
<c></c>
<c>**Normalize Light Image by removing bad white pixel and bad black pixel(0 &amp; 255 gray value pixel)</c>
<l>GrayvalNormalize := Grayval</l>
<l>BadWhitePixelIdx := find(Grayval, 255)</l>
<l>if(BadWhitePixelIdx[0] != -1)</l>
<l>    tuple_remove (Grayval, BadWhitePixelIdx, GrayvalNormalize)</l>
<l>endif</l>
<c></c>
<l>BadBlackPixelIdx := find(Grayval, 0)</l>
<l>if(BadBlackPixelIdx[0] != -1)</l>
<l>    tuple_remove (GrayvalNormalize, BadBlackPixelIdx, GrayvalNormalize)</l>
<l>endif</l>
<c></c>
<l>MaxGrayValue := max(GrayvalNormalize)</l>
<l>MinGrayValue := min(GrayvalNormalize)</l>
<c></c>
<l>tuple_gen_const (|Grayval|, 4194304, RandomMax)</l>
<l>tuple_gen_const (|Grayval|, MaxGrayValue, ActualMax)</l>
<c></c>
<l>Coefficient := (ActualMax*RandomMax*1.0)/Grayval</l>
<c></c>
<l>if(BadWhitePixelIdx[0] != -1)</l>
<l>    tuple_replace (Coefficient, BadWhitePixelIdx, 4194304, Coefficient)</l>
<l>endif</l>
<l>if(BadBlackPixelIdx[0] != -1)</l>
<l>    tuple_replace (Coefficient, BadBlackPixelIdx, 4194304, Coefficient)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Light_Coefficient_Inspect">
<parameters>
<parameter id="Coefficient"/>
<parameter id="ImageCols"/>
<parameter id="ImageRows"/>
<parameter id="LightImage"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Light_Correction">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="CorrectedImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Coefficient" base_type="ctrl" dimension="0"/>
<par name="ImageRows" base_type="ctrl" dimension="0"/>
<par name="ImageCols" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>**Correcting The Image</c>
<l>copy_image (Image, CorrectedImage)</l>
<l>if(|ImageRows| &lt;= 0 or |ImageCols| &lt;= 0 or |Coefficient| &lt;= 0 or \
    |ImageRows| != |ImageCols| or |ImageRows| != |Coefficient| or |ImageCols| != |Coefficient| )</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>get_grayval (Image, ImageRows, ImageCols, InspectImageGrayval)</l>
<c></c>
<l>* LightCorrectedGrayVal := ((InspectImageGrayval * Coefficient) + 2097152)/ pow(2,22)</l>
<l>LightCorrectedGrayVal := ((InspectImageGrayval * Coefficient) + 2097152)</l>
<l>tuple_round (LightCorrectedGrayVal, LightCorrectedGrayVal)</l>
<l>tuple_rsh(LightCorrectedGrayVal, 22, LightCorrectedGrayVal)</l>
<c></c>
<c></c>
<l>InvalidGrayValue := LightCorrectedGrayVal [&gt;] 255</l>
<l>InvalidIndex := find(InvalidGrayValue, 1)</l>
<l>tuple_replace (LightCorrectedGrayVal, InvalidIndex, 255, LightCorrectedGrayVal)</l>
<l>set_grayval (CorrectedImage, ImageRows, ImageCols, LightCorrectedGrayVal)</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_Light_Correction">
<parameters>
<parameter id="Coefficient"/>
<parameter id="CorrectedImage"/>
<parameter id="Image"/>
<parameter id="ImageCols"/>
<parameter id="ImageRows"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_LightCorrection">
<interface>
<io>
<par name="Image1" base_type="iconic" dimension="0"/>
<par name="Image2" base_type="iconic" dimension="0"/>
<par name="Image3" base_type="iconic" dimension="0"/>
<par name="Image4" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ResultantMaxImage" base_type="iconic" dimension="0"/>
<par name="TargetUniformImage" base_type="iconic" dimension="0"/>
<par name="LightCorrectionImage" base_type="iconic" dimension="0"/>
<par name="PositiveContrastImage" base_type="iconic" dimension="0"/>
<par name="NegativeContrastImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="TargetGrayValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>max_image(Image1, Image2, ImageMax)</l>
<l>max_image(Image3, Image4, ImageMax1)</l>
<l>max_image (ImageMax, ImageMax1, ResultantMaxImage)</l>
<c></c>
<l>get_image_size (ResultantMaxImage, Width, Height)</l>
<l>convert_image_type (ResultantMaxImage, ResultantMaxImage1, 'int2')</l>
<c></c>
<l>gen_image_proto (ResultantMaxImage, TargetUniformImage, TargetGrayValue)</l>
<l>convert_image_type (TargetUniformImage, TargetUniformImage1, 'int2')</l>
<c></c>
<c>***Light Correction Image</c>
<l>sub_image (TargetUniformImage1, ResultantMaxImage1 , LightCorrectionImage, 1, 0)</l>
<c></c>
<c>***Posive Contrast Value</c>
<l>convert_image_type (LightCorrectionImage, PositiveContrastImage, 'byte')</l>
<c></c>
<c></c>
<c>****Negative Contrast Value</c>
<l>invert_image (LightCorrectionImage, ImageInvert)</l>
<l>convert_image_type (ImageInvert, ImageInvert, 'byte')</l>
<l>sub_image (ImageInvert, PositiveContrastImage, NegativeContrastImage, 1, 0)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_LightCorrection">
<parameters>
<parameter id="Image1"/>
<parameter id="Image2"/>
<parameter id="Image3"/>
<parameter id="Image4"/>
<parameter id="LightCorrectionImage"/>
<parameter id="NegativeContrastImage"/>
<parameter id="PositiveContrastImage"/>
<parameter id="ResultantMaxImage"/>
<parameter id="TargetGrayValue"/>
<parameter id="TargetUniformImage"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Location_AutoTeach_ReadData">
<interface>
<ic>
<par name="posDTupleNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TeachLocDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (posDTupleNames, ['TeachLocDoc','ignore_case'], tupleTeachLocDoc) </l>
<l>tuple_regexp_select (posDTupleNames, ['NoOfLocationTeachRegs','ignore_case'], tupleNoOfLocationTeachRegs) </l>
<l>tuple_regexp_select (posDTupleNames, ['LocDeviceWidth','ignore_case'], tupleDeviceWidth)</l>
<l>tuple_regexp_select (posDTupleNames, ['LocDeviceHeight','ignore_case'], tupleDeviceHeight)</l>
<l>tuple_regexp_select (posDTupleNames, ['LocMinDeviceContrast','ignore_case'], tupleMinDeviceContrast)</l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['LocNoOfUniquePatterns','ignore_case'], tupleNoOfUniquePatterns)                                             </l>
<l>tuple_regexp_select (posDTupleNames, ['LocMaxRotationAngle','ignore_case'], tupleMaxRotationAngle)           </l>
<l>tuple_regexp_select (posDTupleNames, ['LocPatternSearchAreaAlongX','ignore_case'], tuplePatternSearchAreaAlongX)                     </l>
<l>tuple_regexp_select (posDTupleNames, ['LocPatternSearchAreaAlongY','ignore_case'], tuplePatternSearchAreaAlongY)           </l>
<l>tuple_regexp_select (posDTupleNames, ['LocMinAcceptanceScore','ignore_case'], tupleMinAcceptanceScore)</l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['LocPatternTeachRows','ignore_case'], tuplePatternTeachRows)           </l>
<l>tuple_regexp_select (posDTupleNames, ['LocPatternTeachCols','ignore_case'], tuplePatternTeachCols)                       </l>
<l>tuple_regexp_select (posDTupleNames, ['LocationTeachRows','ignore_case'], tupleLocationTeachRows)</l>
<l>tuple_regexp_select (posDTupleNames, ['LocationTeachCols','ignore_case'], tupleLocationTeachCols)           </l>
<c></c>
<l>tuple_regexp_select (posDTupleNames, ['LocModelIDs','ignore_case'], tupleModelIDs)</l>
<l>tuple_regexp_select (posDTupleNames, ['LocPatternDegree','ignore_case'], tuplePatternDegree)           </l>
<l>tuple_regexp_select (posDTupleNames, ['LocMatchModelCenterRow','ignore_case'], tupleMatchModelCenterRow)</l>
<l>tuple_regexp_select (posDTupleNames, ['LocMatchModelCenterColumn','ignore_case'], tupleMatchModelCenterColumn)           </l>
<l>tuple_regexp_select (posDTupleNames, ['LocMaskSize','ignore_case'], tupleLocMaskSize)           </l>
<c></c>
<c></c>
<l>read_tuple(tupleTeachLocDoc, TeachLocDoc)</l>
<l>read_tuple(tupleNoOfLocationTeachRegs, NoOfLocationTeachRegs)</l>
<l>read_tuple(tupleDeviceWidth, DeviceWidth)</l>
<l>read_tuple(tupleDeviceHeight, DeviceHeight)</l>
<l>read_tuple(tupleMinDeviceContrast, MinDeviceContrast)</l>
<c></c>
<l>read_tuple(tupleNoOfUniquePatterns, NoOfUniquePatterns)</l>
<l>read_tuple(tupleMaxRotationAngle, MaxRotationAngle)</l>
<l>read_tuple(tuplePatternSearchAreaAlongX, PatternSearchAreaAlongX)</l>
<l>read_tuple(tuplePatternSearchAreaAlongY, PatternSearchAreaAlongY)</l>
<l>read_tuple(tupleMinAcceptanceScore, MinAcceptanceScore)</l>
<c></c>
<l>read_tuple(tuplePatternTeachRows, PatternTeachRows)</l>
<l>read_tuple(tuplePatternTeachCols, PatternTeachCols)</l>
<l>read_tuple(tupleLocationTeachRows, LocationTeachRows)</l>
<l>read_tuple(tupleLocationTeachCols, LocationTeachCols)</l>
<c></c>
<l>read_tuple(tupleModelIDs, ModelIDs)</l>
<l>read_tuple(tuplePatternDegree, PatternDegree)</l>
<l>read_tuple(tupleMatchModelCenterRow, MatchModelCenterRow)</l>
<l>read_tuple(tupleMatchModelCenterColumn, MatchModelCenterColumn)</l>
<l>read_tuple(tupleLocMaskSize, MaskSize)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Location_AutoTeach_ReadData">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceWidth"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelCenterColumn"/>
<parameter id="MatchModelCenterRow"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelIDs"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternDegree"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
<parameter id="TeachLocDoc"/>
<parameter id="posDTupleNames"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_OffsetRegions">
<interface>
<io>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="Sub_Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionForPVI_InspectionOut" base_type="iconic" dimension="0"/>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="EdgeOffset" base_type="ctrl" dimension="0"/>
<par name="EdgeWidth" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
<par name="Bool" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>if(Bool = true)</l>
<l>    AreaMsg := ''</l>
<l>else</l>
<l>    AreaMsg := ['of Area['+(nPVIArea+1)+']']</l>
<l>endif</l>
<c></c>
<c></c>
<l>RegionForPVI_InspectionOut := RegionForPVI_Inspection</l>
<l>if(EdgeOffset&gt;0)</l>
<l>     erosion_circle (RegionForPVI_InspectionOut, RegionForPVI_InspectionOut, EdgeOffset)</l>
<l>     connection (RegionForPVI_InspectionOut, ConnectedRegions)</l>
<l>     select_shape_std (ConnectedRegions, RegionForPVI_InspectionOut, 'max_area', 70)</l>
<c></c>
<l>     if (IsStepMode)</l>
<l>          Message:=[' Edge region obtained using EdgeOffset ' + AreaMsg]</l>
<l>          _FCI_DebugParameters (Sub_Image, RegionForPVI_InspectionOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif </l>
<c>     </c>
<l>     if(EdgeWidth&gt;0)</l>
<l>          erosion_circle (RegionForPVI_InspectionOut, RegionErosion3, EdgeWidth)</l>
<l>          connection (RegionErosion3, ConnectedRegions1)</l>
<l>          select_shape_std (ConnectedRegions1, RegionErosion3, 'max_area', 70)</l>
<l>          difference (RegionForPVI_InspectionOut, RegionErosion3, RegionForPVI_InspectionOut)</l>
<c>    </c>
<l>       if (IsStepMode)</l>
<l>          Message:=[' Edge region obtained using EdgeWidth' + AreaMsg]</l>
<l>          _FCI_DebugParameters (Sub_Image, RegionForPVI_InspectionOut, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif </l>
<c>     </c>
<l>     endif   </l>
<c>     </c>
<l>     reduce_domain (Sub_Image, RegionForPVI_InspectionOut, ImageForPVI_Inspection)</l>
<l>else </l>
<l>     reduce_domain (Sub_Image, RegionForPVI_InspectionOut, ImageForPVI_Inspection)</l>
<l>endif </l>
<l>return ()</l>
</body>
<docu id="_FCI_OffsetRegions">
<parameters>
<parameter id="Bool"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="EdgeOffset"/>
<parameter id="EdgeWidth"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="IsStepMode"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="RegionForPVI_InspectionOut"/>
<parameter id="Sub_Image"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_PVI_CheckingSlot">
<interface>
<io>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="Defect_Region" base_type="iconic" dimension="0"/>
<par name="SlotRegions" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ActualPVIDefect" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
<par name="RotationAngle" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="ShiftAlongCol" base_type="ctrl" dimension="0"/>
<par name="ConnectionCheckTopSide" base_type="ctrl" dimension="0"/>
<par name="ConnectionCheckBottomSide" base_type="ctrl" dimension="0"/>
<par name="ConnectionCheckLeftSide" base_type="ctrl" dimension="0"/>
<par name="ConnectionCheckRightSide" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_empty_obj (ActualPVIDefect)</l>
<l>gen_empty_obj(DebugImageOut)</l>
<l>gen_empty_obj(DebugRegionOut)</l>
<l>IsPass := true</l>
<l>DebugMessageOut := []</l>
<c></c>
<c>****Project On Inspect Image: Method 1</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -RotationAngle, DeviceCenterRow, DeviceCenterColumn, HomMat2DRotate)</l>
<l>hom_mat2d_translate (HomMat2DRotate, -ShiftAlongRow, -ShiftAlongCol, HomMat2DTranslate)</l>
<l>affine_trans_region (SlotRegions, ProjectedSlotRegions, HomMat2DTranslate, 'nearest_neighbor')</l>
<c></c>
<l>smallest_rectangle1 (RegionForPVI_Inspection, PVIRegionRow1, PVIRegionCol1, PVIRegionRow2, PVIRegionCol2)</l>
<c></c>
<l>gen_empty_obj(PVISideRegions)</l>
<l>if(ConnectionCheckTopSide)</l>
<l>    gen_region_line (TopSideRegionLine, PVIRegionRow1, PVIRegionCol1, PVIRegionRow1, PVIRegionCol2)</l>
<l>    concat_obj (ProjectedSlotRegions, TopSideRegionLine, ProjectedSlotRegions)</l>
<l>    concat_obj (PVISideRegions, TopSideRegionLine, PVISideRegions)</l>
<l>endif</l>
<l>if(ConnectionCheckBottomSide)</l>
<l>    gen_region_line (BottomSideRegionLine, PVIRegionRow2, PVIRegionCol1, PVIRegionRow2, PVIRegionCol2)</l>
<l>    concat_obj (ProjectedSlotRegions, BottomSideRegionLine, ProjectedSlotRegions)</l>
<l>    concat_obj (PVISideRegions, BottomSideRegionLine, PVISideRegions)</l>
<l>endif</l>
<l>if(ConnectionCheckLeftSide)</l>
<l>    gen_region_line (LeftSideRegionLine, PVIRegionRow1, PVIRegionCol1, PVIRegionRow2, PVIRegionCol1)</l>
<l>    concat_obj (ProjectedSlotRegions, LeftSideRegionLine, ProjectedSlotRegions)</l>
<l>    concat_obj (PVISideRegions, LeftSideRegionLine, PVISideRegions)</l>
<l>endif</l>
<l>if(ConnectionCheckRightSide)</l>
<l>    gen_region_line (RightSideRegionLine, PVIRegionRow1, PVIRegionCol2, PVIRegionRow2, PVIRegionCol2)</l>
<l>    concat_obj (ProjectedSlotRegions, RightSideRegionLine, ProjectedSlotRegions)</l>
<l>    concat_obj (PVISideRegions, RightSideRegionLine, PVISideRegions)</l>
<l>endif</l>
<c></c>
<c>* Step Debug </c>
<l>if(IsStepMode)</l>
<l>  Message := ['Project Slot Locations To Check Connected Defect Between Slots']</l>
<c></c>
<l>  _FCI_DebugParameters (InspectImage, ProjectedSlotRegions, DebugImageOut, DebugRegionOut, \
                              DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif</l>
<c></c>
<l>count_obj (ProjectedSlotRegions, SlotRegionsCount)</l>
<l>connection (Defect_Region, Defect_Region)</l>
<l>count_obj (Defect_Region, Defect_RegionCount)</l>
<l>tuple_gen_const (Defect_RegionCount, 0, ConnectedCounts)</l>
<l>for Index:=1 to SlotRegionsCount by 1</l>
<l>    select_obj (ProjectedSlotRegions, ObjectSelected, Index)</l>
<l>    intersection (Defect_Region, ObjectSelected , RegionIntersection)</l>
<l>    region_features (RegionIntersection, 'area', Area)</l>
<l>    IsIntersection := Area [&gt;] 0</l>
<l>    tuple_add (ConnectedCounts, IsIntersection, ConnectedCounts)</l>
<l>endfor</l>
<l>IsConnectedSlot := ConnectedCounts [&gt;=] 2</l>
<l>tuple_find (IsConnectedSlot, 1, Indices)</l>
<l>if(Indices[0] &gt;= 0)</l>
<l>    select_obj (Defect_Region, ActualPVIDefect, Indices+1)</l>
<l>    count_obj (ActualPVIDefect, ActualPVIDefectCount)</l>
<c>    </c>
<c>    ** Ignore the case that defect is connecting from the side to the side (Ex: From Top To Left, Top To Bottom, ...)</c>
<l>    count_obj(PVISideRegions, PVISideRegionsCount)</l>
<l>    if(PVISideRegionsCount &gt; 1)</l>
<l>        tuple_gen_const (ActualPVIDefectCount, 0, ConnectedCounts)</l>
<l>        for Index:=1 to PVISideRegionsCount by 1</l>
<l>            select_obj (PVISideRegions, ObjectSelected, Index)</l>
<l>            intersection (ActualPVIDefect, ObjectSelected , RegionIntersection)</l>
<l>            region_features (RegionIntersection, 'area', Area)</l>
<l>            IsIntersection := Area [&gt;] 0</l>
<l>            tuple_add (ConnectedCounts, IsIntersection, ConnectedCounts)</l>
<l>        endfor</l>
<l>        IsConnectedSides := ConnectedCounts [&gt;=] 2</l>
<l>        tuple_find (IsConnectedSides, 0, Indices)</l>
<l>        if(Indices[0] &gt;= 0)</l>
<l>            select_obj (ActualPVIDefect, ActualPVIDefect, Indices+1)</l>
<l>            count_obj (ActualPVIDefect, ActualPVIDefectCount)</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>   if(ActualPVIDefectCount &gt; 0)</l>
<l>       IsPass := false</l>
<l>   endif</l>
<c>    </c>
<c>   * Step Debug </c>
<l>   if(IsStepMode)</l>
<l>       Message := ['Final Linked Slots Defect']</l>
<c>    </c>
<l>       _FCI_DebugParameters (InspectImage, ActualPVIDefect, DebugImageOut, DebugRegionOut, \
                            DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>   endif</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_PVI_CheckingSlot">
<parameters>
<parameter id="ActualPVIDefect"/>
<parameter id="ConnectionCheckBottomSide"/>
<parameter id="ConnectionCheckLeftSide"/>
<parameter id="ConnectionCheckRightSide"/>
<parameter id="ConnectionCheckTopSide"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="Defect_Region"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="InspectImage"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="RotationAngle"/>
<parameter id="ShiftAlongCol"/>
<parameter id="ShiftAlongRow"/>
<parameter id="SlotRegions"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_PVI_Inspection">
<interface>
<io>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="PVI_DefectRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DefectCharacteristics" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
<par name="MinLength" base_type="ctrl" dimension="0"/>
<par name="MinSize" base_type="ctrl" dimension="0"/>
<par name="MinSquareSize" base_type="ctrl" dimension="0"/>
<par name="MinCount" base_type="ctrl" dimension="0"/>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="IntensityIndex" base_type="ctrl" dimension="0"/>
<par name="DefectCount" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
<par name="Bool" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**************************</c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<c></c>
<l>IsPass:=true</l>
<l>gen_empty_obj (PVI_DefectRegion)</l>
<l>gen_empty_obj (ConcatDefect)</l>
<c></c>
<c></c>
<c></c>
<c>****</c>
<l>if(Bool = true)</l>
<l>    AreaMsg := 'Device Edge'</l>
<l>else</l>
<l>    AreaMsg := [ 'Defect['+(DefectCount)+'] of Area['+(nPVIArea+1)+']']</l>
<l>endif</l>
<c></c>
<c></c>
<l>threshold (ImageForPVI_Inspection, Region1, Contrast, 255)</l>
<c></c>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=[' Initial segmentation of the ' + AreaMsg]</l>
<l>     _FCI_DebugParameters (ImageForPVI_Inspection, Region1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>connection (Region1, ConnectedRegions1)</l>
<l>fill_up (ConnectedRegions1, RegionFillUp1)</l>
<l>select_shape (RegionFillUp1, SelectedRegions1, ['max_diameter','area'], 'and', [MinLength,MinSize], [99999,99999])</l>
<c></c>
<l>if (IsStepMode)</l>
<l>     Message:=[' Selection Region using MinLength and MinSize of the ' + AreaMsg]</l>
<l>     _FCI_DebugParameters (ImageForPVI_Inspection, SelectedRegions1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>count_obj (SelectedRegions1, NumberFirstSelection)</l>
<c></c>
<l>if(NumberFirstSelection&gt;0)</l>
<l>     smallest_rectangle1 (SelectedRegions1, Row1, Column1, Row2, Column2)</l>
<l>     gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)</l>
<l>     select_shape (Rectangle, SelectedRegions2, ['height','width'], 'and', [MinSquareSize,MinSquareSize], [99999,99999])</l>
<c>     </c>
<l>     if (IsStepMode)</l>
<l>          Message:=[' Selection Region using MinSquareSize of the ' + AreaMsg]</l>
<l>          _FCI_DebugParameters (ImageForPVI_Inspection, SelectedRegions2, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>     endif</l>
<c>     ******* Recheck to eliminate defect in teach *****</c>
<l>*      reduce_domain (InspectImage, RegionForPVI_Inspection, ImageReduced)</l>
<c>     </c>
<l>*      dilation_circle (SelectedRegions1, RegionDilation, 5.5)</l>
<l>*      min_max_gray (RegionDilation, ImageReduced, 0, Min, Max, Range)</l>
<l>*      tuple_length (Min, Length)</l>
<l>*      tuple_gen_const (Length, Contrast, Newtuple)</l>
<l>*      intensity (SelectedRegions1, ImageReduced, Mean, Deviation)</l>
<c>     </c>
<l>*      if(DefectCharacteristics=0)</l>
<l>*           tuple_sub (Max, Newtuple, Difference)</l>
<l>*           tuple_less_elem (Mean, Difference, Less)</l>
<c>          </c>
<l>*           tuple_find (Less, 0, Indices)</l>
<l>*           if(Indices#-1)</l>
<l>*                select_obj (SelectedRegions1, ObjectSelected, Indices+1)</l>
<l>*                difference (SelectedRegions1, ObjectSelected, ActualInspectedDefects)</l>
<l>*                area_center (ActualInspectedDefects, Area, Row3, Column3)</l>
<l>*                tuple_greater_elem (Area, 0, Greater1)</l>
<l>*                tuple_find (Greater1, 1, Indices1)</l>
<l>*                tuple_select (Area, Indices1, Selected)</l>
<l>*                select_obj (ActualInspectedDefects, ActualInspectedDefects, Indices1+1)</l>
<l>*           endif </l>
<l>*      else</l>
<l>*           tuple_add (Min, Newtuple, Difference)</l>
<l>*           tuple_greater_elem (Mean, Difference, Greater)</l>
<l>*           tuple_find (Greater, 0, Indices)</l>
<l>*           if(Indices#-1)</l>
<l>*                select_obj (SelectedRegions1, ObjectSelected, Indices+1)</l>
<l>*                difference (SelectedRegions1, ObjectSelected, ActualInspectedDefects)</l>
<l>*                area_center (ActualInspectedDefects, Area, Row3, Column3)</l>
<l>*                tuple_greater_elem (Area, 0, Greater1)</l>
<l>*                tuple_find (Greater1, 1, Indices1)</l>
<l>*                tuple_select (Area, Indices1, Selected)</l>
<l>*                select_obj (ActualInspectedDefects, ActualInspectedDefects, Indices1+1)</l>
<l>*           endif </l>
<l>*      endif</l>
<c></c>
<l>     count_obj (SelectedRegions2, DefectNumber)</l>
<l>     if(DefectNumber&gt;=MinCount)  </l>
<c>          </c>
<l>          IsPass := false </l>
<l>*           intersection (SelectedRegions2, SelectedRegions1, RegionIntersection)</l>
<l>*           union1 (RegionIntersection, RegionUnion)</l>
<l>*           connection (RegionUnion, ConnectedRegions)</l>
<l>*           smallest_rectangle2 (ConnectedRegions, Row, Column, Phi, Length1, Length2)</l>
<l>*           gen_rectangle2 (PVI_DefectRegion, Row, Column, Phi, Length1, Length2)</l>
<l>          PVI_DefectRegion:=SelectedRegions1</l>
<l>          if (IsStepMode)</l>
<l>              if(Bool = true)</l>
<l>                  Message:=[' Device Edge Defect Regions']</l>
<l>              else</l>
<l>                  Message:= ['PVI ' + AreaMsg + 'Regions']</l>
<c>                  </c>
<l>              endif</l>
<l>               _FCI_DebugParameters (InspectImage, PVI_DefectRegion, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>          endif </l>
<l>     endif</l>
<l>endif    </l>
<c></c>
<c></c>
<c>   </c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_PVI_Inspection">
<parameters>
<parameter id="Bool"/>
<parameter id="Contrast"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectCharacteristics"/>
<parameter id="DefectCount"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="InspectImage"/>
<parameter id="IntensityIndex"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinCount"/>
<parameter id="MinLength"/>
<parameter id="MinSize"/>
<parameter id="MinSquareSize"/>
<parameter id="PVI_DefectRegion"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Region_AutoTeach_ReadData">
<interface>
<ic>
<par name="SingleAreaTeachTuple" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="PVI2DCenter" base_type="ctrl" dimension="0"/>
<par name="PVISize" base_type="ctrl" dimension="0"/>
<par name="Mask2DCenterPoints" base_type="ctrl" dimension="0"/>
<par name="MaskAngleConcat" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['NumOfMask','ignore_case'], tupleNoOfMask)</l>
<c></c>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['PVIAngle','ignore_case'], tuplePVIAngle)           </l>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['PVI2DCenter','ignore_case'], tuplePVI2DCenter)</l>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['PVISize','ignore_case'], tuplePVISize)   </l>
<c></c>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['Mask2DCenterPoints','ignore_case'], tupleMask2DCenterPoints)           </l>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['MaskAngleConcat','ignore_case'], tupleMaskAngleConcat)           </l>
<l>tuple_regexp_select (SingleAreaTeachTuple, ['MaskSize','ignore_case'], tupleMaskSize)           </l>
<c></c>
<c></c>
<l>read_tuple (tupleNoOfMask, NoOfMaskRegions)</l>
<l>read_tuple (tuplePVIAngle, PVIAngle)</l>
<l>read_tuple (tuplePVI2DCenter, PVI2DCenter)</l>
<l>read_tuple (tuplePVISize, PVISize)</l>
<c></c>
<l>read_tuple (tupleMask2DCenterPoints,Mask2DCenterPoints )</l>
<l>read_tuple (tupleMaskAngleConcat,MaskAngleConcat )</l>
<l>read_tuple (tupleMaskSize,MaskSize )</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Region_AutoTeach_ReadData">
<parameters>
<parameter id="Mask2DCenterPoints"/>
<parameter id="MaskAngleConcat"/>
<parameter id="MaskSize"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="PVI2DCenter"/>
<parameter id="PVIAngle"/>
<parameter id="PVISize"/>
<parameter id="SingleAreaTeachTuple"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_RegionInspection">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="FitGeneratedPVIRegion" base_type="iconic" dimension="0"/>
<par name="UnionPVIMaskRegion" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="LocationCenterRow" base_type="ctrl" dimension="0"/>
<par name="LocationCenterColumn" base_type="ctrl" dimension="0"/>
<par name="LocationEdgePoint" base_type="ctrl" dimension="0"/>
<par name="PVIAreaCenterRow" base_type="ctrl" dimension="0"/>
<par name="PVIAreaCenterColumn" base_type="ctrl" dimension="0"/>
<par name="PVITeachRows" base_type="ctrl" dimension="0"/>
<par name="PVITeachColumns" base_type="ctrl" dimension="0"/>
<par name="PVItoEdge_X_Shift" base_type="ctrl" dimension="0"/>
<par name="PVItoEdge_Y_Shift" base_type="ctrl" dimension="0"/>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="PVIMaskCenterRows" base_type="ctrl" dimension="0"/>
<par name="PVIMaskCenterColumns" base_type="ctrl" dimension="0"/>
<par name="PVIMaskRows" base_type="ctrl" dimension="0"/>
<par name="PVIMaskColumns" base_type="ctrl" dimension="0"/>
<par name="PVIMasktoEdge_X_Shift" base_type="ctrl" dimension="0"/>
<par name="PVIMasktoEdge_Y_Shift" base_type="ctrl" dimension="0"/>
<par name="AngleOfDeviation" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceRow" base_type="ctrl" dimension="0"/>
<par name="MidInspectDeviceColumn" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>dev_display(Image)</l>
<l>gen_rectangle1 (GeneratedPVIRegion, PVITeachRows[0], PVITeachColumns[0], PVITeachRows[1], PVITeachColumns[1])</l>
<c></c>
<l>GeneratedPVIRegionRow := PVIAreaCenterRow</l>
<l>GeneratedPVIRegionColumn := PVIAreaCenterColumn</l>
<c></c>
<c>****Fit the region in the given image</c>
<l>if(FoV = 1 or FoV = nFoVs)</l>
<l>    vector_angle_to_rigid (GeneratedPVIRegionRow, GeneratedPVIRegionColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, -rad(AngleOfDeviation), PVIRegionHomMat2D)</l>
<l>    hom_mat2d_translate_local(PVIRegionHomMat2D, -PVItoEdge_X_Shift, -PVItoEdge_Y_Shift, PVIRegionHomMat2DTranslate)</l>
<l>    affine_trans_region (GeneratedPVIRegion, FitGeneratedPVIRegion, PVIRegionHomMat2DTranslate, 'nearest_neighbor')</l>
<l>else</l>
<l>    vector_angle_to_rigid (GeneratedPVIRegionRow, GeneratedPVIRegionColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, rad(AngleOfDeviation), PVIRegionHomMat2D)</l>
<l>    hom_mat2d_translate_local(PVIRegionHomMat2D, -PVItoEdge_X_Shift, -PVItoEdge_Y_Shift, PVIRegionHomMat2DTranslate)</l>
<l>    affine_trans_region (GeneratedPVIRegion, FitGeneratedPVIRegion, PVIRegionHomMat2DTranslate, 'nearest_neighbor')</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>dev_display(Image)</l>
<l>dev_display(FitGeneratedPVIRegion)</l>
<c></c>
<c>****Fit Masks in the given image</c>
<l>gen_empty_obj(PVIMaskRegion)</l>
<l>for maskIndex := 0 to NoOfMaskRegions-1 by 1</l>
<c>    </c>
<l>    SelectedMaskRows := PVIMaskRows[2*maskIndex: 2*(maskIndex+1)-1]</l>
<l>    SelectedMaskCols := PVIMaskColumns[2*maskIndex: 2*(maskIndex+1)-1]</l>
<l>    SelectMaskCenterRow := PVIMaskCenterRows[maskIndex]</l>
<l>    SelectMaskCenterColumn := PVIMaskCenterColumns[maskIndex]</l>
<l>    SelectedMasK_X_Shift := PVIMasktoEdge_X_Shift[maskIndex]</l>
<l>    SelectedMasK_Y_Shift := PVIMasktoEdge_Y_Shift[maskIndex]</l>
<c> </c>
<l>    gen_rectangle1 (GeneratedMaskRegion, SelectedMaskRows[0], SelectedMaskCols[0], SelectedMaskRows[1], SelectedMaskCols[1]) </l>
<c>    </c>
<l>    GeneratedMaskRegionCenterRow := SelectMaskCenterRow</l>
<l>    GeneratedMaskRegionCenterColumn := SelectMaskCenterColumn</l>
<l>    if(FoV = 1 or FoV = nFoVs)</l>
<l>        vector_angle_to_rigid (GeneratedMaskRegionCenterRow, GeneratedMaskRegionCenterColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, -rad(AngleOfDeviation), MaskRegionHomMat2D)</l>
<l>        hom_mat2d_translate_local (MaskRegionHomMat2D, -SelectedMasK_X_Shift, -SelectedMasK_Y_Shift, MaskRegionHomMat2DTranslate)</l>
<l>        affine_trans_region (GeneratedMaskRegion, FitGeneratedMaskRegion, MaskRegionHomMat2DTranslate, 'nearest_neighbor')</l>
<l>    else</l>
<l>        vector_angle_to_rigid (GeneratedMaskRegionCenterRow, GeneratedMaskRegionCenterColumn, 0, MidInspectDeviceRow, MidInspectDeviceColumn, rad(AngleOfDeviation), MaskRegionHomMat2D)</l>
<l>        hom_mat2d_translate_local (MaskRegionHomMat2D, -SelectedMasK_X_Shift, -SelectedMasK_Y_Shift, MaskRegionHomMat2DTranslate)</l>
<l>        affine_trans_region (GeneratedMaskRegion, FitGeneratedMaskRegion, MaskRegionHomMat2DTranslate, 'nearest_neighbor')    </l>
<l>    endif</l>
<l>    concat_obj(PVIMaskRegion, FitGeneratedMaskRegion, PVIMaskRegion)</l>
<l>endfor</l>
<c></c>
<l>union1(PVIMaskRegion, UnionPVIMaskRegion)</l>
<l>dev_display(Image)</l>
<l>dev_display(UnionPVIMaskRegion)</l>
<c>**********</c>
<c></c>
<c>****Fit Region Display</c>
<l>dev_display(Image)</l>
<l>dev_display(FitGeneratedPVIRegion)</l>
<l>dev_display(UnionPVIMaskRegion)</l>
<c></c>
<c>*****Reduced Image and Region without mask</c>
<c></c>
<l>difference(FitGeneratedPVIRegion, UnionPVIMaskRegion, RegionForPVI_Inspection)</l>
<l>reduce_domain(Image, RegionForPVI_Inspection, ImageForPVI_Inspection)</l>
<c></c>
<l>return()</l>
<c></c>
</body>
<docu id="_FCI_RegionInspection">
<parameters>
<parameter id="AngleOfDeviation"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="FitGeneratedPVIRegion"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="IsStepMode"/>
<parameter id="LocationCenterColumn"/>
<parameter id="LocationCenterRow"/>
<parameter id="LocationEdgePoint"/>
<parameter id="MidInspectDeviceColumn"/>
<parameter id="MidInspectDeviceRow"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="PVIAreaCenterColumn"/>
<parameter id="PVIAreaCenterRow"/>
<parameter id="PVIMaskCenterColumns"/>
<parameter id="PVIMaskCenterRows"/>
<parameter id="PVIMaskColumns"/>
<parameter id="PVIMaskRows"/>
<parameter id="PVIMasktoEdge_X_Shift"/>
<parameter id="PVIMasktoEdge_Y_Shift"/>
<parameter id="PVITeachColumns"/>
<parameter id="PVITeachRows"/>
<parameter id="PVItoEdge_X_Shift"/>
<parameter id="PVItoEdge_Y_Shift"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="UnionPVIMaskRegion"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Save_TeachParameters">
<interface>
<ic>
<par name="TeachLocDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>write_tuple (TeachLocDoc, TeachDocPath+'pos'+FoV+'_'+'TeachLocDoc')</l>
<l>write_tuple (NoOfLocationTeachRegs, TeachDocPath+'pos'+FoV+'_'+'NoOfLocationTeachRegs')</l>
<l>write_tuple (DeviceWidth, TeachDocPath+'pos'+FoV+'_'+'LocDeviceWidth')</l>
<l>write_tuple (DeviceHeight, TeachDocPath+'pos'+FoV+'_'+'LocDeviceHeight')</l>
<l>write_tuple (MinDeviceContrast, TeachDocPath+'pos'+FoV+'_'+'LocMinDeviceContrast')</l>
<c></c>
<l>write_tuple (NoOfUniquePatterns, TeachDocPath+'pos'+FoV+'_'+'LocNoOfUniquePatterns')</l>
<l>write_tuple (MaxRotationAngle, TeachDocPath+'pos'+FoV+'_'+'LocMaxRotationAngle')                </l>
<l>write_tuple (PatternSearchAreaAlongX, TeachDocPath+'pos'+FoV+'_'+'LocPatternSearchAreaAlongX')</l>
<l>write_tuple (PatternSearchAreaAlongY, TeachDocPath+'pos'+FoV+'_'+'LocPatternSearchAreaAlongY')</l>
<l>write_tuple (MinAcceptanceScore, TeachDocPath+'pos'+FoV+'_'+'LocMinAcceptanceScore')</l>
<c></c>
<l>write_tuple (PatternTeachRectRows, TeachDocPath+'pos'+FoV+'_'+'LocPatternTeachRows')</l>
<l>write_tuple (PatternTeachRectCols, TeachDocPath+'pos'+FoV+'_'+'LocPatternTeachCols')</l>
<l>write_tuple (LocationTeachRectRows, TeachDocPath+'pos'+FoV+'_'+'LocationTeachRows')</l>
<l>write_tuple (LocationTeachRectCols, TeachDocPath+'pos'+FoV+'_'+'LocationTeachCols')</l>
<c></c>
<l>write_tuple (ModelIDs, TeachDocPath+'pos'+FoV+'_'+'LocModelIDs')</l>
<l>write_tuple (PatternDegree, TeachDocPath+'pos'+FoV+'_'+'LocPatternDegree')</l>
<l>write_tuple (MatchModelCenterRow, TeachDocPath+'pos'+FoV+'_'+'LocMatchModelCenterRow')</l>
<l>write_tuple (MatchModelCenterColumn, TeachDocPath+'pos'+FoV+'_'+'LocMatchModelCenterColumn')</l>
<c></c>
<l>write_tuple (MaskSize, TeachDocPath+'pos'+FoV+'_'+'LocMaskSize')</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Save_TeachParameters">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceWidth"/>
<parameter id="FoV"/>
<parameter id="LocationTeachRectCols"/>
<parameter id="LocationTeachRectRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelCenterColumn"/>
<parameter id="MatchModelCenterRow"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelIDs"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternDegree"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachRectCols"/>
<parameter id="PatternTeachRectRows"/>
<parameter id="TeachDocPath"/>
<parameter id="TeachLocDoc"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SaveCVLAlignmentParameter">
<interface>
<ic>
<par name="CVLAlignmentTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLARect" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLAModelIDs" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLATeachCols" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLADatum" base_type="ctrl" dimension="0"/>
<par name="CVLADatumModelID" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachCols" base_type="ctrl" dimension="0"/>
<par name="CVLARefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointColumn" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLArectFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRowsFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachColsFL" base_type="ctrl" dimension="0"/>
<par name="MaxDistanceBtnCLFL" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>write_tuple (CVLAlignmentTeachDoc, TeachDocPath+'pos'+FoV+'_'+'CVLAlignmentTeachDoc')</l>
<c></c>
<l>write_tuple (NoOfCVLARect, TeachDocPath+'pos'+FoV+'_'+'NoOfCVLARect')</l>
<l>write_tuple (MaxRotationAngle, TeachDocPath+'pos'+FoV+'_'+'CVLAMaxRotationAngle')</l>
<l>write_tuple (PatternSearchAreaAlongX, TeachDocPath+'pos'+FoV+'_'+'CVLAPatternSearchAreaAlongX')</l>
<l>write_tuple (PatternSearchAreaAlongY, TeachDocPath+'pos'+FoV+'_'+'CVLAPatternSearchAreaAlongY')</l>
<l>write_tuple (MinAcceptanceScore, TeachDocPath+'pos'+FoV+'_'+'CVLAMinAcceptanceScore')</l>
<l>write_tuple (CVLAModelIDs, TeachDocPath+'pos'+FoV+'_'+'CVLAModelIDs')</l>
<l>write_tuple (CVLATeachRows, TeachDocPath+'pos'+FoV+'_'+'CVLATeachRows')</l>
<l>write_tuple (CVLATeachCols, TeachDocPath+'pos'+FoV+'_'+'CVLATeachCols')</l>
<c></c>
<l>write_tuple (NoOfCVLADatum, TeachDocPath+'pos'+FoV+'_'+'NoOfCVLADatum')</l>
<l>write_tuple (CVLADatumModelID, TeachDocPath+'pos'+FoV+'_'+'CVLADatumModelID')</l>
<l>write_tuple (CVLADatumTeachRows, TeachDocPath+'pos'+FoV+'_'+'CVLADatumTeachRows')</l>
<l>write_tuple (CVLADatumTeachCols, TeachDocPath+'pos'+FoV+'_'+'CVLADatumTeachCols')</l>
<c></c>
<l>write_tuple (CVLARefRotationAngle, TeachDocPath+'pos'+FoV+'_'+'CVLARefRotationAngle')</l>
<l>write_tuple (CVLARefPointRow, TeachDocPath+'pos'+FoV+'_'+'CVLARefPointRow')</l>
<l>write_tuple (CVLARefPointColumn, TeachDocPath+'pos'+FoV+'_'+'CVLARefPointColumn')</l>
<c></c>
<l>write_tuple (NoOfCVLArectFL, TeachDocPath+'pos'+FoV+'_'+'NoOfCVLArectFL')</l>
<l>write_tuple (CVLATeachRowsFL, TeachDocPath+'pos'+FoV+'_'+'CVLATeachRowsFL')</l>
<l>write_tuple (CVLATeachColsFL, TeachDocPath+'pos'+FoV+'_'+'CVLATeachColsFL')</l>
<c></c>
<l>write_tuple (MaxDistanceBtnCLFL, TeachDocPath+'pos'+FoV+'_'+'MaxDistanceBtnCLFL')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_SaveCVLAlignmentParameter">
<parameters>
<parameter id="CVLADatumModelID"/>
<parameter id="CVLADatumTeachCols"/>
<parameter id="CVLADatumTeachRows"/>
<parameter id="CVLAModelIDs"/>
<parameter id="CVLARefPointColumn"/>
<parameter id="CVLARefPointRow"/>
<parameter id="CVLARefRotationAngle"/>
<parameter id="CVLATeachCols"/>
<parameter id="CVLATeachColsFL"/>
<parameter id="CVLATeachRows"/>
<parameter id="CVLATeachRowsFL"/>
<parameter id="CVLAlignmentTeachDoc"/>
<parameter id="FoV"/>
<parameter id="MaxDistanceBtnCLFL"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="NoOfCVLADatum"/>
<parameter id="NoOfCVLARect"/>
<parameter id="NoOfCVLArectFL"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="TeachDocPath"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SaveCVLParameter">
<interface>
<ic>
<par name="CVLTeachDoc" base_type="ctrl" dimension="0"/>
<par name="NoOfRegions" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnRows" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnCols" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
<par name="CVLRefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLRefPointColumn" base_type="ctrl" dimension="0"/>
<par name="CVLContrast" base_type="ctrl" dimension="0"/>
<par name="CVLLength" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="MinCVLHeight" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>write_tuple (CVLTeachDoc, TeachDocPath+'pos'+FoV+'_'+'CVLTeachDoc')</l>
<l>write_tuple (NoOfRegions, TeachDocPath+'pos'+FoV+'_'+'NoOfRegions')</l>
<l>write_tuple (CVLRectRgnRows, TeachDocPath+'pos'+FoV+'_'+'CVLRectRgnRows')</l>
<l>write_tuple (CVLRectRgnCols, TeachDocPath+'pos'+FoV+'_'+'CVLRectRgnCols')</l>
<c></c>
<l>write_tuple (NoOfUniquePatterns, TeachDocPath+'pos'+FoV+'_'+'CVLNoOfUniquePatterns')</l>
<l>write_tuple (MaxRotationAngle, TeachDocPath+'pos'+FoV+'_'+'CVLMaxRotationAngle')</l>
<l>write_tuple (PatternSearchAreaAlongX, TeachDocPath+'pos'+FoV+'_'+'CVLPatternSearchAreaAlongX')</l>
<l>write_tuple (PatternSearchAreaAlongY, TeachDocPath+'pos'+FoV+'_'+'CVLPatternSearchAreaAlongY')</l>
<l>write_tuple (MinAcceptanceScore, TeachDocPath+'pos'+FoV+'_'+'CVLMinAcceptanceScore')</l>
<l>write_tuple (CVLDatumRows, TeachDocPath+'pos'+FoV+'_'+'CVLDatumRows')</l>
<l>write_tuple (CVLDatumCols, TeachDocPath+'pos'+FoV+'_'+'CVLDatumCols')</l>
<l>write_tuple (CVLModelID, TeachDocPath+'pos'+FoV+'_'+'CVLModelID')</l>
<c></c>
<l>write_tuple (CVLRefRotationAngle, TeachDocPath+'pos'+FoV+'_'+'CVLRefRotationAngle')</l>
<l>write_tuple (CVLRefPointRow, TeachDocPath+'pos'+FoV+'_'+'CVLRefPointRow')</l>
<l>write_tuple (CVLRefPointColumn, TeachDocPath+'pos'+FoV+'_'+'CVLRefPointColumn')</l>
<c></c>
<l>write_tuple (CVLContrast, TeachDocPath+'pos'+FoV+'_'+'CVLContrast')</l>
<l>write_tuple (CVLLength, TeachDocPath+'pos'+FoV+'_'+'CVLLength')</l>
<l>write_tuple (MaskSize, TeachDocPath+'pos'+FoV+'_'+'CVLMaskSize')</l>
<l>write_tuple (MinCVLHeight, TeachDocPath+'pos'+FoV+'_'+'CVLMinCVLHeight')</l>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_SaveCVLParameter">
<parameters>
<parameter id="CVLContrast"/>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLLength"/>
<parameter id="CVLModelID"/>
<parameter id="CVLRectRgnCols"/>
<parameter id="CVLRectRgnRows"/>
<parameter id="CVLRefPointColumn"/>
<parameter id="CVLRefPointRow"/>
<parameter id="CVLRefRotationAngle"/>
<parameter id="CVLTeachDoc"/>
<parameter id="FoV"/>
<parameter id="MaskSize"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinCVLHeight"/>
<parameter id="NoOfRegions"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="TeachDocPath"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SaveEncapParameter">
<interface>
<ic>
<par name="EncapTeachDoc" base_type="ctrl" dimension="0"/>
<par name="MinEncapContrast" base_type="ctrl" dimension="0"/>
<par name="MaxEncapContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfEncapRect4EncapLoc" base_type="ctrl" dimension="0"/>
<par name="EncapRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapRectCols" base_type="ctrl" dimension="0"/>
<par name="NoOfRectangle4EncapInsp" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>write_tuple (EncapTeachDoc, TeachDocPath+'pos'+FoV+'_'+'EncapTeachDoc')</l>
<l>write_tuple (MinEncapContrast, TeachDocPath+'pos'+FoV+'_'+'MinEncapContrast')</l>
<l>write_tuple (MaxEncapContrast, TeachDocPath+'pos'+FoV+'_'+'MaxEncapContrast')</l>
<c></c>
<l>write_tuple (NoOfEncapRect4EncapLoc, TeachDocPath+'pos'+FoV+'_'+'NoOfEncapRect4EncapLoc')</l>
<l>write_tuple (EncapRectRows, TeachDocPath+'pos'+FoV+'_'+'EncapRectRows')</l>
<l>write_tuple (EncapRectCols, TeachDocPath+'pos'+FoV+'_'+'EncapRectCols')</l>
<c></c>
<l>write_tuple (NoOfRectangle4EncapInsp, TeachDocPath+'pos'+FoV+'_'+'NoOfRectangle4EncapInsp')</l>
<l>write_tuple (EncapInspectRectRows, TeachDocPath+'pos'+FoV+'_'+'EncapInspectRectRows')</l>
<l>write_tuple (EncapInspectRectCols, TeachDocPath+'pos'+FoV+'_'+'EncapInspectRectCols')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_SaveEncapParameter">
<parameters>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapRectCols"/>
<parameter id="EncapRectRows"/>
<parameter id="EncapTeachDoc"/>
<parameter id="FoV"/>
<parameter id="MaxEncapContrast"/>
<parameter id="MinEncapContrast"/>
<parameter id="NoOfEncapRect4EncapLoc"/>
<parameter id="NoOfRectangle4EncapInsp"/>
<parameter id="TeachDocPath"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SavePVIParameters">
<interface>
<ic>
<par name="NoOfPVIAreas" base_type="ctrl" dimension="0"/>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="Mask2DCenterPoints" base_type="ctrl" dimension="0"/>
<par name="MaskAngleConcat" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="PVI2DCenter" base_type="ctrl" dimension="0"/>
<par name="PVISize" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="w" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>write_tuple (NoOfPVIAreas, TeachDocPath+'pos'+FoV+'_'+'NumOfPVIAreas')</l>
<l>write_tuple (NoOfMaskRegions, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'NumOfMask')</l>
<c></c>
<l>write_tuple (PVIAngle, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'PVIAngle')</l>
<l>write_tuple (PVI2DCenter, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'PVI2DCenter')</l>
<l>write_tuple (PVISize, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'PVISize')</l>
<c></c>
<l>write_tuple (Mask2DCenterPoints, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'Mask2DCenterPoints')</l>
<l>write_tuple (MaskAngleConcat, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'MaskAngleConcat')</l>
<l>write_tuple (MaskSize, TeachDocPath+'pos'+FoV+'_'+'PVI_Area'+w+'_'+'MaskSize')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_SavePVIParameters">
<parameters>
<parameter id="FoV"/>
<parameter id="Mask2DCenterPoints"/>
<parameter id="MaskAngleConcat"/>
<parameter id="MaskSize"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="NoOfPVIAreas"/>
<parameter id="PVI2DCenter"/>
<parameter id="PVIAngle"/>
<parameter id="PVISize"/>
<parameter id="TeachDocPath"/>
<parameter id="w"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SaveTeachParameters">
<interface>
<io>
<par name="Doc1Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="NoOfTeachRegions" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="RegionTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="RegionTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="TeachDoc1Path" base_type="ctrl" dimension="0"/>
<par name="j" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>for rect:=1 to NoOfUniquePatterns by 1</l>
<l>    stop()</l>
<l>    draw_rectangle1(WindowHandle, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1(Rectangle, Row1, Column1, Row2, Column2)</l>
<l>    tuple_concat (PatternTeachRectRows, Row1, PatternTeachRectRows)</l>
<l>    tuple_concat (PatternTeachRectRows, Row2, PatternTeachRectRows)</l>
<l>    tuple_concat (PatternTeachRectCols, Column1, PatternTeachRectCols)</l>
<l>    tuple_concat (PatternTeachRectCols, Column2, PatternTeachRectCols)</l>
<l>endfor</l>
<c></c>
<l>for rect:=1 to NoOfLocationTeachRegs by 1</l>
<l>    stop()</l>
<l>    draw_rectangle1(WindowHandle, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1(Rectangle1, Row1, Column1, Row2, Column2)</l>
<l>    tuple_concat (LocationTeachRectRows, Row1, LocationTeachRectRows)</l>
<l>    tuple_concat (LocationTeachRectRows, Row2, LocationTeachRectRows)</l>
<l>    tuple_concat (LocationTeachRectCols, Column1, LocationTeachRectCols)</l>
<l>    tuple_concat (LocationTeachRectCols, Column2, LocationTeachRectCols)</l>
<l>endfor</l>
<c></c>
<c></c>
<l>write_tuple (NoOfUniquePatterns, TeachDoc1Path+'pos'+j+'_'+'NoOfUniquePatterns')</l>
<l>write_tuple (NoOfLocationTeachRegs, TeachDoc1Path+'pos'+j+'_'+'NoOfLocationTeachRegs')</l>
<l>write_tuple (NoOfTeachRegions, TeachDoc1Path+'pos'+j+'_'+'NoOfTeachRegions')</l>
<l>write_tuple (MaxRotationAngle, TeachDoc1Path+'pos'+j+'_'+'MaxRotationAngle')</l>
<c></c>
<c></c>
<l>write_tuple (PatternTeachRectRows, TeachDoc1Path+'pos'+j+'_'+'PatternTeachRows')</l>
<l>write_tuple (PatternTeachRectCols, TeachDoc1Path+'pos'+j+'_'+'PatternTeachCols')</l>
<l>write_tuple (LocationTeachRectRows, TeachDoc1Path+'pos'+j+'_'+'LocationTeachRows')</l>
<l>write_tuple (LocationTeachRectCols, TeachDoc1Path+'pos'+j+'_'+'LocationTeachCols')</l>
<l>write_tuple (RegionTeachRectRows, TeachDoc1Path+'pos'+j+'_'+'RegionTeachRows')</l>
<l>write_tuple (RegionTeachRectCols, TeachDoc1Path+'pos'+j+'_'+'RegionTeachCols')</l>
<l>return ()</l>
</body>
<docu id="_FCI_SaveTeachParameters">
<parameters>
<parameter id="Doc1Image"/>
<parameter id="LocationTeachRectCols"/>
<parameter id="LocationTeachRectRows"/>
<parameter id="MaxRotationAngle"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfTeachRegions"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternTeachRectCols"/>
<parameter id="PatternTeachRectRows"/>
<parameter id="RegionTeachRectCols"/>
<parameter id="RegionTeachRectRows"/>
<parameter id="TeachDoc1Path"/>
<parameter id="WindowHandle"/>
<parameter id="j"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SaveTiltParameter">
<interface>
<ic>
<par name="TiltTeachDoc" base_type="ctrl" dimension="0"/>
<par name="TiltRectRows" base_type="ctrl" dimension="0"/>
<par name="TiltRectCols" base_type="ctrl" dimension="0"/>
<par name="TeachDocPath" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>write_tuple (TiltTeachDoc, TeachDocPath+'pos'+FoV+'_'+'TiltTeachDoc')</l>
<l>write_tuple (TiltRectRows, TeachDocPath+'pos'+FoV+'_'+'TiltRectRows')</l>
<l>write_tuple (TiltRectCols, TeachDocPath+'pos'+FoV+'_'+'TiltRectCols')</l>
<l>return ()</l>
</body>
<docu id="_FCI_SaveTiltParameter">
<parameters>
<parameter id="FoV"/>
<parameter id="TeachDocPath"/>
<parameter id="TiltRectCols"/>
<parameter id="TiltRectRows"/>
<parameter id="TiltTeachDoc"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Select_DeviceLocation">
<interface>
<io>
<par name="ConcatDeviceLocation" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DeviceCenterRow" base_type="ctrl" dimension="0"/>
<par name="DeviceCenterColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>select_obj(ConcatDeviceLocation, DeviceLocationSelected, i+1)</l>
<l>area_center (DeviceLocationSelected, DeviceArea, DeviceCenterRow, DeviceCenterColumn)</l>
<l>if(DeviceArea &lt;= 5)</l>
<l>    area_center(ConcatDeviceLocation, ConcatDeviceLocationArea, Dummy, Dummy)</l>
<l>    tuple_greater_elem(ConcatDeviceLocationArea, 1, Greater)</l>
<l>    tuple_find_first (Greater, 1, Index)</l>
<l>    if (Index = -1)</l>
<l>        return()</l>
<l>    endif</l>
<l>    select_obj (ConcatDeviceLocation, DeviceLocationSelected, Index+1)</l>
<l>    area_center(DeviceLocationSelected, DeviceArea, DeviceCenterRow, DeviceCenterColumn)</l>
<l>endif            </l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Select_DeviceLocation">
<parameters>
<parameter id="ConcatDeviceLocation"/>
<parameter id="DeviceCenterColumn"/>
<parameter id="DeviceCenterRow"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Select_ROI4CoverLayer">
<interface>
<io>
<par name="ConcatObject" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="OuterSelectedObj" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>gen_empty_obj(OuterSelectedObj)</l>
<l>area_center (ConcatObject, OuterObjArea, Dummy, Dummy)</l>
<l>tuple_greater_equal_elem (OuterObjArea, 1, Greatereq)</l>
<l>tuple_find (Greatereq, 1, Indices)</l>
<l>if(Indices = -1)  </l>
<l>    return()</l>
<l>else</l>
<l>    if(|Indices| = 1)</l>
<l>        select_obj (ConcatObject, OuterSelectedObj, Indices+1)</l>
<l>    else</l>
<l>        concat_obj (OuterSelectedObj, ConcatObject, OuterSelectedObj)</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_FCI_Select_ROI4CoverLayer">
<parameters>
<parameter id="ConcatObject"/>
<parameter id="OuterSelectedObj"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Select_TeachParameter">
<interface>
<ic>
<par name="TupleVector" base_type="ctrl" dimension="3"/>
<par name="DatumTeachTuple" base_type="ctrl" dimension="0"/>
<par name="EdgeTeachTuple" base_type="ctrl" dimension="0"/>
<par name="nIntensity" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="IsDatum" base_type="ctrl" dimension="0"/>
<par name="IsEdge" base_type="ctrl" dimension="0"/>
<par name="FindDatumIndex" base_type="ctrl" dimension="0"/>
<par name="FindEdgeIndex" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>TupleVectorOut := TupleVector</l>
<l>IsPass := false</l>
<l>TeachLocDoc1 := TupleVectorOut.at(FoV-1).at(i).at(17)</l>
<l>IsEdge := 0</l>
<l>IsDatum := 0</l>
<l>FindDatumIndex := -1</l>
<l>FindEdgeIndex := -1</l>
<c></c>
<l>gen_empty_obj (DeviceLocation)</l>
<l>if(TeachLocDoc1&gt;=0)</l>
<l>    IsDatum := DatumTeachTuple[i]</l>
<l>    if(IsDatum &gt; 0)</l>
<l>        FindDatumIndex := i</l>
<l>    endif</l>
<l>    IsEdge := EdgeTeachTuple[i]</l>
<l>    if(IsEdge &gt; 0)</l>
<l>        FindEdgeIndex := i</l>
<l>    endif</l>
<c>    </c>
<l>else</l>
<l>    IsFound := 0</l>
<l>    if(not IsFound)</l>
<l>        for j := i to 0 by -1</l>
<l>            if(DatumTeachTuple[j] = 1)</l>
<l>                FindDatumIndex := j</l>
<l>                IsDatum := 1</l>
<l>                IsFound := true</l>
<l>                break</l>
<l>            elseif(EdgeTeachTuple[j] = 1)</l>
<l>                FindEdgeIndex := j</l>
<l>                IsEdge := 1</l>
<l>                IsFound := true</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<c>    </c>
<l>    if(not IsFound)</l>
<l>        for k := i to nIntensity-1 by 1</l>
<l>            if(DatumTeachTuple[k] = 1)</l>
<l>                FindDatumIndex := k</l>
<l>                IsDatum := 1</l>
<l>                break</l>
<l>            elseif(EdgeTeachTuple[k] = 1)</l>
<l>                FindEdgeIndex := k</l>
<l>                IsEdge := 1</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>if(IsEdge = 1 or IsDatum = 1)</l>
<l>    IsPass := true</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Select_TeachParameter">
<parameters>
<parameter id="DatumTeachTuple"/>
<parameter id="EdgeTeachTuple"/>
<parameter id="FindDatumIndex"/>
<parameter id="FindEdgeIndex"/>
<parameter id="FoV"/>
<parameter id="IsDatum"/>
<parameter id="IsEdge"/>
<parameter id="IsPass"/>
<parameter id="TupleVector"/>
<parameter id="i"/>
<parameter id="nIntensity"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SelectTeachParameter">
<interface>
<ic>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="NoOfLocationTeachRegsInput" base_type="ctrl" dimension="0"/>
<par name="DeviceWidthInput" base_type="ctrl" dimension="0"/>
<par name="DeviceHeightInput" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrastInput" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatternsInput" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngleInput" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongXInput" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongYInput" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScoreInput" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRowsInput" base_type="ctrl" dimension="0"/>
<par name="PatternTeachColsInput" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRowsInput" base_type="ctrl" dimension="0"/>
<par name="LocationTeachColsInput" base_type="ctrl" dimension="0"/>
<par name="ModelIDsInput" base_type="ctrl" dimension="0"/>
<par name="PatternDegreeInput" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="SelectedNoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="SelectedDeviceWidth" base_type="ctrl" dimension="0"/>
<par name="SelectedDeviceHeight" base_type="ctrl" dimension="0"/>
<par name="SelectedMinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="SelectedNoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="SelectedMaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="SelectedMinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="SelectedLocationTeachRows" base_type="ctrl" dimension="0"/>
<par name="SelectedLocationTeachCols" base_type="ctrl" dimension="0"/>
<par name="SelectedModelIDs" base_type="ctrl" dimension="0"/>
<par name="SelectedPatternDegree" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>tuple_concat(NoOfLocationTeachRegsInput, NoOfLocationTeachRegs, SelectedNoOfLocationTeachRegs)</l>
<l>tuple_concat(DeviceWidthInput, DeviceWidth, SelectedDeviceWidth)</l>
<l>tuple_concat(DeviceHeightInput, DeviceHeight, SelectedDeviceHeight)</l>
<l>tuple_concat(MinDeviceContrastInput, MinDeviceContrast, SelectedMinDeviceContrast)</l>
<c></c>
<l>tuple_concat(NoOfUniquePatternsInput, NoOfUniquePatterns, SelectedNoOfUniquePatterns)</l>
<l>tuple_concat(MaxRotationAngleInput, MaxRotationAngle, SelectedMaxRotationAngle)</l>
<l>tuple_concat(PatternSearchAreaAlongXInput, PatternSearchAreaAlongX, SelectedPatternSearchAreaAlongX)</l>
<l>tuple_concat(PatternSearchAreaAlongYInput, PatternSearchAreaAlongY, SelectedPatternSearchAreaAlongY)</l>
<l>tuple_concat(MinAcceptanceScoreInput, MinAcceptanceScore, SelectedMinAcceptanceScore)</l>
<c></c>
<l>tuple_concat(PatternTeachRowsInput, PatternTeachRows, SelectedPatternTeachRows)</l>
<l>tuple_concat(PatternTeachColsInput, PatternTeachCols, SelectedPatternTeachCols)</l>
<l>tuple_concat(LocationTeachRowsInput, LocationTeachRows, SelectedLocationTeachRows)</l>
<l>tuple_concat(LocationTeachColsInput, LocationTeachCols, SelectedLocationTeachCols)</l>
<l>tuple_concat(ModelIDsInput, ModelIDs, SelectedModelIDs)</l>
<l>tuple_concat(PatternDegreeInput, PatternDegree, SelectedPatternDegree)    </l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_SelectTeachParameter">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceHeightInput"/>
<parameter id="DeviceWidth"/>
<parameter id="DeviceWidthInput"/>
<parameter id="LocationTeachCols"/>
<parameter id="LocationTeachColsInput"/>
<parameter id="LocationTeachRows"/>
<parameter id="LocationTeachRowsInput"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MaxRotationAngleInput"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinAcceptanceScoreInput"/>
<parameter id="MinDeviceContrast"/>
<parameter id="MinDeviceContrastInput"/>
<parameter id="ModelIDs"/>
<parameter id="ModelIDsInput"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfLocationTeachRegsInput"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="NoOfUniquePatternsInput"/>
<parameter id="PatternDegree"/>
<parameter id="PatternDegreeInput"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongXInput"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternSearchAreaAlongYInput"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachColsInput"/>
<parameter id="PatternTeachRows"/>
<parameter id="PatternTeachRowsInput"/>
<parameter id="SelectedDeviceHeight"/>
<parameter id="SelectedDeviceWidth"/>
<parameter id="SelectedLocationTeachCols"/>
<parameter id="SelectedLocationTeachRows"/>
<parameter id="SelectedMaxRotationAngle"/>
<parameter id="SelectedMinAcceptanceScore"/>
<parameter id="SelectedMinDeviceContrast"/>
<parameter id="SelectedModelIDs"/>
<parameter id="SelectedNoOfLocationTeachRegs"/>
<parameter id="SelectedNoOfUniquePatterns"/>
<parameter id="SelectedPatternDegree"/>
<parameter id="SelectedPatternSearchAreaAlongX"/>
<parameter id="SelectedPatternSearchAreaAlongY"/>
<parameter id="SelectedPatternTeachCols"/>
<parameter id="SelectedPatternTeachRows"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SetOptimumPulseWidth">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="TargetGrayMeanValue" base_type="ctrl" dimension="0"/>
<par name="Tolerance" base_type="ctrl" dimension="0"/>
<par name="TargetGrayDeviation" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsRange" base_type="ctrl" dimension="0"/>
<par name="Difference" base_type="ctrl" dimension="0"/>
<par name="MaxDeviationValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>MaxDeviationValue := 0</l>
<l>PartitionSize := 3</l>
<l>get_domain(Image, Domain)</l>
<l>get_image_size(Image, Width, Height)</l>
<l>partition_rectangle(Domain, Partitioned, Width/PartitionSize, Height/PartitionSize)</l>
<l>intensity (Partitioned, Image, ActualGrayMeanValue, ActualGrayDeviation)</l>
<c></c>
<l>tuple_gen_const(|ActualGrayDeviation|, TargetGrayDeviation, Newtuple)</l>
<l>tuple_greater_elem(ActualGrayDeviation, TargetGrayDeviation, Greater)</l>
<l>tuple_find (Greater, 1, Indices)</l>
<l>if(Indices # -1)</l>
<l>   tuple_max( ActualGrayDeviation, MaxDeviationValue)</l>
<l>   return()</l>
<l>endif</l>
<c></c>
<l>tuple_mean(ActualGrayMeanValue, ActualGrayMeanValue)</l>
<l>MinTargetGrayMeanValue := TargetGrayMeanValue - Tolerance</l>
<l>MaxTargetGrayMeanValue := TargetGrayMeanValue + Tolerance </l>
<c></c>
<l>if(MaxTargetGrayMeanValue &gt; 255)</l>
<l>    MaxTargetGrayMeanValue := 255</l>
<l>endif</l>
<l>if(MinTargetGrayMeanValue &lt; 0 )</l>
<l>    MinTargetGrayMeanValue := 0</l>
<l>endif</l>
<c></c>
<c></c>
<l>if (ActualGrayMeanValue &gt; MaxTargetGrayMeanValue)</l>
<l>    Difference := abs(TargetGrayMeanValue - ActualGrayMeanValue)</l>
<l>    IsRange := -1</l>
<c>    </c>
<l>elseif (ActualGrayMeanValue &lt; MinTargetGrayMeanValue)</l>
<l>    Difference := abs(TargetGrayMeanValue - ActualGrayMeanValue)</l>
<l>    IsRange := 1</l>
<c>    </c>
<l>else</l>
<c></c>
<l>    Difference := 0</l>
<l>    IsRange := 0</l>
<c>    </c>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_SetOptimumPulseWidth">
<parameters>
<parameter id="Difference"/>
<parameter id="Image"/>
<parameter id="IsRange"/>
<parameter id="MaxDeviationValue"/>
<parameter id="TargetGrayDeviation"/>
<parameter id="TargetGrayMeanValue"/>
<parameter id="Tolerance"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_SideCameraCalibration">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="InputRegionRow1" base_type="ctrl" dimension="0"/>
<par name="InputRegionColumn1" base_type="ctrl" dimension="0"/>
<par name="InputRegionRow2" base_type="ctrl" dimension="0"/>
<par name="InputRegionColumn2" base_type="ctrl" dimension="0"/>
<par name="TargetGrayMeanValue" base_type="ctrl" dimension="0"/>
<par name="Tolerance" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsRange" base_type="ctrl" dimension="0"/>
<par name="Deviation" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>gen_rectangle1(Region, InputRegionRow1, InputRegionColumn1, InputRegionRow2, InputRegionColumn2)</l>
<l>intensity (Region, Image, ActualGrayMeanValue, Dummy)</l>
<l>MinTargetGrayMeanValue := TargetGrayMeanValue - Tolerance</l>
<l>MaxTargetGrayMeanValue := TargetGrayMeanValue + Tolerance </l>
<c></c>
<l>if(MaxTargetGrayMeanValue &gt; 255)</l>
<l>    MaxTargetGrayMeanValue := 255</l>
<l>endif</l>
<l>if(MinTargetGrayMeanValue &lt; 0 )</l>
<l>    MinTargetGrayMeanValue := 0</l>
<l>endif</l>
<c></c>
<l>if (ActualGrayMeanValue &gt; MaxTargetGrayMeanValue)</l>
<l>    Deviation := TargetGrayMeanValue - ActualGrayMeanValue</l>
<l>    IsRange := -1</l>
<c>   </c>
<l>elseif (ActualGrayMeanValue &lt; MinTargetGrayMeanValue)</l>
<l>    Deviation := ActualGrayMeanValue - MinTargetGrayMeanValue</l>
<l>    IsRange := -1</l>
<c>    </c>
<l>else</l>
<l>    Deviation := 0</l>
<l>    IsRange := 1</l>
<l>endif</l>
<c></c>
<l>return ()</l>
<c></c>
</body>
<docu id="_FCI_SideCameraCalibration">
<parameters>
<parameter id="Deviation"/>
<parameter id="Image"/>
<parameter id="InputRegionColumn1"/>
<parameter id="InputRegionColumn2"/>
<parameter id="InputRegionRow1"/>
<parameter id="InputRegionRow2"/>
<parameter id="IsRange"/>
<parameter id="TargetGrayMeanValue"/>
<parameter id="Tolerance"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Teach_Datam">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ROI" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Col1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Col2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RefDeg" base_type="ctrl" dimension="0"/>
<par name="ModelID1" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>ROICenterRow := []</l>
<l>ROICenterCol := []   </l>
<l>ModelID1 := []</l>
<c>    </c>
<l>gen_empty_obj(ROI)</l>
<c></c>
<l>for i:= 0 to |Row1|-1 by 1</l>
<l>    gen_rectangle1(ROIIns, Row1[i], Col1[i], Row2[i], Col2[i]) </l>
<l>    area_center(ROIIns, Dummy, CenterRow, CenterCol)</l>
<c>        </c>
<l>    tuple_concat(ROICenterRow, CenterRow, ROICenterRow)</l>
<l>    tuple_concat(ROICenterCol, CenterCol, ROICenterCol)</l>
<c>        </c>
<c>        </c>
<l>    concat_obj(ROI, ROIIns, ROI)</l>
<c>    </c>
<l>    reduce_domain(Image, ROIIns, TemplateImage)</l>
<l>    create_ncc_model(TemplateImage, \
                         'auto', -rad(25), rad(50), 'auto', 'use_polarity', \
                         ModelID)</l>
<l>    tuple_concat(ModelID1, ModelID, ModelID1)</l>
<c>            </c>
<l>endfor</l>
<c></c>
<l>gen_region_line(RegionLines, ROICenterRow[0], ROICenterCol[0], ROICenterRow[1], ROICenterCol[1])</l>
<l>orientation_region(RegionLines, Phi)</l>
<l>tuple_deg(Phi, RefDeg)</l>
<l>if(RefDeg &lt; 0)</l>
<l>    RefDeg := 180 + RefDeg</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Teach_Datam">
<parameters>
<parameter id="Col1"/>
<parameter id="Col2"/>
<parameter id="Image"/>
<parameter id="ModelID1"/>
<parameter id="ROI"/>
<parameter id="RefDeg"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_TeachUniquePattern">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachCols" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>ModelIDs:=[]</l>
<l>gen_empty_obj (PatternRects)</l>
<l>if(NoOfUniquePatterns &gt; 0)</l>
<l>    for p:= 0 to NoOfUniquePatterns-1 by 1</l>
<c>        </c>
<l>        PatternRows := PatternTeachRows[2*p:2*(p+1)-1]</l>
<l>        PatternCols := PatternTeachCols[2*p:2*(p+1)-1]</l>
<c>        </c>
<l>        gen_rectangle1(PatternRectangle, PatternRows[0], PatternCols[0], PatternRows[1], PatternCols[1])</l>
<l>        concat_obj(PatternRects,PatternRectangle, PatternRects)                    </l>
<l>    endfor</l>
<c>    </c>
<l>    union1 (PatternRects, RegionUnion)</l>
<l>    reduce_domain (Image, RegionUnion, TemplateImageReduced)</l>
<l>    crop_domain (TemplateImageReduced, ImagePart)</l>
<c>    </c>
<l>    create_ncc_model(ImagePart, \
                     'auto', rad(-5), rad(MaxRotationAngle), 'auto', 'use_polarity', \
                     ModelIDs)</l>
<c>    </c>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_TeachUniquePattern">
<parameters>
<parameter id="Image"/>
<parameter id="MaxRotationAngle"/>
<parameter id="ModelIDs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternTeachCols"/>
<parameter id="PatternTeachRows"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Tilt_AutoTeach_ReadData">
<interface>
<ic>
<par name="posDTupleNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TiltTeachDoc" base_type="ctrl" dimension="0"/>
<par name="TiltRectRows" base_type="ctrl" dimension="0"/>
<par name="TiltRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_regexp_select (posDTupleNames, ['TiltTeachDoc','ignore_case'], tupleTiltTeachDoc) </l>
<l>tuple_regexp_select (posDTupleNames, ['TiltRectRows','ignore_case'], tupleTiltRectRows)</l>
<l>tuple_regexp_select (posDTupleNames, ['TiltRectCols','ignore_case'], tupleTiltRectCols)</l>
<c></c>
<l>read_tuple(tupleTiltTeachDoc, TiltTeachDoc)</l>
<l>read_tuple(tupleTiltRectRows, TiltRectRows)</l>
<l>read_tuple(tupleTiltRectCols, TiltRectCols)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Tilt_AutoTeach_ReadData">
<parameters>
<parameter id="TiltRectCols"/>
<parameter id="TiltRectRows"/>
<parameter id="TiltTeachDoc"/>
<parameter id="posDTupleNames"/>
</parameters>
</docu>
</procedure>
<procedure name="_FCI_Tilt_Inspection">
<interface>
<ic>
<par name="A1" base_type="ctrl" dimension="0"/>
<par name="A2" base_type="ctrl" dimension="0"/>
<par name="ResolutionAlongYInMicronPerPixelTop" base_type="ctrl" dimension="0"/>
<par name="B1" base_type="ctrl" dimension="0"/>
<par name="B2" base_type="ctrl" dimension="0"/>
<par name="ResolutionAlongYInMicronPerPixelSide" base_type="ctrl" dimension="0"/>
<par name="TiltTolerance" base_type="ctrl" dimension="0"/>
<par name="AngleOfSideView" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="h" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>IsPass := true</l>
<c></c>
<l>A1_AfterCalib := A1 * (ResolutionAlongYInMicronPerPixelTop)</l>
<l>A2_AfterCalib := A2 * (ResolutionAlongYInMicronPerPixelTop)</l>
<l>B1_AfterCalib := B1 * (ResolutionAlongYInMicronPerPixelSide)</l>
<l>B2_AfterCalib := B2 * (ResolutionAlongYInMicronPerPixelSide)</l>
<c></c>
<c></c>
<l>tuple_rad (AngleOfSideView, Rad)</l>
<c></c>
<l>SinAngle := sin(Rad)</l>
<l>TanAngle := tan(Rad)</l>
<c></c>
<l>FirstPart := B1_AfterCalib*TanAngle - A1_AfterCalib*SinAngle</l>
<l>SecondPart := B2_AfterCalib*TanAngle - A2_AfterCalib*SinAngle</l>
<c></c>
<l>h := abs( FirstPart - SecondPart )</l>
<c></c>
<c></c>
<l>if(h &gt; TiltTolerance)</l>
<l>    IsPass := false</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_FCI_Tilt_Inspection">
<parameters>
<parameter id="A1"/>
<parameter id="A2"/>
<parameter id="AngleOfSideView"/>
<parameter id="B1"/>
<parameter id="B2"/>
<parameter id="IsPass"/>
<parameter id="ResolutionAlongYInMicronPerPixelSide"/>
<parameter id="ResolutionAlongYInMicronPerPixelTop"/>
<parameter id="TiltTolerance"/>
<parameter id="h"/>
</parameters>
</docu>
</procedure>
<procedure name="_Find_Model">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="SearchRegion" base_type="iconic" dimension="0"/>
<par name="ModelRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="MatchModel" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CenterRow" base_type="ctrl" dimension="0"/>
<par name="CenterCol" base_type="ctrl" dimension="0"/>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="MinMatchScore" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsDatumPass" base_type="ctrl" dimension="0"/>
<par name="MatchRow" base_type="ctrl" dimension="0"/>
<par name="MatchColumn" base_type="ctrl" dimension="0"/>
<par name="MatchAngle" base_type="ctrl" dimension="0"/>
<par name="MatchScore" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>IsDatumPass := true</l>
<l>shape_trans (SearchRegion, TransSearchRegion, 'rectangle1')</l>
<l>reduce_domain(Image, TransSearchRegion, RefSearchImage)</l>
<l>crop_domain (RefSearchImage, ImagePart)</l>
<c></c>
<l>find_ncc_model(ImagePart, \
               ModelID, rad(-5), rad(MaxRotationAngle), 0.1, 1, 0.5, 'true', 0, \
               CropMatchRow, CropMatchColumn, MatchAngle, MatchScore )</l>
<c></c>
<l>if(|MatchScore| = 0)</l>
<l>    IsDatumPass := false</l>
<l>    return()</l>
<l>else </l>
<l>    if(MatchScore &gt;= MinMatchScore)</l>
<c>        </c>
<l>        hom_mat2d_identity (AlignmentHomMat2D)</l>
<l>        hom_mat2d_translate (AlignmentHomMat2D, -CenterRow, -CenterCol, AlignmentHomMat2D)</l>
<l>        hom_mat2d_rotate (AlignmentHomMat2D, MatchAngle, 0, 0, AlignmentHomMat2D)</l>
<l>        hom_mat2d_translate (AlignmentHomMat2D, CropMatchRow, CropMatchColumn, AlignmentHomMat2D)</l>
<l>        affine_trans_region (ModelRegion, MatchModel, AlignmentHomMat2D, 'nearest_neighbor')</l>
<l>        CropMatchRow := CropMatchRow</l>
<l>        CropMatchColumn := CropMatchColumn</l>
<l>    else</l>
<l>        IsDatumPass := false</l>
<l>        return()</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>**** Project back to original domain</c>
<l>area_center (ModelRegion, Area, Row, Column)</l>
<l>gen_cross_contour_xld (Cross,CropMatchRow, CropMatchColumn, 60, MatchAngle)</l>
<c></c>
<l>smallest_rectangle1 (TransSearchRegion, Row1, Column1, Row2, Column2)</l>
<l>MatchRow:=Row1+CropMatchRow</l>
<l>MatchColumn:=Column1+CropMatchColumn</l>
<c></c>
<l>dev_display (Image)</l>
<l>gen_cross_contour_xld (Cross1, MatchRow, MatchColumn, 60, MatchAngle)</l>
<l>vector_angle_to_rigid (CropMatchRow, CropMatchColumn, MatchAngle, MatchRow, MatchColumn, MatchAngle, HomMat2D1)</l>
<l>affine_trans_region (MatchModel, MatchModel, HomMat2D1, 'nearest_neighbor')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Find_Model">
<parameters>
<parameter id="CenterCol"/>
<parameter id="CenterRow"/>
<parameter id="Image"/>
<parameter id="IsDatumPass"/>
<parameter id="MatchAngle"/>
<parameter id="MatchColumn"/>
<parameter id="MatchModel"/>
<parameter id="MatchRow"/>
<parameter id="MatchScore"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinMatchScore"/>
<parameter id="ModelID"/>
<parameter id="ModelRegion"/>
<parameter id="SearchRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="_Finding_CVL_Thickness">
<interface>
<io>
<par name="ConnectedLowerRegions" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="LowerCountNumber" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ThicknessOfCVL" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>MaxDistance := []</l>
<l>Offset := 50</l>
<c></c>
<l>for i := 1 to LowerCountNumber by 1</l>
<l>    select_obj (ConnectedLowerRegions, ObjectSelected1, i)</l>
<l>    area_center (ObjectSelected1, Dummy, CenterRow1, CenterColumn1)</l>
<l>    gen_contour_polygon_xld (Contour1, CenterRow1, CenterColumn1)</l>
<c>    </c>
<l>    for j:= i+1 to LowerCountNumber by 1</l>
<l>        select_obj (ConnectedLowerRegions, ObjectSelected2, j)</l>
<l>        area_center (ObjectSelected2, Dummy, CenterRow2, CenterColumn2)</l>
<l>        gen_contour_polygon_xld (Contour2, CenterRow2, CenterColumn2)</l>
<c>        </c>
<l>        distance_cc (Contour1, Contour2, 'point_to_point', Dummy, DistanceMax)</l>
<l>        if(DistanceMax &lt; Offset)</l>
<l>            break</l>
<l>        endif           </l>
<l>        tuple_concat (MaxDistance, DistanceMax, MaxDistance)  </l>
<l>    endfor</l>
<l>endfor</l>
<c></c>
<l>if(|MaxDistance|)</l>
<l>    tuple_max (MaxDistance, ThicknessOfCVL)</l>
<l>else</l>
<l>    ThicknessOfCVL := 0</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Finding_CVL_Thickness">
<parameters>
<parameter id="ConnectedLowerRegions"/>
<parameter id="LowerCountNumber"/>
<parameter id="ThicknessOfCVL"/>
</parameters>
</docu>
</procedure>
<procedure name="_LoadImages">
<interface>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="PassImgPath" base_type="ctrl" dimension="0"/>
<par name="FailImgPath" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>**Procedure to Load Images</c>
<c>**Output Parmeters:: it returns the ImagesFiles </c>
<l>dev_open_file_dialog('read_image', 'default', 'default', Selection)</l>
<l>tuple_strrchr(Selection, '/', Position)</l>
<l>tuple_substr(Selection, 0, Position - 1, Substring)</l>
<c></c>
<l>list_files (Substring, ['files','follow_links','recursive'], ImageFiles)</l>
<l>tuple_regexp_select (ImageFiles, ['\\.(bmp)$','ignore_case'], ImageFiles)</l>
<c></c>
<c></c>
<l>tuple_strrchr(Substring, '/', FolderStartIndex)</l>
<l>tuple_substr(Substring, FolderStartIndex+1, Position - 1, StrFolder) </l>
<c></c>
<l>tuple_add(Substring, '/PassImages', PassImgPath)</l>
<l>tuple_add(Substring, '/FailImages', FailImgPath)</l>
<c></c>
<l>try</l>
<l>    list_files(FailImgPath, 'files', Files)</l>
<l>catch(Exception)</l>
<l>    make_dir(FailImgPath) </l>
<l>endtry</l>
<l>try</l>
<l>    list_files(PassImgPath, 'files', Files)</l>
<l>catch(Exception)</l>
<l>    make_dir(PassImgPath)</l>
<l>endtry</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_LoadImages">
<parameters>
<parameter id="FailImgPath"/>
<parameter id="ImageFiles"/>
<parameter id="PassImgPath"/>
</parameters>
</docu>
</procedure>
<procedure name="_Location_TeachTupleVector">
<interface>
<ic>
<par name="TupleVector" base_type="ctrl" dimension="3"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<c></c>
<l>TupleVectorOut := TupleVector</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(0,NoOfLocationTeachRegs)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(1,DeviceWidth)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(2,DeviceHeight)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(3,MinDeviceContrast)</l>
<c></c>
<l>TupleVectorOut.at(FoV-1).at(i).insert(4,NoOfUniquePatterns)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(5,MaxRotationAngle)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(6,PatternSearchAreaAlongX)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(7,PatternSearchAreaAlongY)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(8,MinAcceptanceScore)</l>
<c></c>
<l>TupleVectorOut.at(FoV-1).at(i).insert(9,PatternTeachRectRows)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(10,PatternTeachRectCols)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(11,LocationTeachRectRows)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(12,LocationTeachRectCols)</l>
<c></c>
<l>TupleVectorOut.at(FoV-1).at(i).insert(13,ModelIDs)</l>
<l>TupleVectorOut.at(FoV-1).at(i).insert(14,PatternDegree)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Location_TeachTupleVector">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceWidth"/>
<parameter id="FoV"/>
<parameter id="LocationTeachRectCols"/>
<parameter id="LocationTeachRectRows"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelIDs"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternDegree"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachRectCols"/>
<parameter id="PatternTeachRectRows"/>
<parameter id="TupleVector"/>
<parameter id="TupleVectorOut"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="_Retrieve_CVL_Data">
<interface>
<ic>
<par name="CVLTupleVector4Eachntensity" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="NoOfRegions" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnRows" base_type="ctrl" dimension="0"/>
<par name="CVLRectRgnCols" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLDatumRows" base_type="ctrl" dimension="0"/>
<par name="CVLDatumCols" base_type="ctrl" dimension="0"/>
<par name="CVLModelID" base_type="ctrl" dimension="0"/>
<par name="CVLRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLMatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="CVLMatchModelCenterCol" base_type="ctrl" dimension="0"/>
<par name="CVLContrast" base_type="ctrl" dimension="0"/>
<par name="CVLLength" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="MinCVLHeight" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>NoOfRegions             := CVLTupleVector4Eachntensity.at(1)</l>
<l>CVLRectRgnRows          := CVLTupleVector4Eachntensity.at(2)</l>
<l>CVLRectRgnCols          := CVLTupleVector4Eachntensity.at(3)</l>
<c></c>
<l>NoOfUniquePatterns      := CVLTupleVector4Eachntensity.at(4)</l>
<l>MaxRotationAngle        := CVLTupleVector4Eachntensity.at(5)</l>
<l>PatternSearchAreaAlongX := CVLTupleVector4Eachntensity.at(6)</l>
<l>PatternSearchAreaAlongY := CVLTupleVector4Eachntensity.at(7)</l>
<l>MinAcceptanceScore      := CVLTupleVector4Eachntensity.at(8)</l>
<c></c>
<l>CVLDatumRows            := CVLTupleVector4Eachntensity.at(9)</l>
<l>CVLDatumCols            := CVLTupleVector4Eachntensity.at(10)</l>
<l>CVLModelID              := CVLTupleVector4Eachntensity.at(11)</l>
<c></c>
<l>CVLRotationAngle        := CVLTupleVector4Eachntensity.at(12)</l>
<l>CVLMatchModelCenterRow  := CVLTupleVector4Eachntensity.at(13)</l>
<l>CVLMatchModelCenterCol  := CVLTupleVector4Eachntensity.at(14)</l>
<c></c>
<l>CVLContrast             := CVLTupleVector4Eachntensity.at(15)</l>
<l>CVLLength               := CVLTupleVector4Eachntensity.at(16)</l>
<l>MaskSize                := CVLTupleVector4Eachntensity.at(17)</l>
<l>MinCVLHeight            := CVLTupleVector4Eachntensity.at(18)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Retrieve_CVL_Data">
<parameters>
<parameter id="CVLContrast"/>
<parameter id="CVLDatumCols"/>
<parameter id="CVLDatumRows"/>
<parameter id="CVLLength"/>
<parameter id="CVLMatchModelCenterCol"/>
<parameter id="CVLMatchModelCenterRow"/>
<parameter id="CVLModelID"/>
<parameter id="CVLRectRgnCols"/>
<parameter id="CVLRectRgnRows"/>
<parameter id="CVLRotationAngle"/>
<parameter id="CVLTupleVector4Eachntensity"/>
<parameter id="MaskSize"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinCVLHeight"/>
<parameter id="NoOfRegions"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
</parameters>
</docu>
</procedure>
<procedure name="_Retrieve_CVLA_Data">
<interface>
<ic>
<par name="CVLATupleVector4Eachntensity" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="NoOfCVLARect" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="CVLAModelIDs" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLATeachCols" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLADatum" base_type="ctrl" dimension="0"/>
<par name="CVLADatumModelID" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachRows" base_type="ctrl" dimension="0"/>
<par name="CVLADatumTeachCols" base_type="ctrl" dimension="0"/>
<par name="CVLARefRotationAngle" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointRow" base_type="ctrl" dimension="0"/>
<par name="CVLARefPointColumn" base_type="ctrl" dimension="0"/>
<par name="NoOfCVLArectFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachRowsFL" base_type="ctrl" dimension="0"/>
<par name="CVLATeachColsFL" base_type="ctrl" dimension="0"/>
<par name="MaxDistanceBtnCLFL" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>NoOfCVLARect            := CVLATupleVector4Eachntensity.at(1)</l>
<l>MaxRotationAngle        := CVLATupleVector4Eachntensity.at(2)</l>
<l>PatternSearchAreaAlongX := CVLATupleVector4Eachntensity.at(3)</l>
<l>PatternSearchAreaAlongY := CVLATupleVector4Eachntensity.at(4)</l>
<l>MinAcceptanceScore      := CVLATupleVector4Eachntensity.at(5)               </l>
<l>CVLAModelIDs            := CVLATupleVector4Eachntensity.at(6)</l>
<l>CVLATeachRows           := CVLATupleVector4Eachntensity.at(7)</l>
<l>CVLATeachCols           := CVLATupleVector4Eachntensity.at(8)</l>
<c></c>
<l>NoOfCVLADatum           := CVLATupleVector4Eachntensity.at(9)</l>
<l>CVLADatumModelID        := CVLATupleVector4Eachntensity.at(10)</l>
<l>CVLADatumTeachRows      := CVLATupleVector4Eachntensity.at(11)</l>
<l>CVLADatumTeachCols      := CVLATupleVector4Eachntensity.at(12)  </l>
<c></c>
<l>CVLARefRotationAngle    := CVLATupleVector4Eachntensity.at(13)</l>
<l>CVLARefPointRow         := CVLATupleVector4Eachntensity.at(14)</l>
<l>CVLARefPointColumn      := CVLATupleVector4Eachntensity.at(15)</l>
<c></c>
<l>NoOfCVLArectFL          := CVLATupleVector4Eachntensity.at(16)</l>
<l>CVLATeachRowsFL         := CVLATupleVector4Eachntensity.at(17)</l>
<l>CVLATeachColsFL         := CVLATupleVector4Eachntensity.at(18)</l>
<c></c>
<l>MaxDistanceBtnCLFL     := CVLATupleVector4Eachntensity.at(19)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Retrieve_CVLA_Data">
<parameters>
<parameter id="CVLADatumModelID"/>
<parameter id="CVLADatumTeachCols"/>
<parameter id="CVLADatumTeachRows"/>
<parameter id="CVLAModelIDs"/>
<parameter id="CVLARefPointColumn"/>
<parameter id="CVLARefPointRow"/>
<parameter id="CVLARefRotationAngle"/>
<parameter id="CVLATeachCols"/>
<parameter id="CVLATeachColsFL"/>
<parameter id="CVLATeachRows"/>
<parameter id="CVLATeachRowsFL"/>
<parameter id="CVLATupleVector4Eachntensity"/>
<parameter id="MaxDistanceBtnCLFL"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="NoOfCVLADatum"/>
<parameter id="NoOfCVLARect"/>
<parameter id="NoOfCVLArectFL"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
</parameters>
</docu>
</procedure>
<procedure name="_Retrieve_Tilt_Data">
<interface>
<ic>
<par name="TiltTupleVector4Eachntensity" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="TiltRectRows" base_type="ctrl" dimension="0"/>
<par name="TiltRectCols" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>TiltRectRows := TiltTupleVector4Eachntensity.at(1)</l>
<l>TiltRectCols := TiltTupleVector4Eachntensity.at(2)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Retrieve_Tilt_Data">
<parameters>
<parameter id="TiltRectCols"/>
<parameter id="TiltRectRows"/>
<parameter id="TiltTupleVector4Eachntensity"/>
</parameters>
</docu>
</procedure>
<procedure name="_Tilt_TeachTupleVector">
<interface>
<ic>
<par name="TiltTupleVector" base_type="ctrl" dimension="3"/>
<par name="TiltTeachDoc" base_type="ctrl" dimension="0"/>
<par name="TiltRectRows" base_type="ctrl" dimension="0"/>
<par name="TiltRectCols" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TiltTupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<l>TiltTupleVectorOut := TiltTupleVector</l>
<l>TiltTupleVectorOut.at(FoV-1).at(i).insert(0,TiltTeachDoc)</l>
<l>TiltTupleVectorOut.at(FoV-1).at(i).insert(1,TiltRectRows)</l>
<l>TiltTupleVectorOut.at(FoV-1).at(i).insert(2,TiltRectCols)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_Tilt_TeachTupleVector">
<parameters>
<parameter id="FoV"/>
<parameter id="TiltRectCols"/>
<parameter id="TiltRectRows"/>
<parameter id="TiltTeachDoc"/>
<parameter id="TiltTupleVector"/>
<parameter id="TiltTupleVectorOut"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="AppendTeachLocation">
<interface>
<ic>
<par name="TopTupleVector" base_type="ctrl" dimension="3"/>
<par name="NoOfLocationTeachRegs" base_type="ctrl" dimension="0"/>
<par name="DeviceWidth" base_type="ctrl" dimension="0"/>
<par name="DeviceHeight" base_type="ctrl" dimension="0"/>
<par name="MinDeviceContrast" base_type="ctrl" dimension="0"/>
<par name="NoOfUniquePatterns" base_type="ctrl" dimension="0"/>
<par name="MaxRotationAngle" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="PatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="MinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="PatternTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectRows" base_type="ctrl" dimension="0"/>
<par name="LocationTeachRectCols" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="PatternDegree" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="TeachLocDoc" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="i" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TopTupleVectorOut" base_type="ctrl" dimension="3"/>
</oc>
</interface>
<body>
<l>TopTupleVectorOut := TopTupleVector</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(0,NoOfLocationTeachRegs)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(1,DeviceWidth)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(2,DeviceHeight)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(3,MinDeviceContrast)</l>
<c></c>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(4,NoOfUniquePatterns)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(5,MaxRotationAngle)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(6,PatternSearchAreaAlongX)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(7,PatternSearchAreaAlongY)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(8,MinAcceptanceScore)</l>
<c></c>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(9,PatternTeachRectRows)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(10,PatternTeachRectCols)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(11,LocationTeachRectRows)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(12,LocationTeachRectCols)</l>
<c></c>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(13,ModelIDs)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(14,PatternDegree)</l>
<c></c>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(15,MatchModelCenterRow)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(16,MatchModelCenterColumn)</l>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(17,MaskSize)</l>
<c></c>
<l>TopTupleVectorOut.at(FoV-1).at(i).insert(18,TeachLocDoc)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="AppendTeachLocation">
<parameters>
<parameter id="DeviceHeight"/>
<parameter id="DeviceWidth"/>
<parameter id="FoV"/>
<parameter id="LocationTeachRectCols"/>
<parameter id="LocationTeachRectRows"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelCenterColumn"/>
<parameter id="MatchModelCenterRow"/>
<parameter id="MaxRotationAngle"/>
<parameter id="MinAcceptanceScore"/>
<parameter id="MinDeviceContrast"/>
<parameter id="ModelIDs"/>
<parameter id="NoOfLocationTeachRegs"/>
<parameter id="NoOfUniquePatterns"/>
<parameter id="PatternDegree"/>
<parameter id="PatternSearchAreaAlongX"/>
<parameter id="PatternSearchAreaAlongY"/>
<parameter id="PatternTeachRectCols"/>
<parameter id="PatternTeachRectRows"/>
<parameter id="TeachLocDoc"/>
<parameter id="TopTupleVector"/>
<parameter id="TopTupleVectorOut"/>
<parameter id="i"/>
</parameters>
</docu>
</procedure>
<procedure name="AppendTeachPVI">
<interface>
<ic>
<par name="TopPVITupleVector" base_type="ctrl" dimension="4"/>
<par name="NoOfPVIAreas" base_type="ctrl" dimension="0"/>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="PVI2DCenter" base_type="ctrl" dimension="0"/>
<par name="PVISize" base_type="ctrl" dimension="0"/>
<par name="Mask2DCenterPoints" base_type="ctrl" dimension="0"/>
<par name="MaskAngleConcat" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
<par name="fov" base_type="ctrl" dimension="0"/>
<par name="Doc" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TopPVITupleVectorOut" base_type="ctrl" dimension="4"/>
</oc>
</interface>
<body>
<c></c>
<l>TopPVITupleVectorOut := TopPVITupleVector</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(0,NoOfPVIAreas)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(1,NoOfMaskRegions)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(2,PVIAngle)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(3,PVI2DCenter)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(4,PVISize)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(5,Mask2DCenterPoints)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(6,MaskAngleConcat)</l>
<l>TopPVITupleVectorOut.at(fov-1).at(Doc).at(nPVIArea).insert(7,MaskSize)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="AppendTeachPVI">
<parameters>
<parameter id="Doc"/>
<parameter id="Mask2DCenterPoints"/>
<parameter id="MaskAngleConcat"/>
<parameter id="MaskSize"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="NoOfPVIAreas"/>
<parameter id="PVI2DCenter"/>
<parameter id="PVIAngle"/>
<parameter id="PVISize"/>
<parameter id="TopPVITupleVector"/>
<parameter id="TopPVITupleVectorOut"/>
<parameter id="fov"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="ConcatTuple">
<interface>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="EncapCenterRow" base_type="ctrl" dimension="0"/>
<par name="EncapCenterColumn" base_type="ctrl" dimension="0"/>
<par name="X_Shift" base_type="ctrl" dimension="0"/>
<par name="Y_Shift" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectRows" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectCols" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterRow" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterColumn" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_X_Shift" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_Y_Shift" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EncapInspectRectRowsUpdate" base_type="ctrl" dimension="0"/>
<par name="EncapInspectRectColsUpdate" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterRowUpdate" base_type="ctrl" dimension="0"/>
<par name="EncapInspectCenterColumnUpdate" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_X_ShiftUpdate" base_type="ctrl" dimension="0"/>
<par name="EncaptoEdge_Y_ShiftUpdate" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>tuple_concat (EncapInspectRectRows, [Row1, Row2], EncapInspectRectRowsUpdate)</l>
<l>tuple_concat (EncapInspectRectCols, [Column1,Column2 ], EncapInspectRectColsUpdate)</l>
<c></c>
<l>tuple_concat (EncapInspectCenterRow, EncapCenterRow, EncapInspectCenterRowUpdate)</l>
<l>tuple_concat (EncapInspectCenterColumn, EncapCenterColumn, EncapInspectCenterColumnUpdate)</l>
<c></c>
<l>tuple_concat (EncaptoEdge_X_Shift, X_Shift, EncaptoEdge_X_ShiftUpdate)</l>
<l>tuple_concat (EncaptoEdge_Y_Shift, Y_Shift, EncaptoEdge_Y_ShiftUpdate)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="ConcatTuple">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="EncapCenterColumn"/>
<parameter id="EncapCenterRow"/>
<parameter id="EncapInspectCenterColumn"/>
<parameter id="EncapInspectCenterColumnUpdate"/>
<parameter id="EncapInspectCenterRow"/>
<parameter id="EncapInspectCenterRowUpdate"/>
<parameter id="EncapInspectRectCols"/>
<parameter id="EncapInspectRectColsUpdate"/>
<parameter id="EncapInspectRectRows"/>
<parameter id="EncapInspectRectRowsUpdate"/>
<parameter id="EncaptoEdge_X_Shift"/>
<parameter id="EncaptoEdge_X_ShiftUpdate"/>
<parameter id="EncaptoEdge_Y_Shift"/>
<parameter id="EncaptoEdge_Y_ShiftUpdate"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
<parameter id="X_Shift"/>
<parameter id="Y_Shift"/>
</parameters>
</docu>
</procedure>
<procedure name="GetEdgeLine">
<interface>
<io>
<par name="image" base_type="iconic" dimension="0"/>
<par name="edgeSearchRoi" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="edgeSideID" base_type="ctrl" dimension="0"/>
<par name="edgeContrast" base_type="ctrl" dimension="0"/>
<par name="maxAngleDiffDeg" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="edgeLinePoints" base_type="ctrl" dimension="0"/>
<par name="isPass" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*// Kind of edge</c>
<l>ANY_COLOR:=2</l>
<l>BLACK:=1</l>
<l>WHITE:=0</l>
<c></c>
<c>* //Side id: 0: Left to right, 1: Top to bottom, 2: Right to left, 3: Bottom to top </c>
<l>LEFT_TO_RIGHT := 0</l>
<l>TOP_TO_BOTTOM := 1</l>
<l>RIGHT_TO_LEFT := 2</l>
<l>BOTTOM_TO_TOP := 3</l>
<c></c>
<c>*small values result in strong smoothing for detecting edges</c>
<l>smoothFactor := 1.5</l>
<c></c>
<c>* Angle rad to filter vertical &amp; horizontal egde</c>
<l>refOrientation := rad(90)</l>
<l>angleTolerance := rad(maxAngleDiffDeg)</l>
<l>verticalLowerLimit := [refOrientation - angleTolerance,refOrientation - angleTolerance -rad(180),refOrientation - angleTolerance + rad(180)]</l>
<l>verticalUpperLimit := [refOrientation + angleTolerance,refOrientation + angleTolerance - rad(180),refOrientation + angleTolerance + rad(180)]</l>
<c></c>
<l>refOrientation := rad(0)</l>
<l>angleTolerance := rad(maxAngleDiffDeg)</l>
<l>horizontalLowerLimit := [refOrientation - angleTolerance,refOrientation - angleTolerance -rad(180),refOrientation - angleTolerance + rad(180)]</l>
<l>horizontalUpperLimit := [refOrientation + angleTolerance,refOrientation + angleTolerance - rad(180),refOrientation + angleTolerance + rad(180)]</l>
<c></c>
<l>tuple_gen_const (4, 0, edgeLinePoints)</l>
<l>isPass:= 0</l>
<c></c>
<c>*</c>
<c>* Start processing</c>
<c></c>
<l>region_features(edgeSearchRoi, 'width', regionSearchWidth)</l>
<l>region_features(edgeSearchRoi, 'height', regionSearchHeight)</l>
<l>minContourLength := (regionSearchWidth[0] + regionSearchHeight[0])/4</l>
<c></c>
<l>reduce_domain (image, edgeSearchRoi, ImageReduced)</l>
<c></c>
<c>* / The vertical line</c>
<l>if(edgeSideID % 2 = 0)</l>
<c>    * Detect the real edges</c>
<l>    edges_sub_pix (ImageReduced, edgesInspect, 'canny', smoothFactor, edgeContrast, 2*edgeContrast)</l>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    if(edgesInspectCount = 0)</l>
<l>        isPass := 0</l>
<l>        return()</l>
<l>    endif</l>
<c>    </c>
<l>    union_collinear_contours_xld (edgesInspect, edgesInspect, minContourLength, minContourLength, 2, 0.1, 'attr_keep')</l>
<c>    </c>
<c>    </c>
<c>    */Filter vertical edge by angle</c>
<l>    gen_polygons_xld (edgesInspect, Polygons, 'ramer', 2)</l>
<l>    split_contours_xld (Polygons, edgesInspectSplited, 'polygon', 1, 5)</l>
<l>    select_shape_xld (edgesInspectSplited, edgesInspect, ['phi_points','phi_points','phi_points'], 'or', verticalLowerLimit, verticalUpperLimit)</l>
<c>    </c>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    if(edgesInspectCount = 0)</l>
<l>        smoothFactor := 1.2</l>
<c>         * Detect the real edges</c>
<l>        edges_sub_pix (ImageReduced, edgesInspect, 'canny', smoothFactor, edgeContrast , 2*edgeContrast)</l>
<l>        count_obj(edgesInspect, edgesInspectCount)</l>
<l>        if(edgesInspectCount = 0)</l>
<l>            isPass := false</l>
<l>            return()</l>
<l>        endif</l>
<c>        </c>
<l>        union_collinear_contours_xld (edgesInspect, edgesInspect, minContourLength, minContourLength, 2, 0.1, 'attr_keep')</l>
<c>        </c>
<c>        */Filter vertical edge by angle</c>
<l>        gen_polygons_xld (edgesInspect, Polygons, 'ramer', 2)</l>
<l>        split_contours_xld (Polygons, edgesInspectSplited, 'polygon', 1, 5)</l>
<l>        select_shape_xld (edgesInspectSplited, edgesInspect, ['phi_points','phi_points','phi_points'], 'or', horizontalLowerLimit, horizontalUpperLimit)</l>
<c>        </c>
<l>        count_obj(edgesInspect, edgesInspectCount)</l>
<l>        if(edgesInspectCount = 0)</l>
<l>            isPass := false</l>
<l>            return()</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<c>    *Fit the contour by the line</c>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    gen_empty_obj(candidatesLines)</l>
<l>    for Index := 1 to edgesInspectCount by 1</l>
<l>        select_obj(edgesInspect, ObjectSelected, Index)</l>
<l>        fit_line_contour_xld (ObjectSelected, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>        gen_contour_polygon_xld (ObjectSelectedLine, [RowBegin[0], RowEnd[0]], [ColBegin[0], ColEnd[0]])</l>
<l>        concat_obj(candidatesLines, ObjectSelectedLine, candidatesLines)</l>
<l>    endfor</l>
<c>    </c>
<l>    union_collinear_contours_xld (candidatesLines, verticalLines, 3*minContourLength, 3*minContourLength, 4, 0.1, 'attr_keep')</l>
<c>    </c>
<c>        * /Get heighest region</c>
<l>    gen_region_contour_xld(verticalLines, verticalLineRegions, 'filled')</l>
<l>    region_features(verticalLineRegions, 'height', verticalLineRegionsHeight)</l>
<c>    </c>
<c>    * If we have more than one contour </c>
<l>    maxHeight := max(verticalLineRegionsHeight)</l>
<l>    candidatevertical := verticalLineRegionsHeight [&gt;=] 0.5*maxHeight</l>
<l>    lib_Mask2Index (candidatevertical, candidateverticalIdx)</l>
<l>    if(|candidateverticalIdx| &gt; 1)</l>
<c>        * Choose the longest contour</c>
<l>        candidateverticalIdx := candidateverticalIdx + 1</l>
<l>        select_obj(verticalLines, edgesInspectCandidate, candidateverticalIdx)</l>
<l>        area_center_points_xld (edgesInspectCandidate, Area1, Row, Column)</l>
<c>    </c>
<c>        * Left and Right Side edges</c>
<l>        if(edgeSideID = LEFT_TO_RIGHT)</l>
<l>            select_obj(edgesInspectCandidate, verticalLine, find(Column, min(Column))[0] + 1)</l>
<l>        elseif(edgeSideID = RIGHT_TO_LEFT)</l>
<l>            select_obj(edgesInspectCandidate, verticalLine, find(Column, max(Column))[0] + 1)</l>
<l>        endif</l>
<l>    else</l>
<l>        select_obj(verticalLines, verticalLine, find(verticalLineRegionsHeight, maxHeight)[0] + 1)</l>
<l>    endif</l>
<c>    </c>
<l>    fit_line_contour_xld (verticalLine, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>    edgeLinePoints := [RowBegin[0], ColBegin[0], RowEnd[0], ColEnd[0]]</l>
<l>    isPass := true</l>
<l>else</l>
<c>    * / The horizontal line</c>
<c>    * Detect the real edges</c>
<c>    </c>
<l>    edges_sub_pix (ImageReduced, edgesInspect, 'canny', smoothFactor, edgeContrast , 2*edgeContrast)</l>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    if(edgesInspectCount = 0)</l>
<l>        isPass := false</l>
<l>        return()</l>
<l>    endif</l>
<c>    </c>
<l>    union_collinear_contours_xld (edgesInspect, edgesInspect, minContourLength, minContourLength, 2, 0.1, 'attr_keep')</l>
<c>    </c>
<c>    */Filter horizontal edge by angle</c>
<l>    gen_polygons_xld (edgesInspect, Polygons, 'ramer', 2)</l>
<l>    split_contours_xld (Polygons, edgesInspectSplited, 'polygon', 1, 5)</l>
<l>    select_shape_xld (edgesInspectSplited, edgesInspect, ['phi_points','phi_points','phi_points'], 'or', horizontalLowerLimit, horizontalUpperLimit)</l>
<c>    </c>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    if(edgesInspectCount = 0)</l>
<l>        smoothFactor := 1.2</l>
<c>         * Detect the real edges</c>
<l>        edges_sub_pix (ImageReduced, edgesInspect, 'canny', smoothFactor, edgeContrast , 2*edgeContrast)</l>
<l>        count_obj(edgesInspect, edgesInspectCount)</l>
<l>        if(edgesInspectCount = 0)</l>
<l>            isPass := false</l>
<l>            return()</l>
<l>        endif</l>
<c>        </c>
<l>        union_collinear_contours_xld (edgesInspect, edgesInspect, minContourLength, minContourLength, 2, 0.1, 'attr_keep')</l>
<c>        </c>
<c>        */Filter horizontal edge by angle</c>
<l>        gen_polygons_xld (edgesInspect, Polygons, 'ramer', 2)</l>
<l>        split_contours_xld (Polygons, edgesInspectSplited, 'polygon', 1, 5)</l>
<l>        select_shape_xld (edgesInspectSplited, edgesInspect, ['phi_points','phi_points','phi_points'], 'or', horizontalLowerLimit, horizontalUpperLimit)</l>
<c>        </c>
<l>        count_obj(edgesInspect, edgesInspectCount)</l>
<l>        if(edgesInspectCount = 0)</l>
<l>            isPass := false</l>
<l>            return()</l>
<l>        endif</l>
<c>      </c>
<l>    endif</l>
<c>    </c>
<c>    *Fit the contour by the line</c>
<l>    count_obj(edgesInspect, edgesInspectCount)</l>
<l>    gen_empty_obj(candidatesLines)</l>
<l>    for Index := 1 to edgesInspectCount by 1</l>
<l>        select_obj(edgesInspect, ObjectSelected, Index)</l>
<l>        fit_line_contour_xld (ObjectSelected, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>        gen_contour_polygon_xld (ObjectSelectedLine, [RowBegin[0], RowEnd[0]], [ColBegin[0], ColEnd[0]])</l>
<l>        concat_obj(candidatesLines, ObjectSelectedLine, candidatesLines)</l>
<l>    endfor</l>
<c>    </c>
<l>    union_collinear_contours_xld (candidatesLines, horizontalLines, 3*minContourLength, 3*minContourLength, 4, 0.1, 'attr_keep')</l>
<c>    </c>
<c>     * /Get longest region</c>
<l>    gen_region_contour_xld(horizontalLines, horizontalLinesRegions, 'filled')</l>
<l>    region_features(horizontalLinesRegions, 'width', horizontalLinesRegionsWidth)</l>
<c>    </c>
<c>    * If we have more than one contour </c>
<l>    maxWidth := max(horizontalLinesRegionsWidth)</l>
<l>    candidatehHorizontal := horizontalLinesRegionsWidth [&gt;=] 0.5*maxWidth</l>
<l>    lib_Mask2Index (candidatehHorizontal, candidatehHorizontalIdx)</l>
<l>    if(|candidatehHorizontalIdx| &gt; 1)</l>
<c>        * Choose the longest contour</c>
<l>        candidatehHorizontalIdx := candidatehHorizontalIdx + 1</l>
<l>        select_obj(horizontalLines, edgesInspectCandidate, candidatehHorizontalIdx)</l>
<l>        area_center_points_xld (edgesInspectCandidate, Area1, Row, Column)</l>
<c>    </c>
<c>        * Top and Bottom edges </c>
<l>        if(edgeSideID = TOP_TO_BOTTOM)</l>
<l>            select_obj(edgesInspectCandidate, horizontalLine, find(Row, min(Row))[0] + 1)</l>
<l>        elseif(edgeSideID = BOTTOM_TO_TOP)</l>
<l>            select_obj(edgesInspectCandidate, horizontalLine, find(Row, max(Row))[0] + 1)</l>
<l>        endif</l>
<l>    else</l>
<l>        select_obj(horizontalLines, horizontalLine, find(horizontalLinesRegionsWidth, maxWidth)[0] + 1)</l>
<l>    endif</l>
<c>    </c>
<c>    *Fit the contour by the line</c>
<l>    fit_line_contour_xld (horizontalLine, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>    edgeLinePoints := [RowBegin[0], ColBegin[0], RowEnd[0], ColEnd[0]]</l>
<l>    isPass := true</l>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="GetEdgeLine">
<parameters>
<parameter id="edgeContrast"/>
<parameter id="edgeLinePoints"/>
<parameter id="edgeSearchRoi"/>
<parameter id="edgeSideID"/>
<parameter id="image"/>
<parameter id="isPass"/>
<parameter id="maxAngleDiffDeg"/>
</parameters>
</docu>
</procedure>
<procedure name="GetEdgeMidPoints">
<interface>
<io>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MidRow" base_type="ctrl" dimension="0"/>
<par name="MidColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>smallest_rectangle2(DeviceLocationSelected, Row3, Column3, Phi2, Length11, Length21)</l>
<l>tuple_floor ([Row3, Column3,Length11, Length21], Floor)</l>
<c></c>
<c></c>
<l>gen_rectangle2(Rectangle1, Floor[0], Floor[1], Phi2, Floor[2], Floor[3]-0.25*Floor[3])</l>
<l>intersection(DeviceLocationSelected, Rectangle1, RegionIntersection1)</l>
<c></c>
<l>hom_mat2d_identity(HomMat2DIdentity)</l>
<l>hom_mat2d_rotate(HomMat2DIdentity, -Phi2, Floor[0], Floor[1], HomMat2DRotate)</l>
<l>affine_trans_region(RegionIntersection1, RegionAffineTrans, HomMat2DRotate, 'nearest_neighbor')</l>
<c></c>
<l>smallest_rectangle1(RegionAffineTrans, Row12, Column12, Row22, Column22)</l>
<l>gen_rectangle1(Rectangle2, Row12, Column12, Row22, Column22)</l>
<c></c>
<c></c>
<l>if(FoV = nFoVs)</l>
<l>    MidRow := (Row12+Row22)/2</l>
<l>    MidColumn := Column22</l>
<l>else</l>
<l>    MidRow     := (Row12+Row22)/2 </l>
<l>    MidColumn  := Column12</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>gen_region_points(Region, MidRow, MidColumn)</l>
<l>gen_cross_contour_xld(Cross3, MidRow, MidColumn, 50, Phi2)</l>
<l>hom_mat2d_identity(HomMat2DIdentity)</l>
<l>hom_mat2d_rotate(HomMat2DIdentity, Phi2, Floor[0], Floor[1], HomMat2DRotate)</l>
<l>affine_trans_region(Region, RegionAffineTrans1, HomMat2DRotate, 'nearest_neighbor')</l>
<l>area_center(RegionAffineTrans1, Dummy, MidRow, MidColumn)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetEdgeMidPoints">
<parameters>
<parameter id="DeviceLocationSelected"/>
<parameter id="FoV"/>
<parameter id="MidColumn"/>
<parameter id="MidRow"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="GetLocationCenter">
<interface>
<io>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="LocationCenterRow" base_type="ctrl" dimension="0"/>
<par name="LocationCenterColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>area_center (DeviceLocationSelected, Dummy, LocationCenterRow, LocationCenterColumn)</l>
<c></c>
<l>tuple_floor (LocationCenterRow, LocationCenterRow)</l>
<l>tuple_floor (LocationCenterColumn, LocationCenterColumn)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetLocationCenter">
<parameters>
<parameter id="DeviceLocationSelected"/>
<parameter id="LocationCenterColumn"/>
<parameter id="LocationCenterRow"/>
</parameters>
</docu>
</procedure>
<procedure name="GetRegionCenter">
<interface>
<oo>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RegionCenterRow" base_type="ctrl" dimension="0"/>
<par name="RegionCenterColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_rectangle1 (PVIRegion, Row1, Column1, Row2, Column2)</l>
<l>area_center (PVIRegion, Dummy, RegionCenterRow, RegionCenterColumn)</l>
<c></c>
<l>tuple_floor (RegionCenterRow, RegionCenterRow)</l>
<l>tuple_floor (RegionCenterColumn, RegionCenterColumn)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="GetRegionCenter">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="PVIRegion"/>
<parameter id="RegionCenterColumn"/>
<parameter id="RegionCenterRow"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
</parameters>
</docu>
</procedure>
<procedure name="GetRelativeDistance">
<interface>
<ic>
<par name="MidRow" base_type="ctrl" dimension="0"/>
<par name="MidColumn" base_type="ctrl" dimension="0"/>
<par name="RegionCenterRow" base_type="ctrl" dimension="0"/>
<par name="RegionCenterColumn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="X_Shift" base_type="ctrl" dimension="0"/>
<par name="Y_Shift" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>X_Shift := MidRow-RegionCenterRow</l>
<l>Y_Shift := MidColumn-RegionCenterColumn</l>
<l>return ()</l>
</body>
<docu id="GetRelativeDistance">
<parameters>
<parameter id="MidColumn"/>
<parameter id="MidRow"/>
<parameter id="RegionCenterColumn"/>
<parameter id="RegionCenterRow"/>
<parameter id="X_Shift"/>
<parameter id="Y_Shift"/>
</parameters>
</docu>
</procedure>
<procedure name="GetTopReferenceTeachValues">
<interface>
<oo>
<par name="Rectangle2" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DeviceTopColumn" base_type="ctrl" dimension="0"/>
<par name="PVITopColumn" base_type="ctrl" dimension="0"/>
<par name="DeviceTopRow" base_type="ctrl" dimension="0"/>
<par name="PVITopRow" base_type="ctrl" dimension="0"/>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="DeviceAngle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TopX_Shift" base_type="ctrl" dimension="0"/>
<par name="TopY_Shift" base_type="ctrl" dimension="0"/>
<par name="Rect2PVIRowCenter" base_type="ctrl" dimension="0"/>
<par name="Rect2PVIColCenter" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="PVIWidth" base_type="ctrl" dimension="0"/>
<par name="PVIHeight" base_type="ctrl" dimension="0"/>
<par name="RelativeAngle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>TopX_Shift :=DeviceTopColumn-PVITopColumn</l>
<l>TopY_Shift :=DeviceTopRow-PVITopRow</l>
<c></c>
<l>gen_rectangle1 (Rectangle2, Row1, Column1, Row2, Column2)</l>
<l>smallest_rectangle2 (Rectangle2, Rect2PVIRowCenter, Rect2PVIColCenter, PVIAngle, PVIWidth, PVIHeight)</l>
<l>RelativeAngle :=DeviceAngle-PVIAngle</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetTopReferenceTeachValues">
<parameters>
<parameter id="Column1"/>
<parameter id="Column2"/>
<parameter id="DeviceAngle"/>
<parameter id="DeviceTopColumn"/>
<parameter id="DeviceTopRow"/>
<parameter id="PVIAngle"/>
<parameter id="PVIHeight"/>
<parameter id="PVITopColumn"/>
<parameter id="PVITopRow"/>
<parameter id="PVIWidth"/>
<parameter id="Rect2PVIColCenter"/>
<parameter id="Rect2PVIRowCenter"/>
<parameter id="Rectangle2"/>
<parameter id="RelativeAngle"/>
<parameter id="Row1"/>
<parameter id="Row2"/>
<parameter id="TopX_Shift"/>
<parameter id="TopY_Shift"/>
</parameters>
</docu>
</procedure>
<procedure name="lib_Mask2Index">
<interface>
<ic>
<par name="mask" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="index" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>index := select_mask([0:1:|mask|-1],mask)</l>
<l>return ()</l>
</body>
<docu id="lib_Mask2Index">
<parameters>
<parameter id="index"/>
<parameter id="mask"/>
</parameters>
</docu>
</procedure>
<procedure name="Projection_Back_Function">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="RegionAffineTrans" base_type="iconic" dimension="0"/>
<par name="ImageRotate" base_type="iconic" dimension="0"/>
<par name="FitMaskRegion" base_type="iconic" dimension="0"/>
<par name="PVIRegion" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionAffineTrans1" base_type="iconic" dimension="0"/>
<par name="ImageRotateShift" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="XShiftValue" base_type="ctrl" dimension="0"/>
<par name="YShiftValue" base_type="ctrl" dimension="0"/>
<par name="OffsetX" base_type="ctrl" dimension="0"/>
<par name="OffsetY" base_type="ctrl" dimension="0"/>
<par name="AngleDiff" base_type="ctrl" dimension="0"/>
<par name="DeviceTopRowInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceTopColumnInspect" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<c></c>
<c>****</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_translate (HomMat2DIdentity, XShiftValue-OffsetX, YShiftValue-OffsetY, HomMat2DTranslate)</l>
<l>hom_mat2d_rotate (HomMat2DTranslate, AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, HomMat2DRotate)</l>
<c></c>
<l>affine_trans_region (PVIRegion, PVIRegionAffineTrans, HomMat2DRotate, 'nearest_neighbor')</l>
<l>affine_trans_region (FitMaskRegion, MaskRegionAffineTrans, HomMat2DRotate, 'nearest_neighbor')</l>
<c></c>
<c></c>
<l>affine_trans_region (RegionAffineTrans, RegionAffineTrans1, HomMat2DRotate, 'nearest_neighbor')</l>
<l>affine_trans_image(ImageRotate, ImageRotateShift, HomMat2DRotate, 'constant', 'false')</l>
<c></c>
<c>******</c>
<c></c>
<l>if(IsStepMode)</l>
<c>    </c>
<l>    Message := [' Projected PVI Area['+(nPVIArea+1)+']']</l>
<l>    _FCI_DebugParameters (InspectImage, PVIRegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>if(IsStepMode)</l>
<c>    </c>
<l>    Message := [' Projected Mask Regions for PVI Area['+(nPVIArea+1)+']']</l>
<l>    _FCI_DebugParameters (InspectImage, MaskRegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>    </c>
<l>endif</l>
<c></c>
<l>if (IsStepMode)</l>
<c>    </c>
<l>    reduce_domain (ImageRotateShift, RegionAffineTrans1, ImageReduced)</l>
<l>    Message := ['Projection of the processed Sub-Image and Region of Area['+(nPVIArea+1)+'] ']</l>
<l>    _FCI_DebugParameters (ImageReduced, RegionAffineTrans1, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c></c>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="Projection_Back_Function">
<parameters>
<parameter id="AngleDiff"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceTopColumnInspect"/>
<parameter id="DeviceTopRowInspect"/>
<parameter id="FitMaskRegion"/>
<parameter id="ImageRotate"/>
<parameter id="ImageRotateShift"/>
<parameter id="InspectImage"/>
<parameter id="IsStepMode"/>
<parameter id="OffsetX"/>
<parameter id="OffsetY"/>
<parameter id="PVIRegion"/>
<parameter id="RegionAffineTrans"/>
<parameter id="RegionAffineTrans1"/>
<parameter id="XShiftValue"/>
<parameter id="YShiftValue"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="Projection_Function">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionAffineTrans" base_type="iconic" dimension="0"/>
<par name="ImageRotate" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="AngleDiff" base_type="ctrl" dimension="0"/>
<par name="DeviceTopRowInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceTopColumnInspect" base_type="ctrl" dimension="0"/>
<par name="XShiftValue" base_type="ctrl" dimension="0"/>
<par name="YShiftValue" base_type="ctrl" dimension="0"/>
<par name="OffsetX" base_type="ctrl" dimension="0"/>
<par name="OffsetY" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, HomMat2DRotate)                   </l>
<l>hom_mat2d_translate (HomMat2DRotate, XShiftValue-OffsetX, YShiftValue-OffsetY, HomMat2DTranslate)</l>
<l>affine_trans_region(DeviceLocationSelected, RegionAffineTrans, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>affine_trans_image(InspectImage, ImageRotate, HomMat2DTranslate, 'constant', 'false')</l>
<c></c>
<l>if (IsStepMode)</l>
<c>    </c>
<l>    Message := ['Projection of the Inspected Image and Region on the Teach Location']</l>
<l>    _FCI_DebugParameters (ImageRotate, RegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c></c>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="Projection_Function">
<parameters>
<parameter id="AngleDiff"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="DeviceTopColumnInspect"/>
<parameter id="DeviceTopRowInspect"/>
<parameter id="ImageRotate"/>
<parameter id="InspectImage"/>
<parameter id="IsStepMode"/>
<parameter id="OffsetX"/>
<parameter id="OffsetY"/>
<parameter id="RegionAffineTrans"/>
<parameter id="XShiftValue"/>
<parameter id="YShiftValue"/>
</parameters>
</docu>
</procedure>
<procedure name="PVI_Inspection_ReCheck">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="TeachObj" base_type="iconic" dimension="0"/>
<par name="PVI_DefectRegion" base_type="iconic" dimension="0"/>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ActualPVIDefect" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="Row6" base_type="ctrl" dimension="0"/>
<par name="Column6" base_type="ctrl" dimension="0"/>
<par name="InspectRotationAngle" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongRow" base_type="ctrl" dimension="0"/>
<par name="InspectShiftAlongColumn" base_type="ctrl" dimension="0"/>
<par name="DefectCharacteristics" base_type="ctrl" dimension="0"/>
<par name="DefectCount" base_type="ctrl" dimension="0"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
<par name="MinMeanGVDiff" base_type="ctrl" dimension="0"/>
<par name="UpperHysBound" base_type="ctrl" dimension="0"/>
<par name="bRecheckEnable" base_type="ctrl" dimension="0"/>
<par name="Bool" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="IsPass" base_type="ctrl" dimension="0"/>
<par name="AllPVIDefectMinSize" base_type="ctrl" dimension="0"/>
<par name="AllPVIDefecMinLength" base_type="ctrl" dimension="0"/>
<par name="AllPVIDefecMinSquareSize" base_type="ctrl" dimension="0"/>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>gen_empty_obj (ActualPVIDefect)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<c>*</c>
<l>IsPass := true</l>
<l>AllPVIDefectMinSize        := 0</l>
<l>AllPVIDefecMinLength       := 0</l>
<l>AllPVIDefecMinSquareSize   := 0</l>
<c></c>
<c>*</c>
<l>if(UpperHysBound &lt;= 10)</l>
<l>    LowerHysBound := 1</l>
<l>    UpperHysBound := 10</l>
<l>else</l>
<l>    LowerHysBound := UpperHysBound  - 10</l>
<l>endif</l>
<c></c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, InspectRotationAngle, Row6, Column6, HomMat2DRotate) </l>
<l>hom_mat2d_translate (HomMat2DRotate, InspectShiftAlongRow, InspectShiftAlongColumn, HomMat2DTranslate)</l>
<c></c>
<l>affine_trans_region(PVI_DefectRegion, RegionAffineRotateShift, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>affine_trans_region(RegionForPVI_Inspection, RegionForPVI_Inspection, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>affine_trans_image(InspectImage, ImageRotateShift, HomMat2DTranslate, 'nearest_neighbor', 'false')</l>
<c></c>
<c>*</c>
<c>** Remove Defect Overkills due to Teach Image</c>
<c></c>
<l>intensity (RegionAffineRotateShift, TeachObj, Mean, Deviation)</l>
<l>intensity (RegionAffineRotateShift, ImageRotateShift, Mean1, Deviation)</l>
<l>DiffMeanForReCheck:= Mean-Mean1</l>
<c></c>
<l>gen_empty_obj (PVIDefect_Allign_Teach)</l>
<l>if(DefectCharacteristics=0)</l>
<l>    tuple_greater_elem (DiffMeanForReCheck, 0, Greater1)</l>
<l>    tuple_find (Greater1, 1, Indices)</l>
<l>    if(Indices[0] &gt; -1)</l>
<l>        select_obj (RegionAffineRotateShift, PVIDefect_Allign_Teach, Indices+1)         </l>
<l>    endif</l>
<l>else</l>
<l>    tuple_less_elem (DiffMeanForReCheck, 0, Less)</l>
<l>    tuple_find (Less, 1, Indices)</l>
<l>    if(Indices[0] &gt; -1)</l>
<l>        select_obj (RegionAffineRotateShift, PVIDefect_Allign_Teach, Indices+1)         </l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>* Step Debug </c>
<l>count_obj (PVIDefect_Allign_Teach, Number1)</l>
<l>if(IsStepMode)</l>
<l>    if(Number1 &gt; 0)</l>
<c>        </c>
<l>        if(Bool = true)</l>
<l>            Message := ['Device Edge Defects after removal of Teach Defects']</l>
<l>        else</l>
<l>            Message := [' PVI Defect['+(DefectCount)+'] of Area['+(nPVIArea+1)+'] after removal of Teach Defects']</l>
<l>        endif</l>
<c>        </c>
<l>        hom_mat2d_identity (HomMat2DIdentity)</l>
<l>        hom_mat2d_rotate (HomMat2DIdentity, -InspectRotationAngle, Row6, Column6, HomMat2DRotate) </l>
<l>        hom_mat2d_translate (HomMat2DRotate, -InspectShiftAlongRow, -InspectShiftAlongColumn, HomMat2DTranslate)</l>
<l>        affine_trans_region(PVIDefect_Allign_Teach, PVIDefect_Allign_Insp, HomMat2DTranslate, 'nearest_neighbor')</l>
<c>        </c>
<l>        _FCI_DebugParameters (InspectImage, PVIDefect_Allign_Insp, DebugImageOut, DebugRegionOut, \
                              DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* Recheck 21-05-18</c>
<c>* Check in the Teach Image</c>
<c></c>
<l>gen_empty_obj (EmptyObject)</l>
<c></c>
<l>if(bRecheckEnable)</l>
<c>    </c>
<l>    for i := 1 to Number1 by 1   </l>
<c>        </c>
<l>        select_obj (PVIDefect_Allign_Teach, ObjectSelected, i)</l>
<l>        intensity (ObjectSelected, ImageRotateShift, InnerMean, Deviation1)</l>
<c>        </c>
<l>        dilation_circle (ObjectSelected, RegionDilation2, 5.5)</l>
<l>        difference (RegionDilation2, ObjectSelected, RegionDifference)</l>
<l>        intersection (RegionDifference, RegionForPVI_Inspection, RegionIntersection)</l>
<c>        </c>
<l>        connection (RegionIntersection, ConnectedRegions)</l>
<l>        select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>        intensity (SelectedRegions, ImageRotateShift, OuterMean, Deviation2)</l>
<l>        AbsMeanDifference := abs(InnerMean - OuterMean)</l>
<c>        </c>
<l>        if((DefectCharacteristics == 0) and (InnerMean &lt; OuterMean))</l>
<c>            </c>
<l>            if(AbsMeanDifference &gt;= MinMeanGVDiff)  </l>
<c>                </c>
<l>                dilation_circle (ObjectSelected, RegionDilation, 3.5)</l>
<l>                intersection (RegionDilation, RegionForPVI_Inspection, RegionIntersection)</l>
<c>                </c>
<l>                reduce_domain (ImageRotateShift, RegionIntersection, ImageReducedInspect)</l>
<l>                reduce_domain (TeachObj, RegionIntersection, ImageReducedTeach)</l>
<c>                </c>
<l>                difference (RegionDilation, RegionForPVI_Inspection, RegionDifference1)</l>
<l>                area_center (RegionDifference1, Area1, D, D)</l>
<l>                if(Area1 &gt; 0)</l>
<l>                    expand_domain_gray (ImageReducedInspect, ImageReducedInspect, 1)</l>
<l>                    expand_domain_gray (ImageReducedTeach, ImageReducedTeach, 1)</l>
<l>                endif</l>
<c>                </c>
<l>                mean_image (ImageReducedInspect, ImageMean2, 2.5, 2.5)</l>
<l>                sobel_amp (ImageMean2, EdgeAmplitudeInsp, 'sum_abs', 3)</l>
<c>                </c>
<l>                mean_image (ImageReducedTeach, ImageMean3, 2.5, 2.5)</l>
<l>                sobel_amp (ImageMean3, EdgeAmplitudeTeach, 'sum_abs', 3)</l>
<c>                </c>
<l>                abs_diff_image (EdgeAmplitudeInsp, EdgeAmplitudeTeach, ImageAbsDiff1, 1)</l>
<l>                reduce_domain (ImageAbsDiff1, ObjectSelected, ImageReduced)</l>
<l>                hysteresis_threshold (ImageReduced, RegionHysteresis, LowerHysBound, UpperHysBound, 10)</l>
<l>                area_center (RegionHysteresis, Area, Row, Column)</l>
<c>                </c>
<l>                if(Area &gt; 0)</l>
<l>                    concat_obj (EmptyObject, ObjectSelected, EmptyObject)</l>
<l>                endif</l>
<l>            endif</l>
<l>        endif</l>
<c>        </c>
<l>        if((DefectCharacteristics == 1) and (InnerMean &gt; OuterMean))</l>
<c>            </c>
<l>            if(AbsMeanDifference &gt;= MinMeanGVDiff)</l>
<c>                </c>
<l>                dilation_circle (ObjectSelected, RegionDilation, 3.5)</l>
<l>                intersection (RegionDilation, RegionForPVI_Inspection, RegionIntersection)</l>
<c>                </c>
<l>                reduce_domain (ImageRotateShift, RegionIntersection, ImageReducedInspect)</l>
<l>                reduce_domain (TeachObj, RegionIntersection, ImageReducedTeach)</l>
<c>                </c>
<l>                difference (RegionDilation, RegionForPVI_Inspection, RegionDifference1)</l>
<l>                area_center (RegionDifference1, Area1, D, D)</l>
<l>                if(Area1 &gt; 0)</l>
<l>                    expand_domain_gray (ImageReducedInspect, ImageReducedInspect, 1)</l>
<l>                    expand_domain_gray (ImageReducedTeach, ImageReducedTeach, 1)</l>
<l>                endif</l>
<c>                </c>
<l>                mean_image (ImageReducedInspect, ImageMean2, 2.5, 2.5)</l>
<l>                sobel_amp (ImageMean2, EdgeAmplitudeInsp, 'sum_abs', 3)</l>
<c>                </c>
<l>                mean_image (ImageReducedTeach, ImageMean3, 2.5, 2.5)</l>
<l>                sobel_amp (ImageMean3, EdgeAmplitudeTeach, 'sum_abs', 3)</l>
<c>                </c>
<l>                abs_diff_image (EdgeAmplitudeInsp, EdgeAmplitudeTeach, ImageAbsDiff1, 1)</l>
<l>                reduce_domain (ImageAbsDiff1, ObjectSelected, ImageReduced)</l>
<l>                hysteresis_threshold (ImageReduced, RegionHysteresis, LowerHysBound, UpperHysBound, 10)</l>
<l>                area_center (RegionHysteresis, Area, Row, Column)</l>
<c>                </c>
<l>                if(Area &gt; 0)</l>
<l>                    concat_obj (EmptyObject, ObjectSelected, EmptyObject)</l>
<l>                endif</l>
<c>                </c>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<l>    count_obj (EmptyObject, Number)</l>
<l>    if(IsStepMode)</l>
<l>        if(Number &gt; 0)</l>
<c>            </c>
<l>            if(Bool = true)</l>
<l>                Message := ['Device Edge Defects after apply Recheck Procedure[using MinMeanGVDiff and MaxContrast]']</l>
<l>            else</l>
<l>                Message:=[' PVI Defect['+(DefectCount)+'] of Area['+(nPVIArea+1)+'] after apply Recheck Procedure[using MinMeanGVDiff and MaxContrast]']</l>
<l>            endif</l>
<c>            </c>
<l>            hom_mat2d_identity (HomMat2DIdentity)</l>
<l>            hom_mat2d_rotate (HomMat2DIdentity, -InspectRotationAngle, Row6, Column6, HomMat2DRotate) </l>
<l>            hom_mat2d_translate (HomMat2DRotate, -InspectShiftAlongRow, -InspectShiftAlongColumn, HomMat2DTranslate)</l>
<l>            affine_trans_region(EmptyObject, EmptyObjectOL, HomMat2DTranslate, 'nearest_neighbor')</l>
<c>            </c>
<l>            _FCI_DebugParameters (InspectImage, EmptyObjectOL, DebugImageOut, DebugRegionOut, \
                                  DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<c>            </c>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<l>else</l>
<l>    concat_obj (EmptyObject, PVIDefect_Allign_Teach, EmptyObject)</l>
<l>endif</l>
<c></c>
<c></c>
<l>count_obj (EmptyObject, Number2)</l>
<l>if(Number2 &gt; 0)</l>
<c>    </c>
<l>    IsPass := false</l>
<c>    </c>
<l>    region_features (EmptyObject, ['area','max_diameter','width','height'], Value)</l>
<l>    AllPVIDefectMinSize             := Value[0]</l>
<l>    AllPVIDefecMinLength            := Value[1]</l>
<l>    AllPVIDefecMinSquareSize        := min2(Value[2],Value[3])</l>
<c>    </c>
<c>    </c>
<l>    union1 (EmptyObject, RegionUnion)</l>
<l>    dilation_circle (RegionUnion, RegionDilation1, 3.5)</l>
<c>       </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -InspectRotationAngle, Row6, Column6, HomMat2DRotate) </l>
<l>    hom_mat2d_translate (HomMat2DRotate, -InspectShiftAlongRow, -InspectShiftAlongColumn, HomMat2DTranslate)</l>
<l>    affine_trans_region(RegionDilation1, RegionAffine, HomMat2DTranslate, 'nearest_neighbor')</l>
<l>    concat_obj (ActualPVIDefect, RegionAffine, ActualPVIDefect) </l>
<c>    </c>
<l>    if (IsStepMode)</l>
<c>        </c>
<l>        if(Bool = true)</l>
<l>            Message := ['Final Device Edge Defects']</l>
<l>        else</l>
<l>            Message:=[' Final PVI Defect['+(DefectCount)+'] of Area['+(nPVIArea+1)+'] ']</l>
<l>        endif</l>
<c>        </c>
<l>        _FCI_DebugParameters (InspectImage, ActualPVIDefect, DebugImageOut, DebugRegionOut, \
                              DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>    endif </l>
<c>    </c>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="PVI_Inspection_ReCheck">
<parameters>
<parameter id="ActualPVIDefect"/>
<parameter id="AllPVIDefecMinLength"/>
<parameter id="AllPVIDefecMinSquareSize"/>
<parameter id="AllPVIDefectMinSize"/>
<parameter id="Bool"/>
<parameter id="Column6"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DefectCharacteristics"/>
<parameter id="DefectCount"/>
<parameter id="InspectImage"/>
<parameter id="InspectRotationAngle"/>
<parameter id="InspectShiftAlongColumn"/>
<parameter id="InspectShiftAlongRow"/>
<parameter id="IsPass"/>
<parameter id="IsStepMode"/>
<parameter id="MinMeanGVDiff"/>
<parameter id="PVI_DefectRegion"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="Row6"/>
<parameter id="TeachObj"/>
<parameter id="UpperHysBound"/>
<parameter id="bRecheckEnable"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="RegionProjection">
<interface>
<io>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="TeachObj" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="ImageForPVI_Inspection" base_type="iconic" dimension="0"/>
<par name="Sub_Image" base_type="iconic" dimension="0"/>
<par name="FitPVIRegion" base_type="iconic" dimension="0"/>
<par name="FitMaskRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Rect2PVIRowCenter" base_type="ctrl" dimension="0"/>
<par name="Rect2PVIColCenter" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="PVIWidth" base_type="ctrl" dimension="0"/>
<par name="PVIHeight" base_type="ctrl" dimension="0"/>
<par name="TopX_Shift" base_type="ctrl" dimension="0"/>
<par name="TopY_Shift" base_type="ctrl" dimension="0"/>
<par name="DeviceTopRowInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceTopColumnInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceAngle" base_type="ctrl" dimension="0"/>
<par name="DeviceAngleInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPoints" base_type="ctrl" dimension="0"/>
<par name="Device2DCenter" base_type="ctrl" dimension="0"/>
<par name="DeviceSize" base_type="ctrl" dimension="0"/>
<par name="Device2DCenterInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceSizeInspect" base_type="ctrl" dimension="0"/>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="StorePatternTeachRows" base_type="ctrl" dimension="0"/>
<par name="StorePatternTeachCols" base_type="ctrl" dimension="0"/>
<par name="StoreModelID" base_type="ctrl" dimension="0"/>
<par name="StoreMinAcceptanceScore" base_type="ctrl" dimension="0"/>
<par name="StorePatternSearchAreaAlongX" base_type="ctrl" dimension="0"/>
<par name="StorePatternSearchAreaAlongY" base_type="ctrl" dimension="0"/>
<par name="CheckDatumForPVI" base_type="ctrl" dimension="0"/>
<par name="TeachModelRowCenter" base_type="ctrl" dimension="0"/>
<par name="TeachModelColCenter" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="MatchModelCenterColumn" base_type="ctrl" dimension="0"/>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="Mask2DCenterPoints" base_type="ctrl" dimension="0"/>
<par name="MaskAngleConcat" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="StoreTeachModelRowCenter" base_type="ctrl" dimension="0"/>
<par name="StoreTeachModelColCenter" base_type="ctrl" dimension="0"/>
<par name="StoreMatchModelCenterRow" base_type="ctrl" dimension="0"/>
<par name="StoreMatchModelCenterColumn" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<c></c>
<c>**** Step 1: Rotate wrt to Angle difference between Teach and Inspected Image.</c>
<l>if(FoV=1)</l>
<c>    *** Obtain the Top Row and Column based on Teach values</c>
<l>    ProjectedPVIRow := DeviceTopRowInspect-TopY_Shift</l>
<l>    ProjectedPVICol := DeviceTopColumnInspect-TopX_Shift</l>
<l>    AngleDiff       := DeviceAngle-DeviceAngleInspect</l>
<c>    </c>
<c>    **** Rotate the device Location</c>
<l>    Rotate_Function (InspectImage, DeviceLocationSelected, RegionAffineTrans, ImageRotate, DebugImageOut, DebugRegionOut, IsStepMode, AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, DebugMessageOut)</l>
<c>    </c>
<c>    </c>
<l>else</l>
<c>    *** Obtain the Top Row and Column based on Teach values</c>
<c>    *** Calculate Center Shifts.</c>
<l>    TopY_Shift:=Device2DCenter[0]-Rect2PVIRowCenter</l>
<l>    TopX_Shift:=Device2DCenter[1]-Rect2PVIRowCenter</l>
<c>    </c>
<l>    ProjectedPVIRow := Device2DCenterInspect[0]-TopY_Shift</l>
<l>    ProjectedPVICol := Device2DCenterInspect[1]-TopX_Shift</l>
<l>    AngleDiff       := DeviceAngle-DeviceAngleInspect</l>
<c>    </c>
<c>    *** Rotate the Projected top PVI point</c>
<l>    Rotate_Function (InspectImage, DeviceLocationSelected, RegionAffineTrans, ImageRotate, DebugImageOut1, DebugRegionOut1, IsStepMode1, AngleDiff, Device2DCenterInspect[0], Device2DCenterInspect[1], DebugMessageOut1)</l>
<c>    </c>
<c>    </c>
<l>endif</l>
<c></c>
<c>**** Step 2: Calculate the Shifts wrt to Top Points of Teach and Inspected.                    </c>
<l>TopReferencePoints (RegionAffineTrans, FoV, AffineTransTopRow, AffineTransTopCol, AffineTransTopAngle, AffineTrans2DCenter, AffineTransSize)</l>
<c></c>
<c>**** Alternate Method to find </c>
<l>if(AffineTransTopRow&gt;AffineTrans2DCenter[0])</l>
<l>    smallest_rectangle2(RegionAffineTrans, Row3, Column3, Phi2, Length11, Length21)</l>
<l>    opening_circle (RegionAffineTrans, RegionOpening, 20.5)</l>
<c></c>
<c>   </c>
<l>    smallest_rectangle2 (RegionOpening, Row, Column, Phi, Length1, Length2)</l>
<l>    gen_rectangle2 (Rectangle2, Row, Column, 0, Length1, Length2)</l>
<c>    </c>
<l>    smallest_rectangle1 (Rectangle2, Row11, Column11, Row21, Column21)</l>
<l>    gen_region_points (Region, Row11, Column11)</l>
<c>        </c>
<l>*     gen_cross_contour_xld (Cross, Row11, Column11, 60, Phi)</l>
<c></c>
<l>*     hom_mat2d_identity (HomMat2DIdentity)</l>
<l>*     hom_mat2d_rotate (HomMat2DIdentity, -Phi, Column, Row, HomMat2DRotate)</l>
<l>*     affine_trans_point_2d (HomMat2DRotate, Column11, Row11, Qx, Qy)</l>
<c>    </c>
<l>*     gen_cross_contour_xld (Cross, Qy, Qx, 60, Phi)</l>
<c>    </c>
<c>    </c>
<l>    TempY:= Row11-Row</l>
<l>    TempX:= Column11-Column</l>
<c>    </c>
<l>    RotatedX:=TempX*cos(-Phi)-TempY*sin(-Phi)</l>
<l>    RotatedY:=TempX*sin(-Phi)+TempY*cos(-Phi)</l>
<c>    </c>
<l>    AffineTransTopCol:=RotatedX+Column</l>
<l>    AffineTransTopRow:=RotatedY+Row</l>
<c>    </c>
<l>    gen_cross_contour_xld (Cross, AffineTransTopRow, AffineTransTopCol, 60, Phi)</l>
<c></c>
<c></c>
<l>endif</l>
<c></c>
<l>if(FoV=1)</l>
<l>    XShiftValue:=DeviceTopPoints[0]-AffineTransTopRow</l>
<l>    YShiftValue:=DeviceTopPoints[1]-AffineTransTopCol     </l>
<c>    </c>
<l>else</l>
<l>    YShiftValue:= Device2DCenter[1]-AffineTrans2DCenter[1]</l>
<l>    XShiftValue:= 0</l>
<l>endif</l>
<c></c>
<c>**** Step 3 : Translate the rotated image with shift calculated.</c>
<l>Translate_Function (RegionAffineTrans, ImageRotate, RegionAffineTrans1, ImageRotateShift, DebugImageOut3, DebugRegionOut3, IsStepMode3, XShiftValue, YShiftValue, 0, 0, DebugMessageOut3)</l>
<c></c>
<c></c>
<c>**** Step 4 : Pattern Matching of Datum in Rotated and Shifted image</c>
<c></c>
<l>if(CheckDatumForPVI)</l>
<c>    </c>
<l>    gen_empty_obj(FindModel)</l>
<c>    </c>
<l>    smallest_rectangle1 (DeviceLocationSelected, Row1, Column1, Row2, Column2)</l>
<l>    gen_rectangle1 (Rectangle1, Row1, Column1, Row2, Column2)</l>
<l>    region_features (Rectangle1, 'width', ValueW)</l>
<l>    region_features (Rectangle1, 'height', ValueH)</l>
<l>    MaxSearchWidth := round(ValueW/2)</l>
<l>    MaxSearchHeight := round(ValueH/2)</l>
<c>    </c>
<c>    </c>
<l>    MatchModelScore := []</l>
<c>    </c>
<l>    gen_empty_obj(ROI)</l>
<l>    NoOfModel := |StoreModelID|</l>
<l>    for Index := 0 to NoOfModel-1 by 1</l>
<l>        tuple_select_range (StorePatternTeachRows, 2*Index, 2*(Index+1)-1, PatternRowsCoord)</l>
<l>        tuple_select_range (StorePatternTeachCols, 2*Index, 2*(Index+1)-1, PatternColsCoord)</l>
<l>        gen_rectangle1(Rectangle, PatternRowsCoord[0], PatternColsCoord[0], PatternRowsCoord[1], PatternColsCoord[1])</l>
<c>        </c>
<l>        concat_obj(ROI, Rectangle, ROI)</l>
<l>    endfor</l>
<c>    </c>
<c>    *****</c>
<l>    offset := 100</l>
<l>    nSteps := MaxSearchWidth/offset</l>
<c>    *****</c>
<l>    for Mo := 0 to NoOfModel-1 by 1</l>
<c>        </c>
<l>        ModelID := StoreModelID[Mo]</l>
<l>        select_obj (ROI, ModelRegion, Mo+1)</l>
<l>        area_center(ModelRegion, Dummy, CenterRow, CenterColumn)</l>
<l>        TeachModelRowCenter:=[TeachModelRowCenter,CenterRow]</l>
<l>        TeachModelColCenter:=[TeachModelColCenter,CenterColumn]</l>
<c>        </c>
<l>        for StepIndex := 1 to nSteps by 1</l>
<l>            if (StorePatternSearchAreaAlongX &lt; MaxSearchWidth and StorePatternSearchAreaAlongY &lt; MaxSearchHeight)</l>
<c>                </c>
<l>                gen_rectangle2(SearchRegion, CenterRow, CenterColumn, 0, StorePatternSearchAreaAlongX, StorePatternSearchAreaAlongY)</l>
<c>                </c>
<l>                _Find_Model (ImageRotateShift, SearchRegion, ModelRegion, MatchModel, CenterRow, CenterColumn, ModelID, StoreMinAcceptanceScore, MaxRotationAngle, IsFindDatum1, MatchRow, MatchColumn, MatchAngle, MatchScore)</l>
<c>                </c>
<l>                if(|MatchRow| = 0)</l>
<l>                    StorePatternSearchAreaAlongX := StorePatternSearchAreaAlongX + offset</l>
<l>                    StorePatternSearchAreaAlongY := StorePatternSearchAreaAlongY + offset</l>
<l>                else</l>
<l>                    tuple_concat(MatchModelScore, MatchScore, MatchModelScore)</l>
<l>                    concat_obj(FindModel, MatchModel, FindModel)</l>
<l>                    MatchModelCenterRow := [MatchModelCenterRow, MatchRow]</l>
<l>                    MatchModelCenterColumn := [MatchModelCenterColumn, MatchColumn]</l>
<l>                    break</l>
<l>                endif</l>
<l>            else</l>
<l>                IsFindDatum := false</l>
<l>                return()</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor          </l>
<l>    StoreTeachModelRowCenter    := TeachModelRowCenter</l>
<l>    StoreTeachModelColCenter    := TeachModelColCenter</l>
<l>    StoreMatchModelCenterRow    := MatchModelCenterRow</l>
<l>    StoreMatchModelCenterColumn := MatchModelCenterColumn</l>
<l>endif</l>
<c></c>
<c>**** Step 5 : Calculate the Shift Offset wrt to Datums of Teach and Inspected.                     </c>
<c></c>
<c>**** Offset of first Datum</c>
<l>if(TeachModelRowCenter#[] or MatchModelCenterRow#[])</l>
<l>    OffsetX1:=   TeachModelRowCenter[0]-MatchModelCenterRow[0]   </l>
<l>    OffsetY1:=   TeachModelColCenter[0]-MatchModelCenterColumn[0]      </l>
<c>    </c>
<c>    **** Offset of Second Datum</c>
<l>    OffsetX2:=   TeachModelRowCenter[1]-MatchModelCenterRow[1]   </l>
<l>    OffsetY2:=   TeachModelColCenter[1]-MatchModelCenterColumn[1] </l>
<l>else</l>
<l>    OffsetX2:=  0  </l>
<l>    OffsetY2  :=0        </l>
<l>endif</l>
<c></c>
<c>**** Step 6 : Translate with the Offset values.</c>
<c></c>
<c></c>
<l>Translate_Function (RegionAffineTrans1, ImageRotateShift, RegionAffineTrans1WithOffset1, ImageRotateShiftWithOffset, DebugImageOut4, DebugRegionOut4, IsStepMode4, OffsetX2, OffsetY2, 0, 0, DebugMessageOut4)</l>
<c></c>
<c></c>
<c>*************************************************************</c>
<l>* if(DefectCharacteristics=0)</l>
<l>* sub_image (TeachObj, ImageRotateShiftWithOffset, ImageSub1, 1, 0)        </l>
<l>* else</l>
<l>* sub_image (ImageRotateShiftWithOffset, TeachObj, ImageSub1, 1, 0)                  </l>
<l>* endif</l>
<c></c>
<l>abs_diff_image (TeachObj, ImageRotateShiftWithOffset, ImageSub1, 1)</l>
<c></c>
<l>gen_empty_obj (FitPVIRegion)</l>
<l>gen_empty_obj (FitMaskRegion)</l>
<c></c>
<c>**** Generate the PVI Teach Region.</c>
<l>gen_rectangle2 (RegionForPVI_Inspection, Rect2PVIRowCenter, Rect2PVIColCenter, PVIAngle, PVIWidth, PVIHeight)</l>
<l>gen_empty_obj (ConcatMasks)</l>
<l>for maskIndex := 0 to NoOfMaskRegions-1 by 1</l>
<c>    </c>
<l>    SelectMask2DCenterPoints := Mask2DCenterPoints[2*maskIndex: 2*(maskIndex+1)-1]</l>
<l>    SelectMaskAngleConcat    := MaskAngleConcat[maskIndex]</l>
<l>    SelectMaskSize           := MaskSize[2*maskIndex: 2*(maskIndex+1)-1]</l>
<c>    </c>
<l>    gen_rectangle2 (RectMask, SelectMask2DCenterPoints[0], SelectMask2DCenterPoints[1], SelectMaskAngleConcat, SelectMaskSize[0], SelectMaskSize[1])</l>
<c>    </c>
<l>    concat_obj (ConcatMasks, RectMask, ConcatMasks)</l>
<l>endfor</l>
<c></c>
<l>FitPVIRegion:=RegionForPVI_Inspection</l>
<l>if(NoOfMaskRegions&gt;0)</l>
<l>    union1 (ConcatMasks, FitMaskRegion)</l>
<l>    difference (RegionForPVI_Inspection, FitMaskRegion, RegionForPVI_Inspection)</l>
<c>    </c>
<l>endif</l>
<c></c>
<c>*************************************************************</c>
<c>*** To get back to inspected image</c>
<l>Translate_Function (RegionForPVI_Inspection, ImageSub1, RegionAffineTransInspect, ImageRotateShiftInspect, DebugImageOut5, DebugRegionOut5, IsStepMode5, -OffsetX2, -OffsetY2, 0, 0, DebugMessageOut5)</l>
<c></c>
<l>Translate_Function (RegionAffineTransInspect, ImageRotateShiftInspect, RegionAffineTransInspectBack, ImageRotateShiftInspectBack, DebugImageOut6, DebugRegionOut6, IsStepMode6, -XShiftValue, -YShiftValue, 0, 0, DebugMessageOut6)</l>
<c></c>
<l>Rotate_Function (ImageRotateShiftInspectBack, RegionAffineTransInspectBack, RegionForPVI_Inspection, Sub_Image, DebugImageOut2, DebugRegionOut2, IsStepMode2, -AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, DebugMessageOut2)</l>
<c></c>
<l>reduce_domain (Sub_Image, RegionForPVI_Inspection, ImageForPVI_Inspection)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="RegionProjection">
<parameters>
<parameter id="CheckDatumForPVI"/>
<parameter id="Device2DCenter"/>
<parameter id="Device2DCenterInspect"/>
<parameter id="DeviceAngle"/>
<parameter id="DeviceAngleInspect"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="DeviceSize"/>
<parameter id="DeviceSizeInspect"/>
<parameter id="DeviceTopColumnInspect"/>
<parameter id="DeviceTopPoints"/>
<parameter id="DeviceTopRowInspect"/>
<parameter id="FitMaskRegion"/>
<parameter id="FitPVIRegion"/>
<parameter id="FoV"/>
<parameter id="ImageForPVI_Inspection"/>
<parameter id="InspectImage"/>
<parameter id="Mask2DCenterPoints"/>
<parameter id="MaskAngleConcat"/>
<parameter id="MaskSize"/>
<parameter id="MatchModelCenterColumn"/>
<parameter id="MatchModelCenterRow"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="PVIAngle"/>
<parameter id="PVIHeight"/>
<parameter id="PVIWidth"/>
<parameter id="Rect2PVIColCenter"/>
<parameter id="Rect2PVIRowCenter"/>
<parameter id="RegionForPVI_Inspection"/>
<parameter id="StoreMatchModelCenterColumn"/>
<parameter id="StoreMatchModelCenterRow"/>
<parameter id="StoreMinAcceptanceScore"/>
<parameter id="StoreModelID"/>
<parameter id="StorePatternSearchAreaAlongX"/>
<parameter id="StorePatternSearchAreaAlongY"/>
<parameter id="StorePatternTeachCols"/>
<parameter id="StorePatternTeachRows"/>
<parameter id="StoreTeachModelColCenter"/>
<parameter id="StoreTeachModelRowCenter"/>
<parameter id="Sub_Image"/>
<parameter id="TeachModelColCenter"/>
<parameter id="TeachModelRowCenter"/>
<parameter id="TeachObj"/>
<parameter id="TopX_Shift"/>
<parameter id="TopY_Shift"/>
</parameters>
</docu>
</procedure>
<procedure name="RetriveTeachValuesForRegionInspect">
<interface>
<ic>
<par name="PVITupleVector4Eachntensity" base_type="ctrl" dimension="2"/>
<par name="nPVIArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="NoOfMaskRegions" base_type="ctrl" dimension="0"/>
<par name="PVIAngle" base_type="ctrl" dimension="0"/>
<par name="PVI2DCenter" base_type="ctrl" dimension="0"/>
<par name="PVISize" base_type="ctrl" dimension="0"/>
<par name="Mask2DCenterPoints" base_type="ctrl" dimension="0"/>
<par name="MaskAngleConcat" base_type="ctrl" dimension="0"/>
<par name="MaskSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>NoOfMaskRegions             := PVITupleVector4Eachntensity.at(nPVIArea).at(1)</l>
<l>PVIAngle                    := PVITupleVector4Eachntensity.at(nPVIArea).at(2)</l>
<l>PVI2DCenter                 := PVITupleVector4Eachntensity.at(nPVIArea).at(3)</l>
<l>PVISize                     := PVITupleVector4Eachntensity.at(nPVIArea).at(4)</l>
<l>Mask2DCenterPoints          := PVITupleVector4Eachntensity.at(nPVIArea).at(5)          </l>
<l>MaskAngleConcat             := PVITupleVector4Eachntensity.at(nPVIArea).at(6)</l>
<l>MaskSize                    := PVITupleVector4Eachntensity.at(nPVIArea).at(7)</l>
<l>return ()  </l>
</body>
<docu id="RetriveTeachValuesForRegionInspect">
<parameters>
<parameter id="Mask2DCenterPoints"/>
<parameter id="MaskAngleConcat"/>
<parameter id="MaskSize"/>
<parameter id="NoOfMaskRegions"/>
<parameter id="PVI2DCenter"/>
<parameter id="PVIAngle"/>
<parameter id="PVISize"/>
<parameter id="PVITupleVector4Eachntensity"/>
<parameter id="nPVIArea"/>
</parameters>
</docu>
</procedure>
<procedure name="Rotate_Function">
<interface>
<io>
<par name="InspectImage" base_type="iconic" dimension="0"/>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionAffineTrans" base_type="iconic" dimension="0"/>
<par name="ImageRotate" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="AngleDiff" base_type="ctrl" dimension="0"/>
<par name="DeviceTopRowInspect" base_type="ctrl" dimension="0"/>
<par name="DeviceTopColumnInspect" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<c></c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, AngleDiff, DeviceTopRowInspect, DeviceTopColumnInspect, HomMat2DRotate)                   </l>
<l>affine_trans_region(DeviceLocationSelected, RegionAffineTrans, HomMat2DRotate, 'nearest_neighbor')</l>
<l>affine_trans_image(InspectImage, ImageRotate, HomMat2DRotate, 'constant', 'false')</l>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Inspection Image and Region After Rotation']</l>
<l>    _FCI_DebugParameters (ImageRotate, RegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="Rotate_Function">
<parameters>
<parameter id="AngleDiff"/>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="DeviceTopColumnInspect"/>
<parameter id="DeviceTopRowInspect"/>
<parameter id="ImageRotate"/>
<parameter id="InspectImage"/>
<parameter id="IsStepMode"/>
<parameter id="RegionAffineTrans"/>
</parameters>
</docu>
</procedure>
<procedure name="TopReferencePoints">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="DeviceLocationSelected" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="FoV" base_type="ctrl" dimension="0"/>
<par name="nFoVs" base_type="ctrl" dimension="0"/>
<par name="ReferencePointType" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DeviceTopPointRow" base_type="ctrl" dimension="0"/>
<par name="DeviceTopPointCol" base_type="ctrl" dimension="0"/>
<par name="DeviceAngle" base_type="ctrl" dimension="0"/>
<par name="Device2DCenter" base_type="ctrl" dimension="0"/>
<par name="DeviceSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>* /Reference Point type</c>
<l>TOP_LEFT := 0</l>
<l>TOP_RIGHT := 1</l>
<l>BOTTOM_LEFT := 2</l>
<l>BOTTOM_RIGHT := 3</l>
<l>ENCAP_EDGE_LEFT := 4</l>
<l>ENCAP_EDGE_RIGHT := 5</l>
<l>CENTER := 6</l>
<c></c>
<l>if(ReferencePointType &lt; 0 or ReferencePointType &gt; 6)</l>
<l>    ReferencePointType := CENTER</l>
<l>endif</l>
<c></c>
<l>DeviceTopPointRow    := 0</l>
<l>DeviceTopPointCol := 0</l>
<c></c>
<c>***</c>
<l>region_features (DeviceLocationSelected, 'width', DeviceWidth)</l>
<l>region_features (DeviceLocationSelected, 'height', DeviceHeight)</l>
<c></c>
<l>area_center (DeviceLocationSelected, Dummy, DeviceCntRow, DeviceCntColumn)</l>
<l>smallest_rectangle2(DeviceLocationSelected, Row3, Column3, Phi2, Length11, Length21)</l>
<l>gen_rectangle2(Rectangle1, Row3, Column3, Phi2, Length11, Length21)</l>
<c></c>
<c>****01-Aug</c>
<l>gen_rectangle2 (RefRectangle, Row3, Column3, Phi2, Length11, 0.25*Length21)</l>
<l>intersection (RefRectangle, DeviceLocationSelected, RegionIntersection)</l>
<l>opening_rectangle1 (RegionIntersection, RegionOpening1, 3, 3)</l>
<l>area_center (RegionOpening1, Area, Row, Column)</l>
<l>if(Area = 0)</l>
<l>    RegionOpening1 := RegionIntersection</l>
<l>endif</l>
<c></c>
<l>smallest_rectangle2 (RegionOpening1, Row2, Column2, Phi1, Length12, Length22)</l>
<l>gen_rectangle2 (ExpandRectangle, Row2, Column2, Phi1, Length12, 1.5*(DeviceHeight/2))</l>
<c></c>
<l>intersection (ExpandRectangle, DeviceLocationSelected, RegionIntersection1)</l>
<l>smallest_rectangle2 (RegionIntersection1, Row4, Column4, Phi3, Length13, Length23)</l>
<l>gen_rectangle2 (GetRectangleRgn, Row4, Column4, Phi3, Length13, Length23)</l>
<l>erosion_rectangle1 (GetRectangleRgn, ErosionRectAlongCol, 0.5, 2.5)</l>
<c></c>
<l>erosion_rectangle1 (GetRectangleRgn, ErosionRectAlongRow, 2.5, 0.5)</l>
<l>difference (GetRectangleRgn, ErosionRectAlongRow, RegionDifference2)</l>
<l>connection (RegionDifference2, ConnectedRegions1)</l>
<l>* sort_region (ConnectedRegions1, SortedRegions, 'character', 'true', 'row')</l>
<l>sort_region (ConnectedRegions1, SortedRegions, 'character', 'true', 'col')</l>
<c></c>
<l>if(ReferencePointType &lt; 4)</l>
<l>    if(ReferencePointType = TOP_LEFT or ReferencePointType = BOTTOM_LEFT)</l>
<l>        select_obj (SortedRegions, ObjectSelected, 1)</l>
<l>    else</l>
<l>        count_obj (SortedRegions, SortedRegionsCount)</l>
<l>        select_obj (SortedRegions, ObjectSelected, SortedRegionsCount)</l>
<l>    endif</l>
<c>    </c>
<c></c>
<l>    area_center (ObjectSelected, Area1, Row1, Column1)</l>
<l>    difference (ObjectSelected, ErosionRectAlongCol, RegionDifference3)</l>
<l>    connection (RegionDifference3, ConnectedRegions2)</l>
<l>    sort_region (ConnectedRegions2, SortedRegions1, 'character', 'true', 'row')</l>
<c>    </c>
<l>    if(ReferencePointType = TOP_LEFT or ReferencePointType = TOP_RIGHT)</l>
<l>        select_obj (SortedRegions1, ObjectSelected1, 1)</l>
<l>    else</l>
<l>        count_obj (SortedRegions1, SortedRegions1Count)</l>
<l>        select_obj (SortedRegions1, ObjectSelected1, SortedRegions1Count)</l>
<l>    endif</l>
<c>    </c>
<l>    area_center (ObjectSelected1, Dummy, DeviceTopPointRow, DeviceTopPointCol) </l>
<l>else</l>
<c></c>
<c></c>
<l>    if(ReferencePointType = CENTER)</l>
<l>       DeviceTopPointRow:= Row4</l>
<l>       DeviceTopPointCol:= Column4 </l>
<l>    else</l>
<l>       difference (GetRectangleRgn, ErosionRectAlongCol, RegionDifference2)</l>
<l>       connection (RegionDifference2, ConnectedRegions)</l>
<l>       sort_region (ConnectedRegions, SortedRegions, 'character', 'false', 'row')</l>
<l>       select_obj (SortedRegions, ObjectSelected, 1)</l>
<l>       dilation_rectangle1 (ObjectSelected, RegionDilation, 0.5, 10)</l>
<l>       intersection (RegionDilation, DeviceLocationSelected, RegionIntersection2)</l>
<l>       if(ReferencePointType = ENCAP_EDGE_LEFT)</l>
<l>           smallest_rectangle1 (RegionIntersection2, DeviceTopPointRow, DeviceTopPointCol, Dummy, Dummy)</l>
<l>       else</l>
<l>           smallest_rectangle1 (RegionIntersection2, Dummy, Dummy, DeviceTopPointRow, DeviceTopPointCol)</l>
<l>       endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<l>Device2DCenter:=[DeviceCntRow, DeviceCntColumn]</l>
<l>DeviceSize:=[Length11, Length21]</l>
<l>DeviceAngle := Phi2</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>***</c>
<l>* opening_circle (DeviceLocationSelected, RegionOpening, 20.5)</l>
<l>* area_center (RegionOpening, Area, Row1, Column1)</l>
<l>* if(Area=0)</l>
<l>*     opening_circle (DeviceLocationSelected, RegionOpening, 12.5)          </l>
<l>* endif</l>
<l>* smallest_rectangle2 (RegionOpening, Row, Column, Phi, Length1, Length2)</l>
<l>* gen_rectangle2 (Rectangle2, Row, Column, Phi, Length1, Length2)</l>
<c></c>
<l>* gen_rectangle2 (RectangleW, Row, Column, Phi, Length1-1, Length2+2)</l>
<l>* gen_rectangle2 (RectangleH, Row, Column, Phi, Length1+2.5, Length2-1)</l>
<c></c>
<l>* boundary(Rectangle2, RegionBorder, 'inner')</l>
<l>* boundary (Rectangle2, RegionBorder1, 'outer')</l>
<c></c>
<c>**********************************</c>
<l>* erosion_rectangle1(RegionBorder, RegionErosion1, 2.0, 0.5)</l>
<l>* dilation_rectangle1(RegionErosion1, RegionDilation1, 11, 11)</l>
<l>* erosion_rectangle1(RegionBorder, RegionErosion2, 0.5, 3.0)</l>
<l>* connection(RegionErosion1, ConnectedRegions1)</l>
<l>* select_shape_std(ConnectedRegions1, SelectedRegions, 'max_area', 70)</l>
<c></c>
<c></c>
<l>* dilation1(RegionErosion1, SelectedRegions, RegionDilation, 1)</l>
<c></c>
<l>* intersection(RegionErosion1, RegionErosion2, RegionIntersection)</l>
<c>****************************************</c>
<l>* if(FoV=1)</l>
<c>    </c>
<l>*     difference(RegionBorder, RectangleW, RegionDifference)</l>
<l>*     difference(RegionDifference, RectangleH, RegionDifference1)</l>
<l>*     connection (RegionDifference1, ConnectedRegions)</l>
<c>    </c>
<c>    ******</c>
<l>*     region_features (ConnectedRegions, 'column', ColumnValue)</l>
<l>*     region_features (ConnectedRegions, 'row', RowValue)</l>
<l>*     tuple_less_elem (ColumnValue, Column, Less)</l>
<l>*     tuple_find (Less, 1, Indices)</l>
<l>*     tuple_select (RowValue, Indices, Selected)</l>
<l>*     tuple_min (Selected, RefRow)</l>
<l>*     tuple_find (RowValue, RefRow, Indices1)</l>
<l>*     tuple_select (ColumnValue, Indices1[0], RefColumn)</l>
<c>    ******</c>
<l>*     DeviceTopPointRow := RefRow</l>
<l>*     DeviceTopPointCol := RefColumn</l>
<l>* endif</l>
<c>    </c>
<c></c>
</body>
<docu id="TopReferencePoints">
<parameters>
<parameter id="Device2DCenter"/>
<parameter id="DeviceAngle"/>
<parameter id="DeviceLocationSelected"/>
<parameter id="DeviceSize"/>
<parameter id="DeviceTopPointCol"/>
<parameter id="DeviceTopPointRow"/>
<parameter id="FoV"/>
<parameter id="Image"/>
<parameter id="ReferencePointType"/>
<parameter id="nFoVs"/>
</parameters>
</docu>
</procedure>
<procedure name="Translate_Function">
<interface>
<io>
<par name="RegionAffineTrans" base_type="iconic" dimension="0"/>
<par name="ImageRotate" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionAffineTrans1" base_type="iconic" dimension="0"/>
<par name="ImageRotateShift" base_type="iconic" dimension="0"/>
<par name="DebugImageOut" base_type="iconic" dimension="0"/>
<par name="DebugRegionOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="IsStepMode" base_type="ctrl" dimension="0"/>
<par name="XShiftValue" base_type="ctrl" dimension="0"/>
<par name="YShiftValue" base_type="ctrl" dimension="0"/>
<par name="OffsetX" base_type="ctrl" dimension="0"/>
<par name="OffsetY" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DebugMessageOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>***Debug Parameter</c>
<l>gen_empty_obj (DebugImageOut)</l>
<l>gen_empty_obj (DebugRegionOut)</l>
<l>DebugMessageOut :=  []</l>
<c></c>
<l>hom_mat2d_identity (HomMat2DIdentity3)</l>
<l>hom_mat2d_translate (HomMat2DIdentity3, XShiftValue-OffsetX, YShiftValue-OffsetY, HomMat2DTranslate1)</l>
<l>affine_trans_region (RegionAffineTrans, RegionAffineTrans1, HomMat2DTranslate1, 'nearest_neighbor')</l>
<l>affine_trans_image(ImageRotate, ImageRotateShift, HomMat2DTranslate1, 'constant', 'false')</l>
<c></c>
<c></c>
<l>if (IsStepMode)</l>
<l>    Message := ['Inspection Image and Region After Translate']</l>
<l>    _FCI_DebugParameters (ImageRotate, RegionAffineTrans, DebugImageOut, DebugRegionOut, DebugImageOut, DebugRegionOut, Message, DebugMessageOut, DebugMessageOut)</l>
<l>endif    </l>
<c></c>
<l>return ()</l>
</body>
<docu id="Translate_Function">
<parameters>
<parameter id="DebugImageOut"/>
<parameter id="DebugMessageOut"/>
<parameter id="DebugRegionOut"/>
<parameter id="ImageRotate"/>
<parameter id="ImageRotateShift"/>
<parameter id="IsStepMode"/>
<parameter id="OffsetX"/>
<parameter id="OffsetY"/>
<parameter id="RegionAffineTrans"/>
<parameter id="RegionAffineTrans1"/>
<parameter id="XShiftValue"/>
<parameter id="YShiftValue"/>
</parameters>
</docu>
</procedure>
</hdevelop>
